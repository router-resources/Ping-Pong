import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _typeof from '@babel/runtime/helpers/typeof';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';
import { post, generateJsonRPCObject, get, setAPIKey, setEmbedHost } from '@toruslabs/http-helpers';
import BN from 'bn.js';
import { ec } from 'elliptic';
import JsonStringify from 'json-stable-stringify';
import { keccak256, toChecksumAddress } from 'web3-utils';
import loglevel from 'loglevel';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';

var log = loglevel.getLogger('torus.js');
log.disableAll();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

var SomeError = /*#__PURE__*/function (_Error) {
  _inherits(SomeError, _Error);

  var _super = _createSuper$1(SomeError);

  function SomeError(_ref) {
    var _this;

    var errors = _ref.errors,
        responses = _ref.responses,
        predicate = _ref.predicate;

    _classCallCheck(this, SomeError);

    _this = _super.call(this, 'Unable to resolve enough promises.');
    _this.errors = errors;
    _this.responses = responses;
    _this.predicate = predicate;
    return _this;
  }

  return _createClass(SomeError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var Some = function Some(promises, predicate) {
  return new Promise(function (resolve, reject) {
    var finishedCount = 0;
    var sharedState = {
      resolved: false
    };
    var errorArr = new Array(promises.length).fill(undefined);
    var resultArr = new Array(promises.length).fill(undefined);
    var predicateError;
    promises.forEach(function (x, index) {
      x.then(function (resp) {
        resultArr[index] = resp;
        return undefined;
      }).catch(function (error) {
        errorArr[index] = error;
      }).finally(function () {
        if (sharedState.resolved) return;
        predicate(resultArr.slice(0), sharedState).then(function (data) {
          sharedState.resolved = true;
          resolve(data);
          return undefined;
        }).catch(function (error) {
          // log only the last predicate error
          predicateError = error;
        }).finally(function (_) {
          finishedCount += 1;

          if (finishedCount === promises.length) {
            var errors = Object.values(resultArr.reduce(function (acc, z) {
              var _error$data;

              var _ref2 = z || {},
                  id = _ref2.id,
                  error = _ref2.error;

              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {
                if (error.data.startsWith('Error occurred while verifying params')) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;
              }

              return acc;
            }, {}));

            if (errors.length > 0) {
              // Format-able errors
              var msg = errors.length > 1 ? "\n".concat(errors.map(function (it) {
                return "\u2022 ".concat(it);
              }).join('\n')) : errors[0];
              reject(new Error(msg));
            } else {
              var _predicateError;

              reject(new SomeError({
                errors: errorArr,
                responses: resultArr,
                predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError
              }));
            }
          }
        });
      });
    });
  });
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var GetOrSetNonceError = /*#__PURE__*/function (_Error) {
  _inherits(GetOrSetNonceError, _Error);

  var _super = _createSuper(GetOrSetNonceError);

  function GetOrSetNonceError() {
    _classCallCheck(this, GetOrSetNonceError);

    return _super.apply(this, arguments);
  }

  return _createClass(GetOrSetNonceError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var kCombinations = function kCombinations(s, k) {
  var set = s;

  if (typeof set === 'number') {
    set = Array.from({
      length: set
    }, function (_, i) {
      return i;
    });
  }

  if (k > set.length || k <= 0) {
    return [];
  }

  if (k === set.length) {
    return [set];
  }

  if (k === 1) {
    return set.reduce(function (acc, cur) {
      return [].concat(_toConsumableArray(acc), [[cur]]);
    }, []);
  }

  var combs = [];
  var tailCombs = [];

  for (var i = 0; i <= set.length - k + 1; i += 1) {
    tailCombs = kCombinations(set.slice(i + 1), k - 1);

    for (var j = 0; j < tailCombs.length; j += 1) {
      combs.push([set[i]].concat(_toConsumableArray(tailCombs[j])));
    }
  }

  return combs;
};
var thresholdSame = function thresholdSame(arr, t) {
  var hashMap = {};

  for (var i = 0; i < arr.length; i += 1) {
    var str = JsonStringify(arr[i]);
    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;

    if (hashMap[str] === t) {
      return arr[i];
    }
  }

  return undefined;
};
var keyLookup = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(endpoints, verifier, verifierId) {
    var lookupPromises;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            lookupPromises = endpoints.map(function (x) {
              return post(x, generateJsonRPCObject('VerifierLookupRequest', {
                verifier: verifier,
                verifier_id: verifierId.toString()
              })).catch(function (err) {
                return log.error('lookup request failed', err);
              });
            });
            return _context.abrupt("return", Some(lookupPromises, function (lookupResults) {
              var lookupShares = lookupResults.filter(function (x1) {
                return x1;
              });
              var errorResult = thresholdSame(lookupShares.map(function (x2) {
                return x2 && x2.error;
              }), ~~(endpoints.length / 2) + 1);
              var keyResult = thresholdSame(lookupShares.map(function (x3) {
                return x3 && x3.result;
              }), ~~(endpoints.length / 2) + 1);

              if (keyResult || errorResult) {
                return Promise.resolve({
                  keyResult: keyResult,
                  errorResult: errorResult
                });
              }

              return Promise.reject(new Error("invalid results ".concat(JSON.stringify(lookupResults))));
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function keyLookup(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
var waitKeyLookup = function waitKeyLookup(endpoints, verifier, verifierId, timeout) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);
    }, timeout);
  });
};
var keyAssign = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {
    var endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId, signerHost, nodeNum, initialPoint, data, signedData, acceptedErrorMsgs;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            endpoints = _ref2.endpoints, torusNodePubs = _ref2.torusNodePubs, lastPoint = _ref2.lastPoint, firstPoint = _ref2.firstPoint, verifier = _ref2.verifier, verifierId = _ref2.verifierId, signerHost = _ref2.signerHost;

            if (lastPoint === undefined) {
              nodeNum = Math.floor(Math.random() * endpoints.length);
              initialPoint = nodeNum;
            } else {
              nodeNum = lastPoint % endpoints.length;
            }

            if (!(nodeNum === firstPoint)) {
              _context2.next = 4;
              break;
            }

            throw new Error('Looped through all');

          case 4:
            if (firstPoint !== undefined) initialPoint = firstPoint;
            data = generateJsonRPCObject('KeyAssign', {
              verifier: verifier,
              verifier_id: verifierId.toString()
            });
            _context2.prev = 6;
            _context2.next = 9;
            return post(signerHost, data, {
              headers: {
                pubKeyX: torusNodePubs[nodeNum].X,
                pubKeyY: torusNodePubs[nodeNum].Y
              }
            }, {
              useAPIKey: true
            });

          case 9:
            signedData = _context2.sent;
            return _context2.abrupt("return", post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {
              headers: {
                'Content-Type': 'application/json; charset=utf-8'
              }
            }));

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](6);
            log.error(_context2.t0);
            acceptedErrorMsgs = [// Slow node
            'Timed out', // Happens when the node is not reachable (dns issue etc)
            'TypeError: Failed to fetch', // All except iOS and Firefox
            'TypeError: cancelled', // iOS
            'TypeError: NetworkError when attempting to fetch resource.' // Firefox
            ];

            if (!acceptedErrorMsgs.includes(_context2.t0.message)) {
              _context2.next = 19;
              break;
            }

            return _context2.abrupt("return", keyAssign({
              endpoints: endpoints,
              torusNodePubs: torusNodePubs,
              lastPoint: nodeNum + 1,
              firstPoint: initialPoint,
              verifier: verifier,
              verifierId: verifierId,
              signerHost: signerHost
            }));

          case 19:
            throw new Error("Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \n\n    ".concat(_context2.t0.message || ''));

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[6, 13]]);
  }));

  return function keyAssign(_x4) {
    return _ref3.apply(this, arguments);
  };
}();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// of Torus nodes to handle malicious node responses

var Torus = /*#__PURE__*/function () {
  function Torus() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$enableOneKey = _ref.enableOneKey,
        enableOneKey = _ref$enableOneKey === void 0 ? false : _ref$enableOneKey,
        _ref$metadataHost = _ref.metadataHost,
        metadataHost = _ref$metadataHost === void 0 ? 'https://metadata.tor.us' : _ref$metadataHost,
        _ref$allowHost = _ref.allowHost,
        allowHost = _ref$allowHost === void 0 ? 'https://signer.tor.us/api/allow' : _ref$allowHost,
        _ref$signerHost = _ref.signerHost,
        signerHost = _ref$signerHost === void 0 ? 'https://signer.tor.us/api/sign' : _ref$signerHost,
        _ref$serverTimeOffset = _ref.serverTimeOffset,
        serverTimeOffset = _ref$serverTimeOffset === void 0 ? 0 : _ref$serverTimeOffset;

    _classCallCheck(this, Torus);

    this.ec = new ec('secp256k1');
    this.metadataHost = metadataHost;
    this.allowHost = allowHost;
    this.enableOneKey = enableOneKey;
    this.serverTimeOffset = serverTimeOffset || 0; // ms

    this.signerHost = signerHost;
  }

  _createClass(Torus, [{
    key: "getUserTypeAndAddress",
    value:
    /**
     * Note: use this function only for openlogin tkey account lookups.
     */
    function () {
      var _getUserTypeAndAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(endpoints, torusNodePubs, _ref2) {
        var verifier,
            verifierId,
            doesKeyAssign,
            _ref3,
            keyResult,
            errorResult,
            isNewKey,
            finalKeyResult,
            assignResult,
            _finalKeyResult$keys$,
            X,
            Y,
            typeOfUser,
            nonce,
            pubNonce,
            modifiedPubKey,
            upgraded,
            _yield$this$getOrSetN,
            finalX,
            finalY,
            address,
            _args = arguments;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                verifier = _ref2.verifier, verifierId = _ref2.verifierId;
                doesKeyAssign = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
                _context.next = 4;
                return keyLookup(endpoints, verifier, verifierId);

              case 4:
                _context.t0 = _context.sent;

                if (_context.t0) {
                  _context.next = 7;
                  break;
                }

                _context.t0 = {};

              case 7:
                _ref3 = _context.t0;
                keyResult = _ref3.keyResult;
                errorResult = _ref3.errorResult;
                isNewKey = false;

                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned'))) {
                  _context.next = 26;
                  break;
                }

                if (doesKeyAssign) {
                  _context.next = 14;
                  break;
                }

                throw new Error('Verifier + VerifierID has not yet been assigned');

              case 14:
                _context.next = 16;
                return keyAssign({
                  endpoints: endpoints,
                  torusNodePubs: torusNodePubs,
                  lastPoint: undefined,
                  firstPoint: undefined,
                  verifier: verifier,
                  verifierId: verifierId,
                  signerHost: this.signerHost
                });

              case 16:
                _context.next = 18;
                return waitKeyLookup(endpoints, verifier, verifierId, 1000);

              case 18:
                _context.t1 = _context.sent;

                if (_context.t1) {
                  _context.next = 21;
                  break;
                }

                _context.t1 = {};

              case 21:
                assignResult = _context.t1;
                finalKeyResult = assignResult.keyResult;
                isNewKey = true;
                _context.next = 31;
                break;

              case 26:
                if (!keyResult) {
                  _context.next = 30;
                  break;
                }

                finalKeyResult = keyResult;
                _context.next = 31;
                break;

              case 30:
                throw new Error("node results do not match at first lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 31:
                if (!finalKeyResult) {
                  _context.next = 61;
                  break;
                }

                _finalKeyResult$keys$ = finalKeyResult.keys[0], X = _finalKeyResult$keys$.pub_key_X, Y = _finalKeyResult$keys$.pub_key_Y;
                _context.prev = 33;
                _context.next = 37;
                return this.getOrSetNonce(X, Y, undefined, !isNewKey);

              case 37:
                _yield$this$getOrSetN = _context.sent;
                typeOfUser = _yield$this$getOrSetN.typeOfUser;
                nonce = _yield$this$getOrSetN.nonce;
                pubNonce = _yield$this$getOrSetN.pubNonce;
                upgraded = _yield$this$getOrSetN.upgraded;
                nonce = new BN(nonce || '0', 16);
                _context.next = 48;
                break;

              case 45:
                _context.prev = 45;
                _context.t2 = _context["catch"](33);
                throw new GetOrSetNonceError();

              case 48:
                if (!(typeOfUser === 'v1')) {
                  _context.next = 52;
                  break;
                }

                modifiedPubKey = this.ec.keyFromPublic({
                  x: X.toString(16),
                  y: Y.toString(16)
                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());
                _context.next = 57;
                break;

              case 52:
                if (!(typeOfUser === 'v2')) {
                  _context.next = 56;
                  break;
                }

                modifiedPubKey = this.ec.keyFromPublic({
                  x: X.toString(16),
                  y: Y.toString(16)
                }).getPublic().add(this.ec.keyFromPublic({
                  x: pubNonce.x,
                  y: pubNonce.y
                }).getPublic());
                _context.next = 57;
                break;

              case 56:
                throw new Error('getOrSetNonce should always return typeOfUser.');

              case 57:
                finalX = modifiedPubKey.getX().toString(16);
                finalY = modifiedPubKey.getY().toString(16);
                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());
                return _context.abrupt("return", {
                  typeOfUser: typeOfUser,
                  nonce: nonce,
                  pubNonce: pubNonce,
                  upgraded: upgraded,
                  X: finalX,
                  Y: finalY,
                  address: address
                });

              case 61:
                throw new Error("node results do not match at final lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 62:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[33, 45]]);
      }));

      function getUserTypeAndAddress(_x, _x2, _x3) {
        return _getUserTypeAndAddress.apply(this, arguments);
      }

      return getUserTypeAndAddress;
    }()
  }, {
    key: "setCustomKey",
    value: function () {
      var _setCustomKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref4) {
        var privKeyHex, metadataNonce, torusKeyHex, customKeyHex, torusKey, privKey, customKey, newMetadataNonce, data;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                privKeyHex = _ref4.privKeyHex, metadataNonce = _ref4.metadataNonce, torusKeyHex = _ref4.torusKeyHex, customKeyHex = _ref4.customKeyHex;

                if (torusKeyHex) {
                  torusKey = new BN(torusKeyHex, 16);
                } else {
                  privKey = new BN(privKeyHex, 16);
                  torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);
                }

                customKey = new BN(customKeyHex, 16);
                newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);
                data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey.toString(16));
                _context2.next = 7;
                return this.setMetadata(data);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setCustomKey(_x4) {
        return _setCustomKey.apply(this, arguments);
      }

      return setCustomKey;
    }()
  }, {
    key: "retrieveShares",
    value: function () {
      var _retrieveShares = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(endpoints, indexes, verifier, verifierParams, idToken) {
        var _this = this;

        var extraParams,
            promiseArr,
            tmpKey,
            pubKey,
            pubKeyX,
            pubKeyY,
            tokenCommitment,
            i,
            p,
            _args5 = arguments;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                extraParams = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : {};
                promiseArr = [];
                _context5.next = 4;
                return get(this.allowHost, {
                  headers: {
                    verifier: verifier,
                    verifier_id: verifierParams.verifier_id
                  }
                }, {
                  useAPIKey: true
                });

              case 4:
                /*
                  CommitmentRequestParams struct {
                    MessagePrefix      string `json:"messageprefix"`
                    TokenCommitment    string `json:"tokencommitment"`
                    TempPubX           string `json:"temppubx"`
                    TempPubY           string `json:"temppuby"`
                    VerifierIdentifier string `json:"verifieridentifier"`
                  } 
                  */
                // generate temporary private and public key that is used to secure receive shares
                tmpKey = generatePrivate();
                pubKey = getPublic(tmpKey).toString('hex');
                pubKeyX = pubKey.slice(2, 66);
                pubKeyY = pubKey.slice(66);
                tokenCommitment = keccak256(idToken); // make commitment requests to endpoints

                for (i = 0; i < endpoints.length; i += 1) {
                  p = post(endpoints[i], generateJsonRPCObject('CommitmentRequest', {
                    messageprefix: 'mug00',
                    tokencommitment: tokenCommitment.slice(2),
                    temppubx: pubKeyX,
                    temppuby: pubKeyY,
                    verifieridentifier: verifier
                  })).catch(function (err) {
                    return log.error('commitment', err);
                  });
                  promiseArr.push(p);
                }
                /*
                  ShareRequestParams struct {
                    Item []bijson.RawMessage `json:"item"`
                  }
                  ShareRequestItem struct {
                    IDToken            string          `json:"idtoken"`
                    NodeSignatures     []NodeSignature `json:"nodesignatures"`
                    VerifierIdentifier string          `json:"verifieridentifier"`
                  }
                  NodeSignature struct {
                    Signature   string
                    Data        string
                    NodePubKeyX string
                    NodePubKeyY string
                  }
                  CommitmentRequestResult struct {
                    Signature string `json:"signature"`
                    Data      string `json:"data"`
                    NodePubX  string `json:"nodepubx"`
                    NodePubY  string `json:"nodepuby"`
                  }
                  */
                // send share request once k + t number of commitment requests have completed


                return _context5.abrupt("return", Some(promiseArr, function (resultArr) {
                  var completedRequests = resultArr.filter(function (x) {
                    if (!x || _typeof(x) !== 'object') {
                      return false;
                    }

                    if (x.error) {
                      return false;
                    }

                    return true;
                  });

                  if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {
                    return Promise.resolve(resultArr);
                  }

                  return Promise.reject(new Error("invalid ".concat(JSON.stringify(resultArr))));
                }).then(function (responses) {
                  var promiseArrRequest = [];
                  var nodeSigs = [];

                  for (var _i = 0; _i < responses.length; _i += 1) {
                    if (responses[_i]) nodeSigs.push(responses[_i].result);
                  }

                  for (var _i2 = 0; _i2 < endpoints.length; _i2 += 1) {
                    // eslint-disable-next-line promise/no-nesting
                    var _p = post(endpoints[_i2], generateJsonRPCObject('ShareRequest', {
                      encrypted: 'yes',
                      item: [_objectSpread(_objectSpread({}, verifierParams), {}, {
                        idtoken: idToken,
                        nodesignatures: nodeSigs,
                        verifieridentifier: verifier
                      }, extraParams)]
                    })).catch(function (err) {
                      return log.error('share req', err);
                    });

                    promiseArrRequest.push(_p);
                  }

                  return Some(promiseArrRequest, /*#__PURE__*/function () {
                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(shareResponses, sharedState) {
                      var completedRequests, thresholdPublicKey, sharePromises, nodeIndex, _i3, metadata, sharesResolved, decryptedShares, allCombis, privateKey, _loop, j, _ret;

                      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              /*
                                  ShareRequestResult struct {
                                    Keys []KeyAssignment
                                  }
                                          / KeyAssignmentPublic -
                                  type KeyAssignmentPublic struct {
                                    Index     big.Int
                                    PublicKey common.Point
                                    Threshold int
                                    Verifiers map[string][]string // Verifier => VerifierID
                                  }
                                   // KeyAssignment -
                                  type KeyAssignment struct {
                                    KeyAssignmentPublic
                                    Share big.Int // Or Si
                                  }
                                */
                              // check if threshold number of nodes have returned the same user public key
                              completedRequests = shareResponses.filter(function (x) {
                                return x;
                              });
                              thresholdPublicKey = thresholdSame(shareResponses.map(function (x) {
                                return x && x.result && x.result.keys[0].PublicKey;
                              }), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received
                              // this is matched against the user public key to ensure that shares are consistent

                              if (!(completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey)) {
                                _context3.next = 25;
                                break;
                              }

                              sharePromises = [];
                              nodeIndex = [];

                              for (_i3 = 0; _i3 < shareResponses.length; _i3 += 1) {
                                if (shareResponses[_i3] && shareResponses[_i3].result && shareResponses[_i3].result.keys && shareResponses[_i3].result.keys.length > 0) {
                                  shareResponses[_i3].result.keys.sort(function (a, b) {
                                    return new BN(a.Index, 16).cmp(new BN(b.Index, 16));
                                  });

                                  if (shareResponses[_i3].result.keys[0].Metadata) {
                                    metadata = {
                                      ephemPublicKey: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.ephemPublicKey, 'hex'),
                                      iv: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.iv, 'hex'),
                                      mac: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mac, 'hex'),
                                      mode: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mode, 'hex')
                                    };
                                    sharePromises.push( // eslint-disable-next-line promise/no-nesting
                                    decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {
                                      ciphertext: Buffer.from(atob(shareResponses[_i3].result.keys[0].Share).padStart(64, '0'), 'hex')
                                    })).catch(function (err) {
                                      return log.debug('share decryption', err);
                                    }));
                                  } else {
                                    sharePromises.push(Promise.resolve(Buffer.from(shareResponses[_i3].result.keys[0].Share.padStart(64, '0'), 'hex')));
                                  }
                                } else {
                                  sharePromises.push(Promise.resolve(undefined));
                                }

                                nodeIndex.push(new BN(indexes[_i3], 16));
                              }

                              _context3.next = 8;
                              return Promise.all(sharePromises);

                            case 8:
                              sharesResolved = _context3.sent;

                              if (!sharedState.resolved) {
                                _context3.next = 11;
                                break;
                              }

                              return _context3.abrupt("return", undefined);

                            case 11:
                              decryptedShares = sharesResolved.reduce(function (acc, curr, index) {
                                if (curr) acc.push({
                                  index: nodeIndex[index],
                                  value: new BN(curr)
                                });
                                return acc;
                              }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit

                              // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit
                              allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);

                              _loop = function _loop(j) {
                                var currentCombi = allCombis[j];
                                var currentCombiShares = decryptedShares.filter(function (v, index) {
                                  return currentCombi.includes(index);
                                });
                                var shares = currentCombiShares.map(function (x) {
                                  return x.value;
                                });
                                var indices = currentCombiShares.map(function (x) {
                                  return x.index;
                                });

                                var derivedPrivateKey = _this.lagrangeInterpolation(shares, indices);

                                var decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex');
                                var decryptedPubKeyX = decryptedPubKey.slice(2, 66);
                                var decryptedPubKeyY = decryptedPubKey.slice(66);

                                if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {
                                  privateKey = derivedPrivateKey;
                                  return "break";
                                }
                              };

                              j = 0;

                            case 15:
                              if (!(j < allCombis.length)) {
                                _context3.next = 22;
                                break;
                              }

                              _ret = _loop(j);

                              if (!(_ret === "break")) {
                                _context3.next = 19;
                                break;
                              }

                              return _context3.abrupt("break", 22);

                            case 19:
                              j += 1;
                              _context3.next = 15;
                              break;

                            case 22:
                              if (!(privateKey === undefined)) {
                                _context3.next = 24;
                                break;
                              }

                              throw new Error('could not derive private key');

                            case 24:
                              return _context3.abrupt("return", privateKey);

                            case 25:
                              throw new Error('invalid');

                            case 26:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3);
                    }));

                    return function (_x10, _x11) {
                      return _ref5.apply(this, arguments);
                    };
                  }());
                }).then( /*#__PURE__*/function () {
                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(returnedKey) {
                    var privateKey, decryptedPubKey, decryptedPubKeyX, decryptedPubKeyY, metadataNonce, _yield$_this$getNonce, nonce, ethAddress;

                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            privateKey = returnedKey;
                            decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), 'hex')).toString('hex');
                            decryptedPubKeyX = decryptedPubKey.slice(2, 66);
                            decryptedPubKeyY = decryptedPubKey.slice(66);

                            if (!_this.enableOneKey) {
                              _context4.next = 12;
                              break;
                            }

                            _context4.next = 7;
                            return _this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);

                          case 7:
                            _yield$_this$getNonce = _context4.sent;
                            nonce = _yield$_this$getNonce.nonce;
                            metadataNonce = new BN(nonce || '0', 16);
                            _context4.next = 15;
                            break;

                          case 12:
                            _context4.next = 14;
                            return _this.getMetadata({
                              pub_key_X: decryptedPubKeyX,
                              pub_key_Y: decryptedPubKeyY
                            });

                          case 14:
                            metadataNonce = _context4.sent;

                          case 15:
                            log.debug('> torus.js/retrieveShares', {
                              privKey: privateKey.toString(16),
                              metadataNonce: metadataNonce.toString(16)
                            });
                            privateKey = privateKey.add(metadataNonce).umod(_this.ec.curve.n);
                            ethAddress = _this.generateAddressFromPrivKey(privateKey);
                            log.debug('> torus.js/retrieveShares', {
                              ethAddress: ethAddress,
                              privKey: privateKey.toString(16)
                            }); // return reconstructed private key and ethereum address

                            return _context4.abrupt("return", {
                              ethAddress: ethAddress,
                              privKey: privateKey.toString('hex', 64),
                              metadataNonce: metadataNonce
                            });

                          case 20:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x12) {
                    return _ref6.apply(this, arguments);
                  };
                }()));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function retrieveShares(_x5, _x6, _x7, _x8, _x9) {
        return _retrieveShares.apply(this, arguments);
      }

      return retrieveShares;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(data, options) {
        var metadataResponse;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return post("".concat(this.metadataHost, "/get"), data, options, {
                  useAPIKey: true
                });

              case 3:
                metadataResponse = _context6.sent;

                if (!(!metadataResponse || !metadataResponse.message)) {
                  _context6.next = 6;
                  break;
                }

                return _context6.abrupt("return", new BN(0));

              case 6:
                return _context6.abrupt("return", new BN(metadataResponse.message, 16));

              case 9:
                _context6.prev = 9;
                _context6.t0 = _context6["catch"](0);
                log.error('get metadata error', _context6.t0);
                return _context6.abrupt("return", new BN(0));

              case 13:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 9]]);
      }));

      function getMetadata(_x13, _x14) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
  }, {
    key: "generateMetadataParams",
    value: function generateMetadataParams(message, privateKey) {
      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64));
      var setData = {
        data: message,
        timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)
      };
      var sig = key.sign(keccak256(JsonStringify(setData)).slice(2));
      return {
        pub_key_X: key.getPublic().getX().toString('hex'),
        pub_key_Y: key.getPublic().getY().toString('hex'),
        set_data: setData,
        signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(sig.v).toString(16, 2), 'hex').toString('base64')
      };
    }
  }, {
    key: "setMetadata",
    value: function () {
      var _setMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data, options) {
        var metadataResponse;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                _context7.next = 3;
                return post("".concat(this.metadataHost, "/set"), data, options, {
                  useAPIKey: true
                });

              case 3:
                metadataResponse = _context7.sent;
                return _context7.abrupt("return", metadataResponse.message);

              case 7:
                _context7.prev = 7;
                _context7.t0 = _context7["catch"](0);
                log.error('set metadata error', _context7.t0);
                return _context7.abrupt("return", '');

              case 11:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[0, 7]]);
      }));

      function setMetadata(_x15, _x16) {
        return _setMetadata.apply(this, arguments);
      }

      return setMetadata;
    }()
  }, {
    key: "lagrangeInterpolation",
    value: function lagrangeInterpolation(shares, nodeIndex) {
      if (shares.length !== nodeIndex.length) {
        return null;
      }

      var secret = new BN(0);

      for (var i = 0; i < shares.length; i += 1) {
        var upper = new BN(1);
        var lower = new BN(1);

        for (var j = 0; j < shares.length; j += 1) {
          if (i !== j) {
            upper = upper.mul(nodeIndex[j].neg());
            upper = upper.umod(this.ec.curve.n);
            var temp = nodeIndex[i].sub(nodeIndex[j]);
            temp = temp.umod(this.ec.curve.n);
            lower = lower.mul(temp).umod(this.ec.curve.n);
          }
        }

        var delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);
        delta = delta.mul(shares[i]).umod(this.ec.curve.n);
        secret = secret.add(delta);
      }

      return secret.umod(this.ec.curve.n);
    }
  }, {
    key: "generateAddressFromPrivKey",
    value: function generateAddressFromPrivKey(privateKey) {
      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex');
      var publicKey = key.getPublic().encode('hex').slice(2);
      var ethAddressLower = "0x".concat(keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38));
      return toChecksumAddress(ethAddressLower);
    }
  }, {
    key: "generateAddressFromPubKey",
    value: function generateAddressFromPubKey(publicKeyX, publicKeyY) {
      var key = this.ec.keyFromPublic({
        x: publicKeyX.toString('hex', 64),
        y: publicKeyY.toString('hex', 64)
      });
      var publicKey = key.getPublic().encode('hex').slice(2);
      var ethAddressLower = "0x".concat(keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38));
      return toChecksumAddress(ethAddressLower);
    }
    /**
     * Note: use this function only with custom auth, don't use to lookup openlogin accounts.
     */

  }, {
    key: "getPublicAddress",
    value: function () {
      var _getPublicAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(endpoints, torusNodePubs, _ref7) {
        var verifier,
            verifierId,
            isExtended,
            finalKeyResult,
            isNewKey,
            _ref8,
            keyResult,
            errorResult,
            assignResult,
            _nonce,
            _finalKeyResult$keys$2,
            X,
            Y,
            typeOfUser,
            nonce,
            pubNonce,
            modifiedPubKey,
            upgraded,
            _yield$this$getOrSetN2,
            address,
            _args8 = arguments;

        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                verifier = _ref7.verifier, verifierId = _ref7.verifierId;
                isExtended = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : false;
                log.debug('> torus.js/getPublicAddress', {
                  endpoints: endpoints,
                  torusNodePubs: torusNodePubs,
                  verifier: verifier,
                  verifierId: verifierId,
                  isExtended: isExtended
                });
                isNewKey = false;
                _context8.next = 6;
                return keyLookup(endpoints, verifier, verifierId);

              case 6:
                _context8.t0 = _context8.sent;

                if (_context8.t0) {
                  _context8.next = 9;
                  break;
                }

                _context8.t0 = {};

              case 9:
                _ref8 = _context8.t0;
                keyResult = _ref8.keyResult;
                errorResult = _ref8.errorResult;

                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier not supported'))) {
                  _context8.next = 16;
                  break;
                }

                throw new Error("Verifier not supported. Check if you: \n\n      1. Are on the right network (Torus testnet/mainnet) \n\n      2. Have setup a verifier on dashboard.web3auth.io?");

              case 16:
                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned'))) {
                  _context8.next = 29;
                  break;
                }

                _context8.next = 19;
                return keyAssign({
                  endpoints: endpoints,
                  torusNodePubs: torusNodePubs,
                  lastPoint: undefined,
                  firstPoint: undefined,
                  verifier: verifier,
                  verifierId: verifierId,
                  signerHost: this.signerHost
                });

              case 19:
                _context8.next = 21;
                return waitKeyLookup(endpoints, verifier, verifierId, 1000);

              case 21:
                _context8.t1 = _context8.sent;

                if (_context8.t1) {
                  _context8.next = 24;
                  break;
                }

                _context8.t1 = {};

              case 24:
                assignResult = _context8.t1;
                finalKeyResult = assignResult.keyResult;
                isNewKey = true;
                _context8.next = 34;
                break;

              case 29:
                if (!keyResult) {
                  _context8.next = 33;
                  break;
                }

                finalKeyResult = keyResult;
                _context8.next = 34;
                break;

              case 33:
                throw new Error("node results do not match at first lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 34:
                log.debug('> torus.js/getPublicAddress', {
                  finalKeyResult: finalKeyResult,
                  isNewKey: isNewKey
                });

                if (!finalKeyResult) {
                  _context8.next = 76;
                  break;
                }

                _finalKeyResult$keys$2 = finalKeyResult.keys[0], X = _finalKeyResult$keys$2.pub_key_X, Y = _finalKeyResult$keys$2.pub_key_Y;

                if (!this.enableOneKey) {
                  _context8.next = 64;
                  break;
                }

                _context8.prev = 38;
                _context8.next = 42;
                return this.getOrSetNonce(X, Y, undefined, !isNewKey);

              case 42:
                _yield$this$getOrSetN2 = _context8.sent;
                typeOfUser = _yield$this$getOrSetN2.typeOfUser;
                nonce = _yield$this$getOrSetN2.nonce;
                pubNonce = _yield$this$getOrSetN2.pubNonce;
                upgraded = _yield$this$getOrSetN2.upgraded;
                nonce = new BN(nonce || '0', 16);
                _context8.next = 53;
                break;

              case 50:
                _context8.prev = 50;
                _context8.t2 = _context8["catch"](38);
                throw new GetOrSetNonceError();

              case 53:
                if (!(typeOfUser === 'v1')) {
                  _context8.next = 57;
                  break;
                }

                modifiedPubKey = this.ec.keyFromPublic({
                  x: X.toString(16),
                  y: Y.toString(16)
                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());
                _context8.next = 62;
                break;

              case 57:
                if (!(typeOfUser === 'v2')) {
                  _context8.next = 61;
                  break;
                }

                if (upgraded) {
                  // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey
                  modifiedPubKey = this.ec.keyFromPublic({
                    x: X.toString(16),
                    y: Y.toString(16)
                  }).getPublic();
                } else {
                  modifiedPubKey = this.ec.keyFromPublic({
                    x: X.toString(16),
                    y: Y.toString(16)
                  }).getPublic().add(this.ec.keyFromPublic({
                    x: pubNonce.x,
                    y: pubNonce.y
                  }).getPublic());
                }

                _context8.next = 62;
                break;

              case 61:
                throw new Error('getOrSetNonce should always return typeOfUser.');

              case 62:
                _context8.next = 69;
                break;

              case 64:
                typeOfUser = 'v1';
                _context8.next = 67;
                return this.getMetadata({
                  pub_key_X: X,
                  pub_key_Y: Y
                });

              case 67:
                nonce = _context8.sent;
                modifiedPubKey = this.ec.keyFromPublic({
                  x: X.toString(16),
                  y: Y.toString(16)
                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());

              case 69:
                X = modifiedPubKey.getX().toString(16);
                Y = modifiedPubKey.getY().toString(16);
                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());
                log.debug('> torus.js/getPublicAddress', {
                  X: X,
                  Y: Y,
                  address: address,
                  typeOfUser: typeOfUser,
                  nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),
                  pubNonce: pubNonce
                });

                if (isExtended) {
                  _context8.next = 75;
                  break;
                }

                return _context8.abrupt("return", address);

              case 75:
                return _context8.abrupt("return", {
                  typeOfUser: typeOfUser,
                  address: address,
                  X: X,
                  Y: Y,
                  metadataNonce: nonce,
                  pubNonce: pubNonce
                });

              case 76:
                throw new Error("node results do not match at final lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 77:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[38, 50]]);
      }));

      function getPublicAddress(_x17, _x18, _x19) {
        return _getPublicAddress.apply(this, arguments);
      }

      return getPublicAddress;
    }()
    /**
     * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing
     */

  }, {
    key: "getOrSetNonce",
    value: function () {
      var _getOrSetNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(X, Y, privKey) {
        var getOnly,
            data,
            msg,
            _args9 = arguments;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                getOnly = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : false;
                msg = getOnly ? 'getNonce' : 'getOrSetNonce';

                if (privKey) {
                  data = this.generateMetadataParams(msg, privKey);
                } else {
                  data = {
                    pub_key_X: X,
                    pub_key_Y: Y,
                    set_data: {
                      data: msg
                    }
                  };
                }

                return _context9.abrupt("return", post("".concat(this.metadataHost, "/get_or_set_nonce"), data, undefined, {
                  useAPIKey: true
                }));

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getOrSetNonce(_x20, _x21, _x22) {
        return _getOrSetNonce.apply(this, arguments);
      }

      return getOrSetNonce;
    }()
  }, {
    key: "getNonce",
    value: function () {
      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(X, Y, privKey) {
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this.getOrSetNonce(X, Y, privKey, true));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getNonce(_x23, _x24, _x25) {
        return _getNonce.apply(this, arguments);
      }

      return getNonce;
    }()
  }, {
    key: "getPostboxKeyFrom1OutOf1",
    value: function getPostboxKeyFrom1OutOf1(privKey, nonce) {
      var privKeyBN = new BN(privKey, 16);
      var nonceBN = new BN(nonce, 16);
      return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString('hex');
    }
  }], [{
    key: "enableLogging",
    value: function enableLogging() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (v) log.enableAll();else log.disableAll();
    }
  }, {
    key: "setAPIKey",
    value: function setAPIKey$1(apiKey) {
      setAPIKey(apiKey);
    }
  }, {
    key: "setEmbedHost",
    value: function setEmbedHost$1(embedHost) {
      setEmbedHost(embedHost);
    }
  }, {
    key: "isGetOrSetNonceError",
    value: function isGetOrSetNonceError(err) {
      return err instanceof GetOrSetNonceError;
    }
  }]);

  return Torus;
}();

export { Torus as default, keyAssign, keyLookup, waitKeyLookup };
//# sourceMappingURL=torusUtils.esm.js.map
