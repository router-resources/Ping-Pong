module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 15);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return modalDOMElementID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return storeKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return UX_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return OPENLOGIN_METHOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ALLOWED_INTERACTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return OPENLOGIN_NETWORK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LOGIN_PROVIDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return MFA_LEVELS; });
const modalDOMElementID = "openlogin-modal";
const storeKey = "openlogin_store";
const UX_MODE = {
  POPUP: "popup",
  REDIRECT: "redirect"
};
const OPENLOGIN_METHOD = {
  LOGIN: "openlogin_login",
  LOGOUT: "openlogin_logout",
  CHECK_3PC_SUPPORT: "openlogin_check_3PC_support",
  SET_PID_DATA: "openlogin_set_pid_data",
  GET_DATA: "openlogin_get_data"
}; // autocomplete workaround https://github.com/microsoft/TypeScript/issues/29729

const ALLOWED_INTERACTIONS = {
  POPUP: "popup",
  REDIRECT: "redirect",
  JRPC: "jrpc"
};
const OPENLOGIN_NETWORK = {
  MAINNET: "mainnet",
  TESTNET: "testnet",
  CYAN: "cyan",
  DEVELOPMENT: "development"
};
const LOGIN_PROVIDER = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  LINE: "line",
  GITHUB: "github",
  KAKAO: "kakao",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  WECHAT: "wechat",
  EMAIL_PASSWORDLESS: "email_passwordless",
  WEBAUTHN: "webauthn",
  JWT: "jwt"
};
/**
 * {@label loginProviderType}
 */

const MFA_LEVELS = {
  DEFAULT: "default",
  OPTIONAL: "optional",
  MANDATORY: "mandatory"
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return documentReady; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return htmlToElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return whitelistUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getHashQueryParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return awaitReq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return constructURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return storageAvailable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return sessionStorageAvailable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return localStorageAvailable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return preloadIframe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getPopupFeatures; });
/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);



async function documentReady() {
  return new Promise(resolve => {
    if (document.readyState !== "loading") {
      resolve();
    } else {
      document.addEventListener("DOMContentLoaded", () => {
        resolve();
      });
    }
  });
}
const htmlToElement = html => {
  const template = window.document.createElement("template");
  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result

  template.innerHTML = trimmedHtml;
  return template.content.firstChild;
};
async function whitelistUrl(clientId, appKey, origin) {
  const appKeyBuf = Buffer.from(appKey.padStart(64, "0"), "hex");
  if (_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1__["base64url"].encode(Object(_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_0__["getPublic"])(appKeyBuf)) !== clientId) throw new Error("appKey mismatch");
  const sig = await Object(_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_0__["sign"])(appKeyBuf, Buffer.from(Object(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1__["keccak"])("keccak256").update(origin).digest("hex"), "hex"));
  return _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1__["base64url"].encode(sig);
}
function getHashQueryParams() {
  let replaceUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  const result = {};
  const url = new URL(window.location.href);
  url.searchParams.forEach((value, key) => {
    if (key !== "result") {
      result[key] = value;
    }
  });
  const queryResult = url.searchParams.get("result");

  if (queryResult) {
    try {
      const queryParams = JSON.parse(Object(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1__["safeatob"])(queryResult));
      Object.keys(queryParams).forEach(key => {
        result[key] = queryParams[key];
      });
    } catch (error) {
      _loglevel__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].error(error);
    }
  }

  const hash = url.hash.substring(1);
  const hashUrl = new URL("".concat(window.location.origin, "/?").concat(hash));
  hashUrl.searchParams.forEach((value, key) => {
    if (key !== "result") {
      result[key] = value;
    }
  });
  const hashResult = hashUrl.searchParams.get("result");

  if (hashResult) {
    try {
      const hashParams = JSON.parse(Object(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_1__["safeatob"])(hashResult));
      Object.keys(hashParams).forEach(key => {
        result[key] = hashParams[key];
      });
    } catch (error) {
      _loglevel__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].error(error);
    }
  }

  if (replaceUrl) {
    const cleanUrl = window.location.origin + window.location.pathname;
    window.history.replaceState(null, "", cleanUrl);
  }

  return result;
}
function awaitReq(id, windowRef) {
  return new Promise((resolve, reject) => {
    if (!windowRef) reject(new Error("Unable to open window"));
    let closedByHandler = false;
    const closedMonitor = setInterval(() => {
      if (!closedByHandler && windowRef.closed) {
        clearInterval(closedMonitor);
        reject(new Error("user closed popup"));
      }
    }, 500);

    const handler = ev => {
      const {
        pid
      } = ev.data;
      if (id !== pid) return;
      window.removeEventListener("message", handler);
      closedByHandler = true;
      clearInterval(closedMonitor);
      windowRef.close();

      if (ev.data.data && ev.data.data.error) {
        reject(new Error(ev.data.data.error));
      } else {
        resolve(ev.data.data);
      }
    };

    window.addEventListener("message", handler);
  });
}
function constructURL(params) {
  const {
    baseURL,
    query,
    hash
  } = params;
  const url = new URL(baseURL);

  if (query) {
    Object.keys(query).forEach(key => {
      url.searchParams.append(key, query[key]);
    });
  }

  if (hash) {
    const h = new URL(constructURL({
      baseURL,
      query: hash
    })).searchParams.toString();
    url.hash = h;
  }

  return url.toString();
}
function storageAvailable(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;

  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    return error && ( // everything except Firefox
    error.code === 22 || // Firefox
    error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    error.name === "QuotaExceededErro r" || // Firefox
    error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0;
  }
}
const sessionStorageAvailable = storageAvailable("sessionStorage");
const localStorageAvailable = storageAvailable("localStorage");
function preloadIframe(url) {
  try {
    if (typeof document === "undefined") return;
    const openloginIframeHtml = document.createElement("link");
    openloginIframeHtml.href = url;
    openloginIframeHtml.crossOrigin = "anonymous";
    openloginIframeHtml.type = "text/html";
    openloginIframeHtml.rel = "prefetch";

    if (openloginIframeHtml.relList && openloginIframeHtml.relList.supports) {
      if (openloginIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(openloginIframeHtml);
      }
    }
  } catch (error) {
    _loglevel__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].error(error);
  }
}
function getPopupFeatures() {
  // Fixes dual-screen position                             Most browsers      Firefox
  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
  const w = 1200;
  const h = 700;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1; // No reliable estimate

  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = "titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=".concat(h / systemZoom, ",width=").concat(w / systemZoom, ",top=").concat(top, ",left=").concat(left);
  return features;
}

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/openlogin-utils");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/openlogin-jrpc");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);

loglevel__WEBPACK_IMPORTED_MODULE_0___default.a.setLevel("error");
/* harmony default export */ __webpack_exports__["a"] = (loglevel__WEBPACK_IMPORTED_MODULE_0___default.a.getLogger("openlogin"));

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/eccrypto");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(1);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "@toruslabs/eccrypto"
var eccrypto_ = __webpack_require__(6);

// EXTERNAL MODULE: external "@toruslabs/http-helpers"
var http_helpers_ = __webpack_require__(11);

// EXTERNAL MODULE: external "@toruslabs/openlogin-jrpc"
var openlogin_jrpc_ = __webpack_require__(4);

// EXTERNAL MODULE: external "@toruslabs/openlogin-utils"
var openlogin_utils_ = __webpack_require__(3);

// EXTERNAL MODULE: external "lodash.merge"
var external_lodash_merge_ = __webpack_require__(13);
var external_lodash_merge_default = /*#__PURE__*/__webpack_require__.n(external_lodash_merge_);

// EXTERNAL MODULE: ./src/constants.ts
var constants = __webpack_require__(0);

// EXTERNAL MODULE: ./src/loglevel.ts
var loglevel = __webpack_require__(5);

// EXTERNAL MODULE: ./src/utils.ts
var utils = __webpack_require__(2);

// CONCATENATED MODULE: ./src/Modal.ts





const handleStream = (handle, eventName, handler) => {
  const handlerWrapper = chunk => {
    handler(chunk);
    handle.removeListener(eventName, handlerWrapper);
  };

  handle.on(eventName, handlerWrapper);
};
class Modal_Modal {
  constructor(modalUrl) {
    defineProperty_default()(this, "modalUrl", void 0);

    defineProperty_default()(this, "iframeElem", void 0);

    defineProperty_default()(this, "initialized", false);

    defineProperty_default()(this, "modalZIndex", 99999);

    defineProperty_default()(this, "mux", void 0);

    defineProperty_default()(this, "verifierStream", void 0);

    this.modalUrl = modalUrl;
  }

  async init() {
    await this.initIFrame(this.modalUrl);
    this.setupStream();
  }

  setupStream() {
    if (this.iframeElem === null) throw new Error("iframe is null");
    this.mux = Object(openlogin_jrpc_["setupMultiplex"])(new openlogin_jrpc_["PostMessageStream"]({
      name: "modal_iframe_rpc",
      target: "modal_rpc",
      targetWindow: this.iframeElem.contentWindow,
      targetOrigin: new URL(this.modalUrl).origin
    }));
    this.verifierStream = this.mux.createStream("verifier");
  }

  async initIFrame(src) {
    await Object(utils["c" /* documentReady */])();
    const documentIFrameElem = document.getElementById(constants["g" /* modalDOMElementID */]);

    if (documentIFrameElem) {
      documentIFrameElem.remove();
      loglevel["a" /* default */].info("already initialized, removing previous modal iframe");
    }

    this.iframeElem = Object(utils["f" /* htmlToElement */])("<iframe\n        id=".concat(constants["g" /* modalDOMElementID */], "\n        class=\"torusIframe\"\n        src=\"").concat(src, "\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ").concat(this.modalZIndex.toString(), "\"\n      ></iframe>"));

    this._hideModal();

    document.body.appendChild(this.iframeElem);
    return new Promise(resolve => {
      this.iframeElem.onload = () => {
        this.initialized = true;
        resolve();
      };
    });
  }

  _showModal() {
    const style = {};
    style.display = "block";
    style.position = "fixed";
    style.width = "100%";
    style.height = "100%";
    style.top = "0px";
    style.right = "0px";
    style.left = "0px";
    style.bottom = "0px";
    style.border = "0";
    style["z-index"] = this.modalZIndex;
    this.iframeElem.setAttribute("style", Object.entries(style).map(_ref => {
      let [k, v] = _ref;
      return "".concat(k, ":").concat(v);
    }).join(";"));
  }

  _hideModal() {
    const style = {};
    style.display = "none";
    style.position = "fixed";
    style.width = "100%";
    style.height = "100%";
    style.top = "0px";
    style.right = "0px";
    style.left = "0px";
    style.bottom = "0px";
    style.border = "0";
    style["z-index"] = this.modalZIndex;
    this.iframeElem.setAttribute("style", Object.entries(style).map(_ref2 => {
      let [k, v] = _ref2;
      return "".concat(k, ":").concat(v);
    }).join(";"));
  }

  async _prompt(clientId, whiteLabel, loginConfig, cb) {
    this._showModal();

    const modalHandler = chunk => {
      this._hideModal();

      cb(chunk);
    };

    handleStream(this.verifierStream, "data", modalHandler);
    this.verifierStream.write({
      name: "prompt",
      clientId,
      whiteLabel,
      loginConfig
    });
  }

  async cleanup() {
    await Object(utils["c" /* documentReady */])();
    const documentIFrameElem = document.getElementById(constants["g" /* modalDOMElementID */]);

    if (documentIFrameElem) {
      documentIFrameElem.remove();
      this.iframeElem = null;
    }

    this.initialized = false;
  }

}
// EXTERNAL MODULE: ./src/OpenLoginStore.ts + 1 modules
var OpenLoginStore = __webpack_require__(9);

// EXTERNAL MODULE: ./src/Provider.ts
var Provider = __webpack_require__(8);

// CONCATENATED MODULE: ./src/OpenLogin.ts


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }











Object(utils["h" /* preloadIframe */])("https://app.openlogin.com/sdk-modal");

class OpenLogin_OpenLogin {
  constructor(options) {
    var _options$no3PC, _options$_startUrl, _options$_popupUrl, _options$redirectUrl, _options$uxMode, _options$replaceUrlOn, _options$originData, _options$whiteLabel, _options$loginConfig;

    defineProperty_default()(this, "provider", void 0);

    defineProperty_default()(this, "state", void 0);

    defineProperty_default()(this, "modal", void 0);

    this.provider = new Proxy(new Provider["a" /* default */](), {
      deleteProperty: () => true // work around for web3

    });

    if (!options._iframeUrl) {
      if (options.network === constants["e" /* OPENLOGIN_NETWORK */].MAINNET) {
        options._iframeUrl = "https://app.openlogin.com";
      } else if (options.network === constants["e" /* OPENLOGIN_NETWORK */].CYAN) {
        options._iframeUrl = "https://cyan.openlogin.com";
      } else if (options.network === constants["e" /* OPENLOGIN_NETWORK */].TESTNET) {
        options._iframeUrl = "https://beta.openlogin.com";
      } else if (options.network === constants["e" /* OPENLOGIN_NETWORK */].DEVELOPMENT) {
        options._iframeUrl = "http://localhost:3000";
      }
    }

    if (!options._iframeUrl) {
      throw new Error("unspecified network and iframeUrl");
    }

    this.modal = new Modal_Modal("".concat(options._iframeUrl, "/sdk-modal"));
    this.initState(_objectSpread(_objectSpread({}, options), {}, {
      no3PC: (_options$no3PC = options.no3PC) !== null && _options$no3PC !== void 0 ? _options$no3PC : false,
      _iframeUrl: options._iframeUrl,
      _startUrl: (_options$_startUrl = options._startUrl) !== null && _options$_startUrl !== void 0 ? _options$_startUrl : "".concat(options._iframeUrl, "/start"),
      _popupUrl: (_options$_popupUrl = options._popupUrl) !== null && _options$_popupUrl !== void 0 ? _options$_popupUrl : "".concat(options._iframeUrl, "/popup-window"),
      redirectUrl: (_options$redirectUrl = options.redirectUrl) !== null && _options$redirectUrl !== void 0 ? _options$redirectUrl : "".concat(window.location.protocol, "//").concat(window.location.host).concat(window.location.pathname),
      uxMode: (_options$uxMode = options.uxMode) !== null && _options$uxMode !== void 0 ? _options$uxMode : constants["f" /* UX_MODE */].REDIRECT,
      replaceUrlOnRedirect: (_options$replaceUrlOn = options.replaceUrlOnRedirect) !== null && _options$replaceUrlOn !== void 0 ? _options$replaceUrlOn : true,
      originData: (_options$originData = options.originData) !== null && _options$originData !== void 0 ? _options$originData : {
        [window.location.origin]: ""
      },
      whiteLabel: (_options$whiteLabel = options.whiteLabel) !== null && _options$whiteLabel !== void 0 ? _options$whiteLabel : {},
      loginConfig: (_options$loginConfig = options.loginConfig) !== null && _options$loginConfig !== void 0 ? _options$loginConfig : {}
    }));
  }

  get privKey() {
    return this.state.privKey ? this.state.privKey.padStart(64, "0") : "";
  }

  initState(options) {
    this.state = {
      uxMode: options.uxMode,
      network: options.network,
      store: OpenLoginStore["a" /* default */].getInstance(),
      iframeUrl: options._iframeUrl,
      startUrl: options._startUrl,
      popupUrl: options._popupUrl,
      clientId: options.clientId,
      redirectUrl: options.redirectUrl,
      replaceUrlOnRedirect: options.replaceUrlOnRedirect,
      originData: options.originData,
      loginConfig: options.loginConfig,
      support3PC: !options.no3PC,
      whiteLabel: options.whiteLabel
    };
  }

  async init() {
    if (this.state.support3PC) {
      await Promise.all([this.modal.init(), this.updateOriginData()]);
      this.provider.init({
        iframeElem: this.modal.iframeElem,
        iframeUrl: this.state.iframeUrl
      });

      this._syncState(Object(utils["d" /* getHashQueryParams */])(this.state.replaceUrlOnRedirect));

      const res = await this._check3PCSupport();
      this.state.support3PC = !!res.support3PC;

      if (this.state.support3PC) {
        this._syncState(await this._getData());
      }
    } else {
      await this.updateOriginData();

      this._syncState(Object(utils["d" /* getHashQueryParams */])(this.state.replaceUrlOnRedirect));
    }
  }

  async updateOriginData() {
    const filteredOriginData = JSON.parse(JSON.stringify(this.state.originData));
    Object.keys(filteredOriginData).forEach(key => {
      if (filteredOriginData[key] === "") delete filteredOriginData[key];
    });
    const [whitelist, whiteLabel] = await Promise.all([this.getWhitelist(), this.getWhiteLabel()]);

    this._syncState({
      originData: _objectSpread(_objectSpread({}, whitelist), filteredOriginData),
      whiteLabel: _objectSpread(_objectSpread({}, whiteLabel), this.state.whiteLabel)
    });
  }

  async getWhitelist() {
    try {
      const {
        clientId
      } = this.state;

      if (!clientId) {
        throw new Error("unspecified clientId");
      }

      const res = await Object(http_helpers_["post"])("https://api.developer.tor.us/whitelist", {
        project_id: this.state.clientId
      });
      return res.signed_urls;
    } catch (_) {
      // fail silently
      return {};
    }
  }

  async getWhiteLabel() {
    try {
      const {
        clientId
      } = this.state;

      if (!clientId) {
        throw new Error("unspecified clientId");
      }

      const res = await Object(http_helpers_["post"])("https://api.developer.tor.us/whitelabel", {
        project_id: this.state.clientId
      });
      return res.whiteLabel;
    } catch (_) {
      // fail silently
      return {};
    }
  }

  async _fastLogin(params) {
    const defaultParams = {
      redirectUrl: this.state.redirectUrl
    };

    const loginParams = _objectSpread(_objectSpread({}, defaultParams), params);

    const res = await this.request({
      params: [_objectSpread(_objectSpread({}, loginParams), {}, {
        fastLogin: true
      })],
      method: constants["d" /* OPENLOGIN_METHOD */].LOGIN,
      startUrl: this.state.startUrl,
      popupUrl: this.state.popupUrl,
      allowedInteractions: [constants["a" /* ALLOWED_INTERACTIONS */].POPUP, constants["a" /* ALLOWED_INTERACTIONS */].REDIRECT]
    });
    this.state.privKey = res.privKey;
    return res;
  }

  async login(params) {
    if (params !== null && params !== void 0 && params.loginProvider) {
      return this._selectedLogin(params);
    }

    return this._modal(params);
  }

  async _selectedLogin(params) {
    const defaultParams = {
      redirectUrl: this.state.redirectUrl
    };

    const loginParams = _objectSpread(_objectSpread({
      loginProvider: params.loginProvider
    }, defaultParams), params); // fast login flow
    // if (this.state.store.get("touchIDPreference") === "enabled" && !loginParams.extraLoginOptions?.login_hint) {
    //   return this._fastLogin(loginParams);
    // }


    const res = await this.request({
      method: constants["d" /* OPENLOGIN_METHOD */].LOGIN,
      allowedInteractions: [constants["f" /* UX_MODE */].REDIRECT, constants["f" /* UX_MODE */].POPUP],
      startUrl: this.state.startUrl,
      popupUrl: this.state.popupUrl,
      params: [loginParams]
    });
    this.state.privKey = res.privKey;

    if (res.store) {
      this._syncState(res);
    } else if (this.state.privKey && this.state.support3PC) {
      this._syncState(await this._getData());
    }

    return {
      privKey: this.privKey
    };
  }

  async logout() {
    let logoutParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const params = {}; // defaults

    params.redirectUrl = this.state.redirectUrl;
    params._clientId = this.state.clientId;

    if (logoutParams.clientId) {
      params._clientId = logoutParams.clientId;
    }

    if (logoutParams.fastLogin !== undefined) {
      params.fastLogin = logoutParams.fastLogin;
    }

    if (logoutParams.redirectUrl !== undefined) {
      params.redirectUrl = logoutParams.redirectUrl;
    }

    const res = await this.request({
      method: constants["d" /* OPENLOGIN_METHOD */].LOGOUT,
      params: [params],
      startUrl: this.state.startUrl,
      popupUrl: this.state.popupUrl,
      allowedInteractions: [constants["a" /* ALLOWED_INTERACTIONS */].JRPC, constants["a" /* ALLOWED_INTERACTIONS */].POPUP, constants["a" /* ALLOWED_INTERACTIONS */].REDIRECT]
    });
    this.state.privKey = ""; // if (!params.fastLogin) this.state.store.set("touchIDPreference", "disabled");

    return res;
  }

  async request(args) {
    var _ref;

    const pid = Object(openlogin_utils_["randomId"])();
    let {
      params
    } = args; // Note: _origin is added later in postMessageStream for jrpc requests
    // do not add it here since its used for checking postMessage constraints

    const session = {};
    if (params.length !== 1) throw new Error("request params array should have only one element");
    const {
      startUrl,
      popupUrl,
      method,
      allowedInteractions
    } = args;
    if (allowedInteractions.length === 0) throw new Error("no allowed interactions");

    if (this.state.clientId) {
      session._clientId = this.state.clientId;
    }

    if (this.privKey) {
      const userData = {
        clientId: session._clientId,
        timestamp: Date.now().toString()
      };
      const sig = await Object(eccrypto_["sign"])(Buffer.from(this.privKey, "hex"), Buffer.from(Object(openlogin_utils_["keccak"])("keccak256").update(JSON.stringify(userData)).digest("hex"), "hex"));
      session._user = Object(eccrypto_["getPublic"])(Buffer.from(this.privKey, "hex")).toString("hex");
      session._userSig = openlogin_utils_["base64url"].encode(sig);
      session._userData = userData;
    }

    session._originData = this.state.originData;
    session._whiteLabelData = this.state.whiteLabel;
    session._loginConfig = this.state.loginConfig; // add in session data (allow overrides)

    params = [_objectSpread(_objectSpread({}, session), params[0])]; // use JRPC where possible

    if (this.state.support3PC && allowedInteractions.includes(constants["a" /* ALLOWED_INTERACTIONS */].JRPC)) {
      return this._jrpcRequest({
        method,
        params
      });
    } // set origin


    params[0]._origin = new URL((_ref = params[0].redirectUrl) !== null && _ref !== void 0 ? _ref : this.state.redirectUrl).origin; // preset params

    if (this.state.support3PC) {
      // set params first if 3PC supported
      await this._setPIDData(pid, params); // eslint-disable-next-line require-atomic-updates

      params = [{}];
    }

    if (!startUrl || !popupUrl) {
      throw new Error("no url for redirect / popup flow");
    } // method and pid are always in URL hash params
    // convert params from JSON to base64


    if (this.state.uxMode === constants["f" /* UX_MODE */].REDIRECT) {
      // if redirects preferred, check for redirect flows first, then check for popup flow
      if (allowedInteractions.includes(constants["a" /* ALLOWED_INTERACTIONS */].REDIRECT)) {
        // give time for synchronous methods to complete before redirect
        setTimeout(() => {
          window.location.href = Object(utils["b" /* constructURL */])({
            baseURL: startUrl,
            hash: {
              b64Params: Object(openlogin_utils_["jsonToBase64"])(params[0]),
              _pid: pid,
              _method: method
            }
          });
        }, 50);
        return {};
      }

      if (allowedInteractions.includes(constants["a" /* ALLOWED_INTERACTIONS */].POPUP)) {
        const u = new URL(Object(utils["b" /* constructURL */])({
          baseURL: popupUrl,
          hash: {
            b64Params: Object(openlogin_utils_["jsonToBase64"])(params[0]),
            _pid: pid,
            _method: method
          }
        }));
        const windowRef = window.open(u.toString(), "_blank", Object(utils["e" /* getPopupFeatures */])());
        return Object(utils["a" /* awaitReq */])(pid, windowRef);
      }
    } else {
      // if popups preferred, check for popup flows first, then check for redirect flow
      if (allowedInteractions.includes(constants["a" /* ALLOWED_INTERACTIONS */].POPUP)) {
        const u = new URL(Object(utils["b" /* constructURL */])({
          baseURL: popupUrl,
          hash: {
            b64Params: Object(openlogin_utils_["jsonToBase64"])(params[0]),
            _pid: pid,
            _method: method
          }
        }));
        const windowRef = window.open(u.toString(), "_blank", Object(utils["e" /* getPopupFeatures */])());
        return Object(utils["a" /* awaitReq */])(pid, windowRef);
      }

      if (allowedInteractions.includes(constants["a" /* ALLOWED_INTERACTIONS */].REDIRECT)) {
        // give time for synchronous methods to complete before redirect
        setTimeout(() => {
          window.location.href = Object(utils["b" /* constructURL */])({
            baseURL: startUrl,
            hash: {
              b64Params: Object(openlogin_utils_["jsonToBase64"])(params[0]),
              _pid: pid,
              _method: method
            }
          });
        }, 50);
        return null;
      }
    }

    throw new Error("no matching allowed interactions");
  }

  async _jrpcRequest(args) {
    // await this.initialized;
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw new Error("invalid request args");
    }

    const {
      method,
      params
    } = args;

    if (typeof method !== "string" || method.length === 0) {
      throw new Error("invalid request method");
    }

    if (params === undefined || !Array.isArray(params)) {
      throw new Error("invalid request params");
    }

    if (params.length === 0) {
      params.push({});
    }

    return new Promise((resolve, reject) => {
      this.provider._rpcRequest({
        method,
        params
      }, Object(openlogin_jrpc_["getRpcPromiseCallback"])(resolve, reject));
    });
  }

  async _check3PCSupport() {
    return this._jrpcRequest({
      method: constants["d" /* OPENLOGIN_METHOD */].CHECK_3PC_SUPPORT,
      params: [{
        _originData: this.state.originData
      }]
    });
  }

  async _setPIDData(pid, data) {
    await this.request({
      allowedInteractions: [constants["a" /* ALLOWED_INTERACTIONS */].JRPC],
      method: constants["d" /* OPENLOGIN_METHOD */].SET_PID_DATA,
      params: [{
        pid,
        data: data[0]
      }]
    });
  }

  async _getData() {
    return this.request({
      allowedInteractions: [constants["a" /* ALLOWED_INTERACTIONS */].JRPC],
      method: constants["d" /* OPENLOGIN_METHOD */].GET_DATA,
      params: [{}]
    });
  }

  _syncState(newState) {
    if (newState.store) {
      if (typeof newState.store !== "object") {
        throw new Error("expected store to be an object");
      }

      Object.keys(newState.store).forEach(key => {
        // if privKey is available then user is not logged out, but in popup mode store info is not available.
        // so we don't want to overwrite the local store if privKey is available
        // and if latest iframe store data is not available
        if (newState.privKey) {
          if (newState.store[key]) {
            this.state.store.set(key, newState.store[key]);
          }
        } else {
          this.state.store.set(key, newState.store[key]);
        }
      });
    }

    const {
      store
    } = this.state;
    this.state = _objectSpread(_objectSpread(_objectSpread({}, this.state), newState), {}, {
      store
    });
  }

  async _modal(params) {
    return new Promise((resolve, reject) => {
      this.modal._prompt(this.state.clientId, this.state.whiteLabel, this.state.loginConfig, async chunk => {
        if (chunk.cancel) {
          reject(new Error("user canceled login"));
        } else {
          try {
            const selectedLoginResponse = await this._selectedLogin(external_lodash_merge_default()(params, chunk));
            resolve(selectedLoginResponse);
          } catch (error) {
            reject(error);
          }
        }
      });
    });
  }

  async _cleanup() {
    await this.modal.cleanup();
    this.provider.cleanup();
  }

  async encrypt(message, privateKey) {
    let privKey = privateKey;

    if (!privKey) {
      privKey = this.privKey;
    } // validations


    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {
      if (privKey === "" || privKey === undefined) {
        throw new Error("private key cannot be empty");
      } else {
        throw new Error("invalid private key in encrypt");
      }
    }

    return Object(eccrypto_["encrypt"])(Object(eccrypto_["getPublic"])(Buffer.from(privKey, "hex")), message);
  }

  async decrypt(ciphertext, privateKey) {
    let privKey = privateKey;

    if (!privKey) {
      privKey = this.privKey;
    } // validations


    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {
      if (privKey === "" || privKey === undefined) {
        throw new Error("private key cannot be empty");
      } else {
        throw new Error("invalid private key in decrypt");
      }
    }

    return Object(eccrypto_["decrypt"])(Buffer.from(privKey, "hex"), ciphertext);
  }

  async getUserInfo() {
    if (this.privKey) {
      const storeData = this.state.store.getStore();
      const userInfo = {
        email: storeData.email || "",
        name: storeData.name || "",
        profileImage: storeData.profileImage || "",
        aggregateVerifier: storeData.aggregateVerifier || "",
        verifier: storeData.verifier || "",
        verifierId: storeData.verifierId || "",
        typeOfLogin: storeData.typeOfLogin || ""
      };
      return userInfo;
    }

    throw new Error("user should be logged in to fetch userInfo");
  }

  async getEncodedLoginUrl(loginParams) {
    const {
      redirectUrl
    } = loginParams;
    const {
      clientId
    } = this.state;

    if (!this.state.originData[origin]) {
      await this.updateOriginData();
    }

    const dataObject = _objectSpread({
      _clientId: clientId,
      _origin: new URL(redirectUrl).origin,
      _originData: this.state.originData,
      redirectUrl
    }, loginParams);

    const b64Params = Object(openlogin_utils_["jsonToBase64"])(dataObject);
    const hashParams = {
      b64Params,
      _method: "openlogin_login"
    };
    return Object(utils["b" /* constructURL */])({
      baseURL: "".concat(this.state.iframeUrl, "/start"),
      hash: hashParams
    });
  }

}

/* harmony default export */ var src_OpenLogin = __webpack_exports__["a"] = (OpenLogin_OpenLogin);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Provider; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);
/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _loglevel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);





class Provider extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__["SafeEventEmitter"] {
  constructor() {
    super(...arguments);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "iframeElem", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "rpcStream", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "iframeUrl", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "rpcEngine", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "initialized", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "mux", void 0);
  }

  init(_ref) {
    let {
      iframeElem,
      iframeUrl
    } = _ref;
    this.iframeElem = iframeElem;
    this.iframeUrl = iframeUrl;
    this.setupStream();
    this.initialized = true;
  }

  setupStream() {
    if (this.iframeElem === null) throw new Error("iframe is null");
    this.rpcStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__["PostMessageStream"]({
      name: "embed_rpc",
      target: "iframe_rpc",
      targetWindow: this.iframeElem.contentWindow,
      targetOrigin: new URL(this.iframeUrl).origin
    });
    this.mux = Object(_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__["setupMultiplex"])(this.rpcStream);
    const JRPCConnection = Object(_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__["createStreamMiddleware"])();
    pump__WEBPACK_IMPORTED_MODULE_3___default()(JRPCConnection.stream, this.mux.createStream("jrpc"), JRPCConnection.stream, error => {
      _loglevel__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].error("JRPC connection broken", error);
    });
    const rpcEngine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__["JRPCEngine"]();
    rpcEngine.push(Object(_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__["createIdRemapMiddleware"])());
    rpcEngine.push(JRPCConnection.middleware);
    this.rpcEngine = rpcEngine;
  }

  cleanup() {
    this.iframeElem = null;
    this.initialized = false;
  }

  _rpcRequest(payload, callback) {
    if (!payload.jsonrpc) {
      payload.jsonrpc = "2.0";
    }

    if (!payload.id) {
      payload.id = Object(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__["randomId"])();
    }

    this.rpcEngine.handle(payload, callback);
  }

}

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ OpenLoginStore_OpenLoginStore; });

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(1);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: ./src/constants.ts
var constants = __webpack_require__(0);

// CONCATENATED MODULE: ./src/MemoryStore.ts

class MemoryStore_MemoryStore {
  constructor() {
    defineProperty_default()(this, "store", {});
  }

  getItem(key) {
    return this.store[key];
  }

  setItem(key, value) {
    this.store[key] = value;
  }

}
// EXTERNAL MODULE: ./src/utils.ts
var utils = __webpack_require__(2);

// CONCATENATED MODULE: ./src/OpenLoginStore.ts




class OpenLoginStore_OpenLoginStore {
  // eslint-disable-next-line no-use-before-define
  constructor(storage) {
    defineProperty_default()(this, "storage", void 0);

    this.storage = storage;

    try {
      if (!storage.getItem(constants["h" /* storeKey */])) {
        this.resetStore();
      }
    } catch (error) {// Storage is not available
    }
  }

  static getInstance() {
    if (!this.instance) {
      this.instance = new this(utils["g" /* localStorageAvailable */] ? localStorage : new MemoryStore_MemoryStore());
    }

    return this.instance;
  }

  toJSON() {
    return this.storage.getItem(constants["h" /* storeKey */]);
  }

  resetStore() {
    const currStore = this.getStore();
    this.storage.setItem(constants["h" /* storeKey */], JSON.stringify({}));
    return currStore;
  }

  getStore() {
    return JSON.parse(this.storage.getItem(constants["h" /* storeKey */]));
  }

  get(key) {
    const store = JSON.parse(this.storage.getItem(constants["h" /* storeKey */]));
    return store[key];
  }

  set(key, value) {
    const store = JSON.parse(this.storage.getItem(constants["h" /* storeKey */]));
    store[key] = value;
    this.storage.setItem(constants["h" /* storeKey */], JSON.stringify(store));
  }

}

defineProperty_default()(OpenLoginStore_OpenLoginStore, "instance", void 0);

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("loglevel");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/http-helpers");

/***/ }),
/* 12 */
/***/ (function(module, exports) {



/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("lodash.merge");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("pump");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modalDOMElementID", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "storeKey", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UX_MODE", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OPENLOGIN_METHOD", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ALLOWED_INTERACTIONS", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OPENLOGIN_NETWORK", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LOGIN_PROVIDER", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MFA_LEVELS", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony import */ var _IStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _IStore__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_IStore__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _IStore__WEBPACK_IMPORTED_MODULE_1__) if(["default","loglevel","OpenLoginStore","Provider","modalDOMElementID","storeKey","UX_MODE","OPENLOGIN_METHOD","ALLOWED_INTERACTIONS","OPENLOGIN_NETWORK","LOGIN_PROVIDER","MFA_LEVELS"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _IStore__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loglevel", function() { return _loglevel__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _OpenLogin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _OpenLogin__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony import */ var _OpenLoginStore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OpenLoginStore", function() { return _OpenLoginStore__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony import */ var _Provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return _Provider__WEBPACK_IMPORTED_MODULE_5__["a"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "documentReady", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "htmlToElement", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "whitelistUrl", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHashQueryParams", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "awaitReq", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constructURL", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "storageAvailable", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["j"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sessionStorageAvailable", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "localStorageAvailable", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preloadIframe", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPopupFeatures", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["e"]; });










/***/ })
/******/ ]);
//# sourceMappingURL=openlogin.cjs.js.map