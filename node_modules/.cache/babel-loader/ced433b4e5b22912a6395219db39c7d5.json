{"ast":null,"code":"/* eslint-disable no-useless-escape */\nconst utils = require('ethereumjs-util');\nconst BN = require('bn.js');\nvar ABI = function () {};\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName(name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3);\n  } else if (name === 'int') {\n    return 'int256';\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4);\n  } else if (name === 'uint') {\n    return 'uint256';\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5);\n  } else if (name === 'fixed') {\n    return 'fixed128x128';\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6);\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n  return name;\n}\nABI.eventID = function (name, types) {\n  // FIXME: use node.js util.format?\n  var sig = name + '(' + types.map(elementaryName).join(',') + ')';\n  return utils.keccak256(Buffer.from(sig));\n};\nABI.methodID = function (name, types) {\n  return ABI.eventID(name, types).slice(0, 4);\n};\n\n// Parse N from type<N>\nfunction parseTypeN(type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM(type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray(type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n  }\n  return null;\n}\nfunction parseNumber(arg) {\n  var type = typeof arg;\n  if (type === 'string') {\n    if (utils.isHexPrefixed(arg)) {\n      return new BN(utils.stripHexPrefix(arg), 16);\n    } else {\n      return new BN(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new BN(arg);\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n}\n\n// someMethod(bytes,uint)\n// someMethod(bytes,uint):(boolean)\nfunction parseSignature(sig) {\n  var tmp = /^(\\w+)\\((.*)\\)$/.exec(sig);\n  if (tmp.length !== 3) {\n    throw new Error('Invalid method signature');\n  }\n  var args = /^(.+)\\):\\((.+)$/.exec(tmp[2]);\n  if (args !== null && args.length === 3) {\n    return {\n      method: tmp[1],\n      args: args[1].split(','),\n      retargs: args[2].split(',')\n    };\n  } else {\n    var params = tmp[2].split(',');\n    if (params.length === 1 && params[0] === '') {\n      // Special-case (possibly naive) fixup for functions that take no arguments.\n      // TODO: special cases are always bad, but this makes the function return\n      // match what the calling functions expect\n      params = [];\n    }\n    return {\n      method: tmp[1],\n      args: params\n    };\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle(type, arg) {\n  var size, num, ret, i;\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg));\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0);\n  } else if (type === 'string') {\n    return encodeSingle('bytes', Buffer.from(arg, 'utf8'));\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?');\n    }\n    size = parseTypeArray(type);\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size);\n    }\n    ret = [];\n    type = type.slice(0, type.lastIndexOf('['));\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg);\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]));\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length);\n      ret.unshift(length);\n    }\n    return Buffer.concat(ret);\n  } else if (type === 'bytes') {\n    arg = Buffer.from(arg);\n    ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);\n    if (arg.length % 32 !== 0) {\n      ret = Buffer.concat([ret, utils.zeros(32 - arg.length % 32)]);\n    }\n    return ret;\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n    return utils.setLengthRight(arg, 32);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n    num = parseNumber(arg);\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n    if (num < 0) {\n      throw new Error('Supplied uint is negative');\n    }\n    return num.toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n    num = parseNumber(arg);\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type);\n    num = parseNumber(arg);\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative');\n    }\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))));\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type);\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));\n  }\n  throw new Error('Unsupported or invalid type: ' + type);\n}\n\n// Decodes a single item (can be dynamic array)\n// @returns: array\n// FIXME: this method will need a lot of attention at checking limits and validation\nfunction decodeSingle(parsedType, data, offset) {\n  if (typeof parsedType === 'string') {\n    parsedType = parseType(parsedType);\n  }\n  var size, num, ret, i;\n  if (parsedType.name === 'address') {\n    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex');\n  } else if (parsedType.name === 'bool') {\n    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();\n  } else if (parsedType.name === 'string') {\n    var bytes = decodeSingle(parsedType.rawType, data, offset);\n    return Buffer.from(bytes, 'utf8').toString();\n  } else if (parsedType.isArray) {\n    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    ret = [];\n    size = parsedType.size;\n    if (parsedType.size === 'dynamic') {\n      offset = decodeSingle('uint256', data, offset).toNumber();\n      size = decodeSingle('uint256', data, offset).toNumber();\n      offset = offset + 32;\n    }\n    for (i = 0; i < size; i++) {\n      var decoded = decodeSingle(parsedType.subArray, data, offset);\n      ret.push(decoded);\n      offset += parsedType.subArray.memoryUsage;\n    }\n    return ret;\n  } else if (parsedType.name === 'bytes') {\n    offset = decodeSingle('uint256', data, offset).toNumber();\n    size = decodeSingle('uint256', data, offset).toNumber();\n    return data.slice(offset + 32, offset + 32 + size);\n  } else if (parsedType.name.startsWith('bytes')) {\n    return data.slice(offset, offset + parsedType.size);\n  } else if (parsedType.name.startsWith('uint')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be');\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n    }\n    return num;\n  } else if (parsedType.name.startsWith('int')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256);\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n    }\n    return num;\n  } else if (parsedType.name.startsWith('ufixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]));\n    num = decodeSingle('uint256', data, offset);\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet');\n    }\n    return num.div(size);\n  } else if (parsedType.name.startsWith('fixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]));\n    num = decodeSingle('int256', data, offset);\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet');\n    }\n    return num.div(size);\n  }\n  throw new Error('Unsupported or invalid type: ' + parsedType.name);\n}\n\n// Parse the given type\n// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)\nfunction parseType(type) {\n  var size;\n  var ret;\n  if (isArray(type)) {\n    size = parseTypeArray(type);\n    var subArray = type.slice(0, type.lastIndexOf('['));\n    subArray = parseType(subArray);\n    ret = {\n      isArray: true,\n      name: type,\n      size: size,\n      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,\n      subArray: subArray\n    };\n    return ret;\n  } else {\n    var rawType;\n    switch (type) {\n      case 'address':\n        rawType = 'uint160';\n        break;\n      case 'bool':\n        rawType = 'uint8';\n        break;\n      case 'string':\n        rawType = 'bytes';\n        break;\n    }\n    ret = {\n      rawType: rawType,\n      name: type,\n      memoryUsage: 32\n    };\n    if (type.startsWith('bytes') && type !== 'bytes' || type.startsWith('uint') || type.startsWith('int')) {\n      ret.size = parseTypeN(type);\n    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {\n      ret.size = parseTypeNxM(type);\n    }\n    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {\n      throw new Error('Invalid bytes<N> width: ' + ret.size);\n    }\n    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\n      throw new Error('Invalid int/uint<N> width: ' + ret.size);\n    }\n    return ret;\n  }\n}\n\n// Is a type dynamic?\nfunction isDynamic(type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic';\n}\n\n// Is a type an array?\nfunction isArray(type) {\n  return type.lastIndexOf(']') === type.length - 1;\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nABI.rawEncode = function (types, values) {\n  var output = [];\n  var data = [];\n  var headLength = 0;\n  types.forEach(function (type) {\n    if (isArray(type)) {\n      var size = parseTypeArray(type);\n      if (size !== 'dynamic') {\n        headLength += 32 * size;\n      } else {\n        headLength += 32;\n      }\n    } else {\n      headLength += 32;\n    }\n  });\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    var cur = encodeSingle(type, value);\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength));\n      data.push(cur);\n      headLength += cur.length;\n    } else {\n      output.push(cur);\n    }\n  }\n  return Buffer.concat(output.concat(data));\n};\nABI.rawDecode = function (types, data) {\n  var ret = [];\n  data = Buffer.from(data);\n  var offset = 0;\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var parsed = parseType(type, data, offset);\n    var decoded = decodeSingle(parsed, data, offset);\n    offset += parsed.memoryUsage;\n    ret.push(decoded);\n  }\n  return ret;\n};\nABI.simpleEncode = function (method) {\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  var sig = parseSignature(method);\n\n  // FIXME: validate/convert arguments\n  if (args.length !== sig.args.length) {\n    throw new Error('Argument count mismatch');\n  }\n  return Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);\n};\nABI.simpleDecode = function (method, data) {\n  var sig = parseSignature(method);\n\n  // FIXME: validate/convert arguments\n  if (!sig.retargs) {\n    throw new Error('No return values in method');\n  }\n  return ABI.rawDecode(sig.retargs, data);\n};\nfunction stringify(type, value) {\n  if (type.startsWith('address') || type.startsWith('bytes')) {\n    return '0x' + value.toString('hex');\n  } else {\n    return value.toString();\n  }\n}\nABI.stringify = function (types, values) {\n  var ret = [];\n  for (var i in types) {\n    var type = types[i];\n    var value = values[i];\n\n    // if it is an array type, concat the items\n    if (/^[^\\[]+\\[.*\\]$/.test(type)) {\n      value = value.map(function (item) {\n        return stringify(type, item);\n      }).join(', ');\n    } else {\n      value = stringify(type, value);\n    }\n    ret.push(value);\n  }\n  return ret;\n};\nABI.solidityHexValue = function (type, value, bitsize) {\n  // pass in bitsize = null if use default bitsize\n  var size, num;\n  if (isArray(type)) {\n    var subType = type.replace(/\\[.*?\\]/, '');\n    if (!isArray(subType)) {\n      var arraySize = parseTypeArray(type);\n      if (arraySize !== 'dynamic' && arraySize !== 0 && value.length > arraySize) {\n        throw new Error('Elements exceed array size: ' + arraySize);\n      }\n    }\n    var arrayValues = value.map(function (v) {\n      return ABI.solidityHexValue(subType, v, 256);\n    });\n    return Buffer.concat(arrayValues);\n  } else if (type === 'bytes') {\n    return value;\n  } else if (type === 'string') {\n    return Buffer.from(value, 'utf8');\n  } else if (type === 'bool') {\n    bitsize = bitsize || 8;\n    var padding = Array(bitsize / 4).join('0');\n    return Buffer.from(value ? padding + '1' : padding + '0', 'hex');\n  } else if (type === 'address') {\n    var bytesize = 20;\n    if (bitsize) {\n      bytesize = bitsize / 8;\n    }\n    return utils.setLengthLeft(value, bytesize);\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n    return utils.setLengthRight(value, size);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n    num = parseNumber(value);\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n    bitsize = bitsize || size;\n    return num.toArrayLike(Buffer, 'be', bitsize / 8);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n    num = parseNumber(value);\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n    bitsize = bitsize || size;\n    return num.toTwos(size).toArrayLike(Buffer, 'be', bitsize / 8);\n  } else {\n    // FIXME: support all other types\n    throw new Error('Unsupported or invalid type: ' + type);\n  }\n};\nABI.solidityPack = function (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values');\n  }\n  var ret = [];\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    ret.push(ABI.solidityHexValue(type, value, null));\n  }\n  return Buffer.concat(ret);\n};\nABI.soliditySHA3 = function (types, values) {\n  return utils.keccak256(ABI.solidityPack(types, values));\n};\nABI.soliditySHA256 = function (types, values) {\n  return utils.sha256(ABI.solidityPack(types, values));\n};\nABI.solidityRIPEMD160 = function (types, values) {\n  return utils.ripemd160(ABI.solidityPack(types, values), true);\n};\n\n// Serpent's users are familiar with this encoding\n// - s: string\n// - b: bytes\n// - b<N>: bytes<N>\n// - i: int256\n// - a: int256[]\n\nfunction isNumeric(c) {\n  // FIXME: is this correct? Seems to work\n  return c >= '0' && c <= '9';\n}\n\n// For a \"documentation\" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp\nABI.fromSerpent = function (sig) {\n  var ret = [];\n  for (var i = 0; i < sig.length; i++) {\n    var type = sig[i];\n    if (type === 's') {\n      ret.push('bytes');\n    } else if (type === 'b') {\n      var tmp = 'bytes';\n      var j = i + 1;\n      while (j < sig.length && isNumeric(sig[j])) {\n        tmp += sig[j] - '0';\n        j++;\n      }\n      i = j - 1;\n      ret.push(tmp);\n    } else if (type === 'i') {\n      ret.push('int256');\n    } else if (type === 'a') {\n      ret.push('int256[]');\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n  return ret;\n};\nABI.toSerpent = function (types) {\n  var ret = [];\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i];\n    if (type === 'bytes') {\n      ret.push('s');\n    } else if (type.startsWith('bytes')) {\n      ret.push('b' + parseTypeN(type));\n    } else if (type === 'int256') {\n      ret.push('i');\n    } else if (type === 'int256[]') {\n      ret.push('a');\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n  return ret.join('');\n};\nmodule.exports = ABI;","map":{"version":3,"names":["utils","require","BN","ABI","elementaryName","name","startsWith","slice","eventID","types","sig","map","join","keccak256","Buffer","from","methodID","parseTypeN","type","parseInt","exec","parseTypeNxM","tmp","parseTypeArray","match","parseNumber","arg","isHexPrefixed","stripHexPrefix","toArray","Error","parseSignature","length","args","method","split","retargs","params","encodeSingle","size","num","ret","i","isArray","lastIndexOf","JSON","parse","push","unshift","concat","zeros","setLengthRight","bitLength","toArrayLike","toTwos","mul","pow","decodeSingle","parsedType","data","offset","parseType","rawType","toString","bytes","toNumber","decoded","subArray","memoryUsage","fromTwos","mod","isZero","div","isDynamic","rawEncode","values","output","headLength","forEach","value","cur","rawDecode","parsed","simpleEncode","Array","prototype","call","arguments","simpleDecode","stringify","test","item","solidityHexValue","bitsize","subType","replace","arraySize","arrayValues","v","padding","bytesize","setLengthLeft","solidityPack","soliditySHA3","soliditySHA256","sha256","solidityRIPEMD160","ripemd160","isNumeric","c","fromSerpent","j","toSerpent","module","exports"],"sources":["/Users/shivamsoni/Desktop/router/pingspong/Ping-Pong/node_modules/ethereumjs-abi/lib/index.js"],"sourcesContent":["/* eslint-disable no-useless-escape */\nconst utils = require('ethereumjs-util')\nconst BN = require('bn.js')\n\nvar ABI = function () {\n}\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName (name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3)\n  } else if (name === 'int') {\n    return 'int256'\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4)\n  } else if (name === 'uint') {\n    return 'uint256'\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5)\n  } else if (name === 'fixed') {\n    return 'fixed128x128'\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6)\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128'\n  }\n  return name\n}\n\nABI.eventID = function (name, types) {\n  // FIXME: use node.js util.format?\n  var sig = name + '(' + types.map(elementaryName).join(',') + ')'\n  return utils.keccak256(Buffer.from(sig))\n}\n\nABI.methodID = function (name, types) {\n  return ABI.eventID(name, types).slice(0, 4)\n}\n\n// Parse N from type<N>\nfunction parseTypeN (type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10)\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM (type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type)\n  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray (type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/)\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)\n  }\n  return null\n}\n\nfunction parseNumber (arg) {\n  var type = typeof arg\n  if (type === 'string') {\n    if (utils.isHexPrefixed(arg)) {\n      return new BN(utils.stripHexPrefix(arg), 16)\n    } else {\n      return new BN(arg, 10)\n    }\n  } else if (type === 'number') {\n    return new BN(arg)\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg\n  } else {\n    throw new Error('Argument is not a number')\n  }\n}\n\n// someMethod(bytes,uint)\n// someMethod(bytes,uint):(boolean)\nfunction parseSignature (sig) {\n  var tmp = /^(\\w+)\\((.*)\\)$/.exec(sig)\n\n  if (tmp.length !== 3) {\n    throw new Error('Invalid method signature')\n  }\n\n  var args = /^(.+)\\):\\((.+)$/.exec(tmp[2])\n\n  if (args !== null && args.length === 3) {\n    return {\n      method: tmp[1],\n      args: args[1].split(','),\n      retargs: args[2].split(',')\n    }\n  } else {\n    var params = tmp[2].split(',')\n    if (params.length === 1 && params[0] === '') {\n      // Special-case (possibly naive) fixup for functions that take no arguments.\n      // TODO: special cases are always bad, but this makes the function return\n      // match what the calling functions expect\n      params = []\n    }\n    return {\n      method: tmp[1],\n      args: params\n    }\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle (type, arg) {\n  var size, num, ret, i\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg))\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0)\n  } else if (type === 'string') {\n    return encodeSingle('bytes', Buffer.from(arg, 'utf8'))\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?')\n    }\n    size = parseTypeArray(type)\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size)\n    }\n    ret = []\n    type = type.slice(0, type.lastIndexOf('['))\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg)\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]))\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length)\n      ret.unshift(length)\n    }\n    return Buffer.concat(ret)\n  } else if (type === 'bytes') {\n    arg = Buffer.from(arg)\n\n    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])\n\n    if ((arg.length % 32) !== 0) {\n      ret = Buffer.concat([ ret, utils.zeros(32 - (arg.length % 32)) ])\n    }\n\n    return ret\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return utils.setLengthRight(arg, 32)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative')\n    }\n\n    return num.toArrayLike(Buffer, 'be', 32)\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32)\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type)\n\n    num = parseNumber(arg)\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative')\n    }\n\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type)\n\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type)\n}\n\n// Decodes a single item (can be dynamic array)\n// @returns: array\n// FIXME: this method will need a lot of attention at checking limits and validation\nfunction decodeSingle (parsedType, data, offset) {\n  if (typeof parsedType === 'string') {\n    parsedType = parseType(parsedType)\n  }\n  var size, num, ret, i\n\n  if (parsedType.name === 'address') {\n    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex')\n  } else if (parsedType.name === 'bool') {\n    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString()\n  } else if (parsedType.name === 'string') {\n    var bytes = decodeSingle(parsedType.rawType, data, offset)\n    return Buffer.from(bytes, 'utf8').toString()\n  } else if (parsedType.isArray) {\n    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    ret = []\n    size = parsedType.size\n\n    if (parsedType.size === 'dynamic') {\n      offset = decodeSingle('uint256', data, offset).toNumber()\n      size = decodeSingle('uint256', data, offset).toNumber()\n      offset = offset + 32\n    }\n    for (i = 0; i < size; i++) {\n      var decoded = decodeSingle(parsedType.subArray, data, offset)\n      ret.push(decoded)\n      offset += parsedType.subArray.memoryUsage\n    }\n    return ret\n  } else if (parsedType.name === 'bytes') {\n    offset = decodeSingle('uint256', data, offset).toNumber()\n    size = decodeSingle('uint256', data, offset).toNumber()\n    return data.slice(offset + 32, offset + 32 + size)\n  } else if (parsedType.name.startsWith('bytes')) {\n    return data.slice(offset, offset + parsedType.size)\n  } else if (parsedType.name.startsWith('uint')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be')\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())\n    }\n    return num\n  } else if (parsedType.name.startsWith('int')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256)\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())\n    }\n\n    return num\n  } else if (parsedType.name.startsWith('ufixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]))\n    num = decodeSingle('uint256', data, offset)\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet')\n    }\n    return num.div(size)\n  } else if (parsedType.name.startsWith('fixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]))\n    num = decodeSingle('int256', data, offset)\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet')\n    }\n    return num.div(size)\n  }\n  throw new Error('Unsupported or invalid type: ' + parsedType.name)\n}\n\n// Parse the given type\n// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)\nfunction parseType (type) {\n  var size\n  var ret\n  if (isArray(type)) {\n    size = parseTypeArray(type)\n    var subArray = type.slice(0, type.lastIndexOf('['))\n    subArray = parseType(subArray)\n    ret = {\n      isArray: true,\n      name: type,\n      size: size,\n      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,\n      subArray: subArray\n    }\n    return ret\n  } else {\n    var rawType\n    switch (type) {\n      case 'address':\n        rawType = 'uint160'\n        break\n      case 'bool':\n        rawType = 'uint8'\n        break\n      case 'string':\n        rawType = 'bytes'\n        break\n    }\n    ret = {\n      rawType: rawType,\n      name: type,\n      memoryUsage: 32\n    }\n\n    if ((type.startsWith('bytes') && type !== 'bytes') || type.startsWith('uint') || type.startsWith('int')) {\n      ret.size = parseTypeN(type)\n    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {\n      ret.size = parseTypeNxM(type)\n    }\n\n    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {\n      throw new Error('Invalid bytes<N> width: ' + ret.size)\n    }\n    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\n      throw new Error('Invalid int/uint<N> width: ' + ret.size)\n    }\n    return ret\n  }\n}\n\n// Is a type dynamic?\nfunction isDynamic (type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')\n}\n\n// Is a type an array?\nfunction isArray (type) {\n  return type.lastIndexOf(']') === type.length - 1\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nABI.rawEncode = function (types, values) {\n  var output = []\n  var data = []\n\n  var headLength = 0\n\n  types.forEach(function (type) {\n    if (isArray(type)) {\n      var size = parseTypeArray(type)\n\n      if (size !== 'dynamic') {\n        headLength += 32 * size\n      } else {\n        headLength += 32\n      }\n    } else {\n      headLength += 32\n    }\n  })\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    var cur = encodeSingle(type, value)\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength))\n      data.push(cur)\n      headLength += cur.length\n    } else {\n      output.push(cur)\n    }\n  }\n\n  return Buffer.concat(output.concat(data))\n}\n\nABI.rawDecode = function (types, data) {\n  var ret = []\n  data = Buffer.from(data)\n  var offset = 0\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var parsed = parseType(type, data, offset)\n    var decoded = decodeSingle(parsed, data, offset)\n    offset += parsed.memoryUsage\n    ret.push(decoded)\n  }\n  return ret\n}\n\nABI.simpleEncode = function (method) {\n  var args = Array.prototype.slice.call(arguments).slice(1)\n  var sig = parseSignature(method)\n\n  // FIXME: validate/convert arguments\n  if (args.length !== sig.args.length) {\n    throw new Error('Argument count mismatch')\n  }\n\n  return Buffer.concat([ ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args) ])\n}\n\nABI.simpleDecode = function (method, data) {\n  var sig = parseSignature(method)\n\n  // FIXME: validate/convert arguments\n  if (!sig.retargs) {\n    throw new Error('No return values in method')\n  }\n\n  return ABI.rawDecode(sig.retargs, data)\n}\n\nfunction stringify (type, value) {\n  if (type.startsWith('address') || type.startsWith('bytes')) {\n    return '0x' + value.toString('hex')\n  } else {\n    return value.toString()\n  }\n}\n\nABI.stringify = function (types, values) {\n  var ret = []\n\n  for (var i in types) {\n    var type = types[i]\n    var value = values[i]\n\n    // if it is an array type, concat the items\n    if (/^[^\\[]+\\[.*\\]$/.test(type)) {\n      value = value.map(function (item) {\n        return stringify(type, item)\n      }).join(', ')\n    } else {\n      value = stringify(type, value)\n    }\n\n    ret.push(value)\n  }\n\n  return ret\n}\n\nABI.solidityHexValue = function (type, value, bitsize) {\n  // pass in bitsize = null if use default bitsize\n  var size, num\n  if (isArray(type)) {\n    var subType = type.replace(/\\[.*?\\]/, '')\n    if (!isArray(subType)) {\n      var arraySize = parseTypeArray(type)\n      if (arraySize !== 'dynamic' && arraySize !== 0 && value.length > arraySize) {\n        throw new Error('Elements exceed array size: ' + arraySize)\n      }\n    }\n    var arrayValues = value.map(function (v) {\n      return ABI.solidityHexValue(subType, v, 256)\n    })\n    return Buffer.concat(arrayValues)\n  } else if (type === 'bytes') {\n    return value\n  } else if (type === 'string') {\n    return Buffer.from(value, 'utf8')\n  } else if (type === 'bool') {\n    bitsize = bitsize || 8\n    var padding = Array((bitsize) / 4).join('0')\n    return Buffer.from(value ? padding + '1' : padding + '0', 'hex')\n  } else if (type === 'address') {\n    var bytesize = 20\n    if (bitsize) {\n      bytesize = bitsize / 8\n    }\n    return utils.setLengthLeft(value, bytesize)\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return utils.setLengthRight(value, size)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(value)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    bitsize = bitsize || size\n    return num.toArrayLike(Buffer, 'be', bitsize / 8)\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(value)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    bitsize = bitsize || size\n    return num.toTwos(size).toArrayLike(Buffer, 'be', bitsize / 8)\n  } else {\n    // FIXME: support all other types\n    throw new Error('Unsupported or invalid type: ' + type)\n  }\n}\n\nABI.solidityPack = function (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values')\n  }\n\n  var ret = []\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    ret.push(ABI.solidityHexValue(type, value, null))\n  }\n\n  return Buffer.concat(ret)\n}\n\nABI.soliditySHA3 = function (types, values) {\n  return utils.keccak256(ABI.solidityPack(types, values))\n}\n\nABI.soliditySHA256 = function (types, values) {\n  return utils.sha256(ABI.solidityPack(types, values))\n}\n\nABI.solidityRIPEMD160 = function (types, values) {\n  return utils.ripemd160(ABI.solidityPack(types, values), true)\n}\n\n// Serpent's users are familiar with this encoding\n// - s: string\n// - b: bytes\n// - b<N>: bytes<N>\n// - i: int256\n// - a: int256[]\n\nfunction isNumeric (c) {\n  // FIXME: is this correct? Seems to work\n  return (c >= '0') && (c <= '9')\n}\n\n// For a \"documentation\" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp\nABI.fromSerpent = function (sig) {\n  var ret = []\n  for (var i = 0; i < sig.length; i++) {\n    var type = sig[i]\n    if (type === 's') {\n      ret.push('bytes')\n    } else if (type === 'b') {\n      var tmp = 'bytes'\n      var j = i + 1\n      while ((j < sig.length) && isNumeric(sig[j])) {\n        tmp += sig[j] - '0'\n        j++\n      }\n      i = j - 1\n      ret.push(tmp)\n    } else if (type === 'i') {\n      ret.push('int256')\n    } else if (type === 'a') {\n      ret.push('int256[]')\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n  return ret\n}\n\nABI.toSerpent = function (types) {\n  var ret = []\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i]\n    if (type === 'bytes') {\n      ret.push('s')\n    } else if (type.startsWith('bytes')) {\n      ret.push('b' + parseTypeN(type))\n    } else if (type === 'int256') {\n      ret.push('i')\n    } else if (type === 'int256[]') {\n      ret.push('a')\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n  return ret.join('')\n}\n\nmodule.exports = ABI\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}