{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccak(prefix + address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n  from = bytes_1.toBuffer(from);\n  var nonceBN = new BN(nonce);\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = bytes_1.toBuffer(from);\n  var saltBuf = bytes_1.toBuffer(salt);\n  var initCodeBuf = bytes_1.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\nexports.isPrecompiled = function (address) {\n  var a = bytes_1.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  pubKey = bytes_1.toBuffer(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n  assert(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n  privateKey = bytes_1.toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n  publicKey = bytes_1.toBuffer(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n  return publicKey;\n};","map":{"version":3,"mappings":"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","names":["assert","require","ethjsUtil","secp256k1","exports","addressLength","addr","bytes_1","address","test","zeroAddr","eip1191ChainId","stripHexPrefix","toLowerCase","prefix","undefined","toString","hash","hash_1","ret","i","length","parseInt","toUpperCase","from","nonce","nonceBN","BN","isZero","slice","Buffer","toArray","salt","initCode","fromBuf","saltBuf","initCodeBuf","concat","a","privateKey","privateKeyVerify","publicKey","sanitize","publicKeyVerify","pubKey","publicKeyConvert","publicKeyCreate"],"sourceRoot":"","sources":["../src/account.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}