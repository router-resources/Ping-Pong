{"ast":null,"code":"\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nvar nodeCrypto = require('crypto');\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\nfunction sha512(msg) {\n  return new Promise(function (resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\nfunction getAes(op) {\n  return function (iv, key, data) {\n    return new Promise(function (resolve) {\n      if (subtle) {\n        var importAlgorithm = {\n          name: \"AES-CBC\"\n        };\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function (cryptoKey) {\n          var encAlgorithm = {\n            name: \"AES-CBC\",\n            iv: iv\n          };\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function (result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        } else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function (resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function (resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nvar getPublic = exports.getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function (privateKey, msg) {\n  return new Promise(function (resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {\n      canonical: true\n    }).toDER()));\n  });\n};\nexports.verify = function (publicKey, msg, sig) {\n  return new Promise(function (resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65) {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33) {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\nvar derive = exports.derive = function (privateKeyA, publicKeyB) {\n  return new Promise(function (resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic()); // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\nexports.encrypt = function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function (resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while (!isValidPrivateKey(ephemPrivateKey)) {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function (Px) {\n    return sha512(Px);\n  }).then(function (hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function (data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function (mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac\n    };\n  });\n};\nexports.decrypt = function (privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function (Px) {\n    return sha512(Px);\n  }).then(function (hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function (macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function (msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};","map":{"version":3,"names":["EC","require","ec","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isScalar","x","isBuffer","length","isValidPrivateKey","privateKey","compare","equalConstTime","b1","b2","res","i","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","Promise","resolve","hash","createHash","result","update","digest","getAes","op","iv","key","data","importAlgorithm","name","keyp","importKey","then","cryptoKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","hmacSha256Sign","hmac","createHmac","hmacSha256Verify","sig","expectedSig","exports","generatePrivate","getPublic","keyFromPrivate","getPublicCompressed","compressed","sign","canonical","toDER","verify","publicKey","reject","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","encrypt","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","encryptionKey","slice","dataToMac","mac","decrypt","macGood"],"sources":["/Users/shivamsoni/Desktop/router/pingspong/Ping-Pong/node_modules/@toruslabs/eccrypto/browser.js"],"sourcesContent":["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,UAAU,CAAC,CAACC,EAAE;AAE/B,IAAIA,EAAE,GAAG,IAAIF,EAAE,CAAC,WAAW,CAAC;AAC5B,IAAIG,aAAa,GAAGC,MAAM,CAACC,MAAM,IAAID,MAAM,CAACE,QAAQ,IAAI,CAAC,CAAC;AAC1D,IAAIC,MAAM,GAAGJ,aAAa,CAACI,MAAM,IAAIJ,aAAa,CAACK,YAAY;AAE/D,IAAIC,UAAU,GAAGR,OAAO,CAAC,QAAQ,CAAC;AAElC,MAAMS,cAAc,GAAGC,MAAM,CAACC,IAAI,CAAC,kEAAkE,EAAE,KAAK,CAAC;AAC7G,MAAMC,MAAM,GAAGF,MAAM,CAACG,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;AAElC,SAASC,MAAM,CAACC,SAAS,EAAEC,OAAO,EAAE;EAClC,IAAI,CAACD,SAAS,EAAE;IACd,MAAM,IAAIE,KAAK,CAACD,OAAO,IAAI,kBAAkB,CAAC;EAChD;AACF;AAEA,SAASE,QAAQ,CAAEC,CAAC,EAAE;EACpB,OAAOT,MAAM,CAACU,QAAQ,CAACD,CAAC,CAAC,IAAIA,CAAC,CAACE,MAAM,KAAK,EAAE;AAC9C;AAEA,SAASC,iBAAiB,CAACC,UAAU,EAAE;EACrC,IAAI,CAACL,QAAQ,CAACK,UAAU,CAAC,EACzB;IACE,OAAO,KAAK;EACd;EACA,OAAOA,UAAU,CAACC,OAAO,CAACZ,MAAM,CAAC,GAAG,CAAC;EAAI;EACzCW,UAAU,CAACC,OAAO,CAACf,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;AAC1C;;AAEA;AACA,SAASgB,cAAc,CAACC,EAAE,EAAEC,EAAE,EAAE;EAC9B,IAAID,EAAE,CAACL,MAAM,KAAKM,EAAE,CAACN,MAAM,EAAE;IAC3B,OAAO,KAAK;EACd;EACA,IAAIO,GAAG,GAAG,CAAC;EACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,EAAE,CAACL,MAAM,EAAEQ,CAAC,EAAE,EAAE;IAClCD,GAAG,IAAIF,EAAE,CAACG,CAAC,CAAC,GAAGF,EAAE,CAACE,CAAC,CAAC,CAAC,CAAE;EACzB;;EACA,OAAOD,GAAG,KAAK,CAAC;AAClB;;AAEA;AACA;AACA;AACA,SAASE,WAAW,CAACC,IAAI,EAAE;EACzB,IAAIC,GAAG,GAAG,IAAIC,UAAU,CAACF,IAAI,CAAC;EAC9B,IAAI,OAAO7B,aAAa,CAACgC,eAAe,KAAK,WAAW,EAAE;IACxD,OAAOxB,MAAM,CAACC,IAAI,CAACH,UAAU,CAACsB,WAAW,CAACC,IAAI,CAAC,CAAC;EAClD,CAAC,MAAM;IACL7B,aAAa,CAACgC,eAAe,CAACF,GAAG,CAAC;EACpC;EACA,OAAOtB,MAAM,CAACC,IAAI,CAACqB,GAAG,CAAC;AACzB;AAEA,SAASG,MAAM,CAACC,GAAG,EAAE;EACnB,OAAO,IAAIC,OAAO,CAAC,UAASC,OAAO,EAAE;IACnC,IAAIC,IAAI,GAAG/B,UAAU,CAACgC,UAAU,CAAC,QAAQ,CAAC;IAC1C,IAAIC,MAAM,GAAGF,IAAI,CAACG,MAAM,CAACN,GAAG,CAAC,CAACO,MAAM,EAAE;IACtCL,OAAO,CAAC,IAAIL,UAAU,CAACQ,MAAM,CAAC,CAAC;EACjC,CAAC,CAAC;AACJ;AAEA,SAASG,MAAM,CAACC,EAAE,EAAE;EAClB,OAAO,UAASC,EAAE,EAAEC,GAAG,EAAEC,IAAI,EAAE;IAC7B,OAAO,IAAIX,OAAO,CAAC,UAASC,OAAO,EAAE;MACnC,IAAIhC,MAAM,EAAE;QACV,IAAI2C,eAAe,GAAG;UAACC,IAAI,EAAE;QAAS,CAAC;QACvC,IAAIC,IAAI,GAAG7C,MAAM,CAAC8C,SAAS,CAAC,KAAK,EAAEL,GAAG,EAAEE,eAAe,EAAE,KAAK,EAAE,CAACJ,EAAE,CAAC,CAAC;QACrE,OAAOM,IAAI,CAACE,IAAI,CAAC,UAASC,SAAS,EAAE;UACnC,IAAIC,YAAY,GAAG;YAACL,IAAI,EAAE,SAAS;YAAEJ,EAAE,EAAEA;UAAE,CAAC;UAC5C,OAAOxC,MAAM,CAACuC,EAAE,CAAC,CAACU,YAAY,EAAED,SAAS,EAAEN,IAAI,CAAC;QAClD,CAAC,CAAC,CAACK,IAAI,CAAC,UAASZ,MAAM,EAAE;UACvBH,OAAO,CAAC5B,MAAM,CAACC,IAAI,CAAC,IAAIsB,UAAU,CAACQ,MAAM,CAAC,CAAC,CAAC;QAC9C,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAII,EAAE,KAAK,SAAS,EAAE;UACpB,IAAIW,MAAM,GAAGhD,UAAU,CAACiD,cAAc,CAAC,aAAa,EAAEV,GAAG,EAAED,EAAE,CAAC;UAC9D,IAAIY,UAAU,GAAGF,MAAM,CAACd,MAAM,CAACM,IAAI,CAAC;UACpC,IAAIW,WAAW,GAAGH,MAAM,CAACI,KAAK,EAAE;UAChCtB,OAAO,CAAC5B,MAAM,CAACmD,MAAM,CAAC,CAACH,UAAU,EAAEC,WAAW,CAAC,CAAC,CAAC;QACnD,CAAC,MACI,IAAId,EAAE,KAAK,SAAS,EAAE;UACzB,IAAIiB,QAAQ,GAAGtD,UAAU,CAACuD,gBAAgB,CAAC,aAAa,EAAEhB,GAAG,EAAED,EAAE,CAAC;UAClE,IAAIY,UAAU,GAAGI,QAAQ,CAACpB,MAAM,CAACM,IAAI,CAAC;UACtC,IAAIW,WAAW,GAAGG,QAAQ,CAACF,KAAK,EAAE;UAClCtB,OAAO,CAAC5B,MAAM,CAACmD,MAAM,CAAC,CAACH,UAAU,EAAEC,WAAW,CAAC,CAAC,CAAC;QACnD;MACF;IACF,CAAC,CAAC;EACJ,CAAC;AACH;AAEA,IAAIK,aAAa,GAAGpB,MAAM,CAAC,SAAS,CAAC;AACrC,IAAIqB,aAAa,GAAGrB,MAAM,CAAC,SAAS,CAAC;AAErC,SAASsB,cAAc,CAACnB,GAAG,EAAEX,GAAG,EAAE;EAChC,OAAO,IAAIC,OAAO,CAAC,UAASC,OAAO,EAAE;IACnC,IAAI6B,IAAI,GAAG3D,UAAU,CAAC4D,UAAU,CAAC,QAAQ,EAAE1D,MAAM,CAACC,IAAI,CAACoC,GAAG,CAAC,CAAC;IAC5DoB,IAAI,CAACzB,MAAM,CAACN,GAAG,CAAC;IAChB,IAAIK,MAAM,GAAG0B,IAAI,CAACxB,MAAM,EAAE;IAC1BL,OAAO,CAACG,MAAM,CAAC;EACjB,CAAC,CAAC;AACJ;AAEA,SAAS4B,gBAAgB,CAACtB,GAAG,EAAEX,GAAG,EAAEkC,GAAG,EAAE;EACvC,OAAO,IAAIjC,OAAO,CAAC,UAASC,OAAO,EAAE;IACnC,IAAI6B,IAAI,GAAG3D,UAAU,CAAC4D,UAAU,CAAC,QAAQ,EAAE1D,MAAM,CAACC,IAAI,CAACoC,GAAG,CAAC,CAAC;IAC5DoB,IAAI,CAACzB,MAAM,CAACN,GAAG,CAAC;IAChB,IAAImC,WAAW,GAAGJ,IAAI,CAACxB,MAAM,EAAE;IAC/BL,OAAO,CAACb,cAAc,CAAC8C,WAAW,EAAED,GAAG,CAAC,CAAC;EAC3C,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAE,OAAO,CAACC,eAAe,GAAG,YAAY;EACpC,IAAIlD,UAAU,GAAGO,WAAW,CAAC,EAAE,CAAC;EAChC,OAAO,CAACR,iBAAiB,CAACC,UAAU,CAAC,EAAE;IACrCA,UAAU,GAAGO,WAAW,CAAC,EAAE,CAAC;EAC9B;EACA,OAAOP,UAAU;AACnB,CAAC;AAED,IAAImD,SAAS,GAAGF,OAAO,CAACE,SAAS,GAAG,UAASnD,UAAU,EAAE;EACvD;EACAT,MAAM,CAACS,UAAU,CAACF,MAAM,KAAK,EAAE,EAAE,iBAAiB,CAAC;EACnDP,MAAM,CAACQ,iBAAiB,CAACC,UAAU,CAAC,EAAE,iBAAiB,CAAC;EACxD;EACA;EACA,OAAOb,MAAM,CAACC,IAAI,CAACV,EAAE,CAAC0E,cAAc,CAACpD,UAAU,CAAC,CAACmD,SAAS,CAAC,KAAK,CAAC,CAAC;AACpE,CAAC;;AAED;AACA;AACA;AACA,IAAIE,mBAAmB,GAAGJ,OAAO,CAACI,mBAAmB,GAAG,UAASrD,UAAU,EAAE;EAAE;EAC7ET,MAAM,CAACS,UAAU,CAACF,MAAM,KAAK,EAAE,EAAE,iBAAiB,CAAC;EACnDP,MAAM,CAACQ,iBAAiB,CAACC,UAAU,CAAC,EAAE,iBAAiB,CAAC;EACxD;EACA,IAAIsD,UAAU,GAAG,IAAI;EACrB,OAAOnE,MAAM,CAACC,IAAI,CAACV,EAAE,CAAC0E,cAAc,CAACpD,UAAU,CAAC,CAACmD,SAAS,CAACG,UAAU,EAAE,KAAK,CAAC,CAAC;AAChF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAL,OAAO,CAACM,IAAI,GAAG,UAASvD,UAAU,EAAEa,GAAG,EAAE;EACvC,OAAO,IAAIC,OAAO,CAAC,UAASC,OAAO,EAAE;IACnCxB,MAAM,CAACS,UAAU,CAACF,MAAM,KAAK,EAAE,EAAE,iBAAiB,CAAC;IACnDP,MAAM,CAACQ,iBAAiB,CAACC,UAAU,CAAC,EAAE,iBAAiB,CAAC;IACxDT,MAAM,CAACsB,GAAG,CAACf,MAAM,GAAG,CAAC,EAAE,6BAA6B,CAAC;IACrDP,MAAM,CAACsB,GAAG,CAACf,MAAM,IAAI,EAAE,EAAE,qBAAqB,CAAC;IAC/CiB,OAAO,CAAC5B,MAAM,CAACC,IAAI,CAACV,EAAE,CAAC6E,IAAI,CAAC1C,GAAG,EAAEb,UAAU,EAAE;MAACwD,SAAS,EAAE;IAAI,CAAC,CAAC,CAACC,KAAK,EAAE,CAAC,CAAC;EAC3E,CAAC,CAAC;AACJ,CAAC;AAEDR,OAAO,CAACS,MAAM,GAAG,UAASC,SAAS,EAAE9C,GAAG,EAAEkC,GAAG,EAAE;EAC7C,OAAO,IAAIjC,OAAO,CAAC,UAASC,OAAO,EAAE6C,MAAM,EAAE;IAC3CrE,MAAM,CAACoE,SAAS,CAAC7D,MAAM,KAAK,EAAE,IAAI6D,SAAS,CAAC7D,MAAM,KAAK,EAAE,EAAE,gBAAgB,CAAC;IAC5E,IAAI6D,SAAS,CAAC7D,MAAM,KAAK,EAAE,EAC3B;MACEP,MAAM,CAACoE,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC;IAC9C;IACA,IAAIA,SAAS,CAAC7D,MAAM,KAAK,EAAE,EAC3B;MACEP,MAAM,CAACoE,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIA,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC;IACpE;IACApE,MAAM,CAACsB,GAAG,CAACf,MAAM,GAAG,CAAC,EAAE,6BAA6B,CAAC;IACrDP,MAAM,CAACsB,GAAG,CAACf,MAAM,IAAI,EAAE,EAAE,qBAAqB,CAAC;IAC/C,IAAIpB,EAAE,CAACgF,MAAM,CAAC7C,GAAG,EAAEkC,GAAG,EAAEY,SAAS,CAAC,EAAE;MAClC5C,OAAO,CAAC,IAAI,CAAC;IACf,CAAC,MAAM;MACL6C,MAAM,CAAC,IAAIlE,KAAK,CAAC,eAAe,CAAC,CAAC;IACpC;EACF,CAAC,CAAC;AACJ,CAAC;AAED,IAAImE,MAAM,GAAGZ,OAAO,CAACY,MAAM,GAAG,UAASC,WAAW,EAAEC,UAAU,EAAE;EAC9D,OAAO,IAAIjD,OAAO,CAAC,UAASC,OAAO,EAAE;IACnCxB,MAAM,CAACJ,MAAM,CAACU,QAAQ,CAACiE,WAAW,CAAC,EAAE,iBAAiB,CAAC;IACvDvE,MAAM,CAACJ,MAAM,CAACU,QAAQ,CAACkE,UAAU,CAAC,EAAE,gBAAgB,CAAC;IACrDxE,MAAM,CAACuE,WAAW,CAAChE,MAAM,KAAK,EAAE,EAAE,iBAAiB,CAAC;IACpDP,MAAM,CAACQ,iBAAiB,CAAC+D,WAAW,CAAC,EAAE,iBAAiB,CAAC;IACzDvE,MAAM,CAACwE,UAAU,CAACjE,MAAM,KAAK,EAAE,IAAIiE,UAAU,CAACjE,MAAM,KAAK,EAAE,EAAE,gBAAgB,CAAC;IAC9E,IAAIiE,UAAU,CAACjE,MAAM,KAAK,EAAE,EAC5B;MACEP,MAAM,CAACwE,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC;IAC/C;IACA,IAAIA,UAAU,CAACjE,MAAM,KAAK,EAAE,EAC5B;MACEP,MAAM,CAACwE,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC;IACtE;IACA,IAAIC,IAAI,GAAGtF,EAAE,CAAC0E,cAAc,CAACU,WAAW,CAAC;IACzC,IAAIG,IAAI,GAAGvF,EAAE,CAACwF,aAAa,CAACH,UAAU,CAAC;IACvC,IAAII,EAAE,GAAGH,IAAI,CAACH,MAAM,CAACI,IAAI,CAACd,SAAS,EAAE,CAAC,CAAC,CAAE;IACzCpC,OAAO,CAAC5B,MAAM,CAACC,IAAI,CAAC+E,EAAE,CAACC,OAAO,EAAE,CAAC,CAAC;EACpC,CAAC,CAAC;AACJ,CAAC;AAEDnB,OAAO,CAACoB,OAAO,GAAG,UAASC,WAAW,EAAEzD,GAAG,EAAE0D,IAAI,EAAE;EACjDA,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EACjB;EACA,IAAIhD,EAAE,EAAEiD,cAAc,EAAEC,UAAU,EAAEC,MAAM;EAC1C,OAAO,IAAI5D,OAAO,CAAC,UAASC,OAAO,EAAE;IACnC,IAAI4D,eAAe,GAAGJ,IAAI,CAACI,eAAe,IAAIpE,WAAW,CAAC,EAAE,CAAC;IAC7D;IACA,OAAM,CAACR,iBAAiB,CAAC4E,eAAe,CAAC,EACzC;MACEA,eAAe,GAAGJ,IAAI,CAACI,eAAe,IAAIpE,WAAW,CAAC,EAAE,CAAC;IAC3D;IACAiE,cAAc,GAAGrB,SAAS,CAACwB,eAAe,CAAC;IAC3C5D,OAAO,CAAC8C,MAAM,CAACc,eAAe,EAAEL,WAAW,CAAC,CAAC;EAC/C,CAAC,CAAC,CAACxC,IAAI,CAAC,UAASqC,EAAE,EAAE;IACnB,OAAOvD,MAAM,CAACuD,EAAE,CAAC;EACnB,CAAC,CAAC,CAACrC,IAAI,CAAC,UAASd,IAAI,EAAE;IACrBO,EAAE,GAAGgD,IAAI,CAAChD,EAAE,IAAIhB,WAAW,CAAC,EAAE,CAAC;IAC/B,IAAIqE,aAAa,GAAG5D,IAAI,CAAC6D,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IACrCH,MAAM,GAAG1D,IAAI,CAAC6D,KAAK,CAAC,EAAE,CAAC;IACvB,OAAOpC,aAAa,CAAClB,EAAE,EAAEqD,aAAa,EAAE/D,GAAG,CAAC;EAC9C,CAAC,CAAC,CAACiB,IAAI,CAAC,UAASL,IAAI,EAAE;IACrBgD,UAAU,GAAGhD,IAAI;IACjB,IAAIqD,SAAS,GAAG3F,MAAM,CAACmD,MAAM,CAAC,CAACf,EAAE,EAAEiD,cAAc,EAAEC,UAAU,CAAC,CAAC;IAC/D,OAAO9B,cAAc,CAAC+B,MAAM,EAAEI,SAAS,CAAC;EAC1C,CAAC,CAAC,CAAChD,IAAI,CAAC,UAASiD,GAAG,EAAE;IACpB,OAAO;MACLxD,EAAE,EAAEA,EAAE;MACNiD,cAAc,EAAEA,cAAc;MAC9BC,UAAU,EAAEA,UAAU;MACtBM,GAAG,EAAEA;IACP,CAAC;EACH,CAAC,CAAC;AACJ,CAAC;AAED9B,OAAO,CAAC+B,OAAO,GAAG,UAAShF,UAAU,EAAEuE,IAAI,EAAE;EAC3C;EACA,IAAIK,aAAa;EACjB,OAAOf,MAAM,CAAC7D,UAAU,EAAEuE,IAAI,CAACC,cAAc,CAAC,CAAC1C,IAAI,CAAC,UAASqC,EAAE,EAAE;IAC/D,OAAOvD,MAAM,CAACuD,EAAE,CAAC;EACnB,CAAC,CAAC,CAACrC,IAAI,CAAC,UAASd,IAAI,EAAE;IACrB4D,aAAa,GAAG5D,IAAI,CAAC6D,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IACjC,IAAIH,MAAM,GAAG1D,IAAI,CAAC6D,KAAK,CAAC,EAAE,CAAC;IAC3B,IAAIC,SAAS,GAAG3F,MAAM,CAACmD,MAAM,CAAC,CAC5BiC,IAAI,CAAChD,EAAE,EACPgD,IAAI,CAACC,cAAc,EACnBD,IAAI,CAACE,UAAU,CAChB,CAAC;IACF,OAAO3B,gBAAgB,CAAC4B,MAAM,EAAEI,SAAS,EAAEP,IAAI,CAACQ,GAAG,CAAC;EACtD,CAAC,CAAC,CAACjD,IAAI,CAAC,UAASmD,OAAO,EAAE;IACxB1F,MAAM,CAAC0F,OAAO,EAAE,SAAS,CAAC;IAC1B,OAAOvC,aAAa,CAAC6B,IAAI,CAAChD,EAAE,EAAEqD,aAAa,EAAEL,IAAI,CAACE,UAAU,CAAC;EAC/D,CAAC,CAAC,CAAC3C,IAAI,CAAC,UAASjB,GAAG,EAAE;IACpB,OAAO1B,MAAM,CAACC,IAAI,CAAC,IAAIsB,UAAU,CAACG,GAAG,CAAC,CAAC;EACzC,CAAC,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"script"}