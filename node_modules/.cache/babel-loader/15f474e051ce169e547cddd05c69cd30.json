{"ast":null,"code":"'use strict';\n\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\nvar secp256k1v3 = require('./secp256k1-lib/index');\nvar der = require('./secp256k1-lib/der');\n\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\nvar privateKeyVerify = function privateKeyVerify(privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\nvar privateKeyExport = function privateKeyExport(privateKey, compressed) {\n  // privateKeyExport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\nvar privateKeyImport = function privateKeyImport(privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n  throw new Error(\"couldn't import from DER format\");\n};\n\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar privateKeyNegate = function privateKeyNegate(privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar privateKeyModInverse = function privateKeyModInverse(privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nvar privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nvar privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyCreate = function publicKeyCreate(privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyConvert = function publicKeyConvert(publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nvar publicKeyVerify = function publicKeyVerify(publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureNormalize = function signatureNormalize(signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureExport = function signatureExport(signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureImport = function signatureImport(signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureImportLax = function signatureImportLax(signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n  var sigObj = der.signatureImportLax(signature);\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n  return secp256k1v3.signatureImport(sigObj);\n};\n\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\nvar sign = function sign(message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n  var signOptions = void 0;\n  if (options) {\n    signOptions = {};\n    if (options.data === null) {\n      throw new TypeError('options.data should be a Buffer');\n    }\n    if (options.data) {\n      // validate option.data length\n      if (options.data.length !== 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n      signOptions.data = new Uint8Array(options.data);\n    }\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n    if (options.noncefn) {\n      //  convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n        var buffer = Buffer.from('');\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n        return Uint8Array.from(buffer);\n      };\n    }\n  }\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nvar verify = function verify(message, signature, publicKey) {\n  // note: secp256k1 v4 verify method has a different argument order\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar recover = function recover(message, signature, recid, compressed) {\n  // note: secp256k1 v4 recover method has a different argument order\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar ecdh = function ecdh(publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\n\n/**\n * Compute an EC Diffie-Hellman secret and return public key as result\n * @method ecdhUnsafe\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  }\n\n  // ensure valid privateKey length\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};\nmodule.exports = {\n  privateKeyVerify: privateKeyVerify,\n  privateKeyExport: privateKeyExport,\n  privateKeyImport: privateKeyImport,\n  privateKeyNegate: privateKeyNegate,\n  privateKeyModInverse: privateKeyModInverse,\n  privateKeyTweakAdd: privateKeyTweakAdd,\n  privateKeyTweakMul: privateKeyTweakMul,\n  publicKeyCreate: publicKeyCreate,\n  publicKeyConvert: publicKeyConvert,\n  publicKeyVerify: publicKeyVerify,\n  publicKeyTweakAdd: publicKeyTweakAdd,\n  publicKeyTweakMul: publicKeyTweakMul,\n  publicKeyCombine: publicKeyCombine,\n  signatureNormalize: signatureNormalize,\n  signatureExport: signatureExport,\n  signatureImport: signatureImport,\n  signatureImportLax: signatureImportLax,\n  sign: sign,\n  verify: verify,\n  recover: recover,\n  ecdh: ecdh,\n  ecdhUnsafe: ecdhUnsafe\n};","map":{"version":3,"names":["secp256k1","require","secp256k1v3","der","privateKeyVerify","privateKey","length","Uint8Array","from","privateKeyExport","compressed","RangeError","publicKey","privateKeyImport","Error","privateKeyNegate","Buffer","privateKeyModInverse","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyCreate","publicKeyConvert","publicKeyVerify","publicKeyTweakAdd","publicKeyTweakMul","publicKeyCombine","publicKeys","keys","forEach","push","signatureNormalize","signature","signatureExport","signatureImport","signatureImportLax","sigObj","sign","message","options","TypeError","signOptions","data","noncefn","algo","attempt","bufferAlgo","bufferData","buffer","sig","ecdsaSign","recovery","recid","verify","ecdsaVerify","recover","ecdsaRecover","ecdh","ecdhUnsafe","module","exports"],"sources":["/Users/shivamsoni/Desktop/router/pingspong/Ping-Pong/node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/secp256k1-adapter.js"],"sourcesContent":["'use strict';\n\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\n\nvar secp256k1v3 = require('./secp256k1-lib/index');\nvar der = require('./secp256k1-lib/der');\n\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\nvar privateKeyVerify = function privateKeyVerify(privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\nvar privateKeyExport = function privateKeyExport(privateKey, compressed) {\n  // privateKeyExport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\nvar privateKeyImport = function privateKeyImport(privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n\n  throw new Error(\"couldn't import from DER format\");\n};\n\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar privateKeyNegate = function privateKeyNegate(privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar privateKeyModInverse = function privateKeyModInverse(privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nvar privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nvar privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyCreate = function publicKeyCreate(privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyConvert = function publicKeyConvert(publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nvar publicKeyVerify = function publicKeyVerify(publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureNormalize = function signatureNormalize(signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureExport = function signatureExport(signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureImport = function signatureImport(signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureImportLax = function signatureImportLax(signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n\n  var sigObj = der.signatureImportLax(signature);\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n\n  return secp256k1v3.signatureImport(sigObj);\n};\n\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\nvar sign = function sign(message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n\n  var signOptions = void 0;\n\n  if (options) {\n    signOptions = {};\n\n    if (options.data === null) {\n      throw new TypeError('options.data should be a Buffer');\n    }\n\n    if (options.data) {\n      // validate option.data length\n      if (options.data.length !== 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n\n      signOptions.data = new Uint8Array(options.data);\n    }\n\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n\n    if (options.noncefn) {\n      //  convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n\n        var buffer = Buffer.from('');\n\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n\n        return Uint8Array.from(buffer);\n      };\n    }\n  }\n\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nvar verify = function verify(message, signature, publicKey) {\n  // note: secp256k1 v4 verify method has a different argument order\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar recover = function recover(message, signature, recid, compressed) {\n  // note: secp256k1 v4 recover method has a different argument order\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar ecdh = function ecdh(publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\n\n/**\n * Compute an EC Diffie-Hellman secret and return public key as result\n * @method ecdhUnsafe\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  }\n\n  // ensure valid privateKey length\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};\n\nmodule.exports = {\n  privateKeyVerify: privateKeyVerify,\n  privateKeyExport: privateKeyExport,\n  privateKeyImport: privateKeyImport,\n  privateKeyNegate: privateKeyNegate,\n  privateKeyModInverse: privateKeyModInverse,\n  privateKeyTweakAdd: privateKeyTweakAdd,\n  privateKeyTweakMul: privateKeyTweakMul,\n\n  publicKeyCreate: publicKeyCreate,\n  publicKeyConvert: publicKeyConvert,\n  publicKeyVerify: publicKeyVerify,\n  publicKeyTweakAdd: publicKeyTweakAdd,\n  publicKeyTweakMul: publicKeyTweakMul,\n  publicKeyCombine: publicKeyCombine,\n\n  signatureNormalize: signatureNormalize,\n  signatureExport: signatureExport,\n  signatureImport: signatureImport,\n  signatureImportLax: signatureImportLax,\n\n  sign: sign,\n  verify: verify,\n  recover: recover,\n\n  ecdh: ecdh,\n  ecdhUnsafe: ecdhUnsafe\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}