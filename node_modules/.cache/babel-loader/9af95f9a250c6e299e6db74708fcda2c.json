{"ast":null,"code":"\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\nlet ModifiersNest = {\n  calldata: true,\n  memory: true\n};\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n    if (ModifiersNest[name]) {\n      return true;\n    }\n  }\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n  return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n  let originalParam = param;\n  function throwError(i) {\n    logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n  }\n  param = param.replace(/\\s/g, \" \");\n  function newNode(parent) {\n    let node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n    return node;\n  }\n  let parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  let node = parent;\n  for (let i = 0; i < param.length; i++) {\n    let c = param[i];\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n      case \")\":\n        delete node.state;\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n          node.indexed = true;\n          node.name = \"\";\n        }\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n        node.type = verifyType(node.type);\n        let child = node;\n        node = node.parent;\n        if (!node) {\n          throwError(i);\n        }\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n      case \",\":\n        delete node.state;\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n          node.indexed = true;\n          node.name = \"\";\n        }\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n        node.type = verifyType(node.type);\n        let sibling = newNode(node.parent);\n        //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        }\n        // If reading name, the name is done\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n              if (node.indexed) {\n                throwError(i);\n              }\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n        break;\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n    }\n  }\n  if (node.parent) {\n    logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n  }\n  delete parent.state;\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n  parent.type = verifyType(parent.type);\n  return parent;\n}\nfunction populate(object, params) {\n  for (let key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\nexport const FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readble with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new ParamType()\"\n      });\n    }\n    populate(this, params);\n    let match = this.type.match(paramTypeArray);\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n    this._isParamType = true;\n    Object.freeze(this);\n  }\n  // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n    if (format === FormatTypes.json) {\n      let result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name: this.name || undefined\n      };\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n      if (this.components) {\n        result.components = this.components.map(comp => JSON.parse(comp.format(format)));\n      }\n      return JSON.stringify(result);\n    }\n    let result = \"\";\n    // Array\n    if (this.baseType === \"array\") {\n      result += this.arrayChildren.format(format);\n      result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n    } else {\n      if (this.baseType === \"tuple\") {\n        if (format !== FormatTypes.sighash) {\n          result += this.type;\n        }\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n    if (format !== FormatTypes.sighash) {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n      if (format === FormatTypes.full && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n    return result;\n  }\n  static from(value, allowIndexed) {\n    if (typeof value === \"string\") {\n      return ParamType.fromString(value, allowIndexed);\n    }\n    return ParamType.fromObject(value);\n  }\n  static fromObject(value) {\n    if (ParamType.isParamType(value)) {\n      return value;\n    }\n    return new ParamType(_constructorGuard, {\n      name: value.name || null,\n      type: verifyType(value.type),\n      indexed: value.indexed == null ? null : !!value.indexed,\n      components: value.components ? value.components.map(ParamType.fromObject) : null\n    });\n  }\n  static fromString(value, allowIndexed) {\n    function ParamTypify(node) {\n      return ParamType.fromObject({\n        name: node.name,\n        type: node.type,\n        indexed: node.indexed,\n        components: node.components\n      });\n    }\n    return ParamTypify(parseParamType(value, !!allowIndexed));\n  }\n  static isParamType(value) {\n    return !!(value != null && value._isParamType);\n  }\n}\n;\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(param => ParamType.fromString(param, allowIndex));\n}\nexport class Fragment {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new Fragment()\"\n      });\n    }\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n  static from(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      return Fragment.fromString(value);\n    }\n    return Fragment.fromObject(value);\n  }\n  static fromObject(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n    switch (value.type) {\n      case \"function\":\n        return FunctionFragment.fromObject(value);\n      case \"event\":\n        return EventFragment.fromObject(value);\n      case \"constructor\":\n        return ConstructorFragment.fromObject(value);\n      case \"fallback\":\n      case \"receive\":\n        // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n        return null;\n    }\n    return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n  }\n  static fromString(value) {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    value = value.replace(/\\s/g, \" \");\n    value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n    value = value.trim();\n    if (value.split(\" \")[0] === \"event\") {\n      return EventFragment.fromString(value.substring(5).trim());\n    } else if (value.split(\" \")[0] === \"function\") {\n      return FunctionFragment.fromString(value.substring(8).trim());\n    } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n      return ConstructorFragment.fromString(value.trim());\n    }\n    return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n  }\n  static isFragment(value) {\n    return !!(value && value._isFragment);\n  }\n}\nexport class EventFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n    let result = \"\";\n    if (format !== FormatTypes.sighash) {\n      result += \"event \";\n    }\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n    if (format !== FormatTypes.sighash) {\n      if (this.anonymous) {\n        result += \"anonymous \";\n      }\n    }\n    return result.trim();\n  }\n  static from(value) {\n    if (typeof value === \"string\") {\n      return EventFragment.fromString(value);\n    }\n    return EventFragment.fromObject(value);\n  }\n  static fromObject(value) {\n    if (EventFragment.isEventFragment(value)) {\n      return value;\n    }\n    if (value.type !== \"event\") {\n      logger.throwArgumentError(\"invalid event object\", \"value\", value);\n    }\n    const params = {\n      name: verifyIdentifier(value.name),\n      anonymous: value.anonymous,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      type: \"event\"\n    };\n    return new EventFragment(_constructorGuard, params);\n  }\n  static fromString(value) {\n    let match = value.match(regexParen);\n    if (!match) {\n      logger.throwArgumentError(\"invalid event string\", \"value\", value);\n    }\n    let anonymous = false;\n    match[3].split(\" \").forEach(modifier => {\n      switch (modifier.trim()) {\n        case \"anonymous\":\n          anonymous = true;\n          break;\n        case \"\":\n          break;\n        default:\n          logger.warn(\"unknown modifier: \" + modifier);\n      }\n    });\n    return EventFragment.fromObject({\n      name: match[1].trim(),\n      anonymous: anonymous,\n      inputs: parseParams(match[2], true),\n      type: \"event\"\n    });\n  }\n  static isEventFragment(value) {\n    return value && value._isFragment && value.type === \"event\";\n  }\n}\nfunction parseGas(value, params) {\n  params.gas = null;\n  let comps = value.split(\"@\");\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n    }\n    if (!comps[1].match(/^[0-9]+$/)) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n    }\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n  return value;\n}\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(modifier => {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n      case \"nonpayable\":\n        params.payable = false;\n        params.stateMutability = \"nonpayable\";\n        break;\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\nfunction verifyState(value) {\n  let result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability;\n    // Set (and check things are consistent) the constant property\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n    // Set (and check things are consistent) the payable property\n    result.payable = result.stateMutability === \"payable\";\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable;\n    // If payable we can assume non-constant; otherwise we can't assume\n    if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n      logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    result.constant = !!value.constant;\n    if (result.constant) {\n      result.stateMutability = \"view\";\n    } else {\n      result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    }\n    if (result.payable && result.constant) {\n      logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  } else if (value.type !== \"constructor\") {\n    logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n  }\n  return result;\n}\nexport class ConstructorFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n    if (format === FormatTypes.sighash) {\n      logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"format(sighash)\"\n      });\n    }\n    let result = \"constructor(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n    if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n      result += this.stateMutability + \" \";\n    }\n    return result.trim();\n  }\n  static from(value) {\n    if (typeof value === \"string\") {\n      return ConstructorFragment.fromString(value);\n    }\n    return ConstructorFragment.fromObject(value);\n  }\n  static fromObject(value) {\n    if (ConstructorFragment.isConstructorFragment(value)) {\n      return value;\n    }\n    if (value.type !== \"constructor\") {\n      logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n    }\n    let state = verifyState(value);\n    if (state.constant) {\n      logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n    }\n    const params = {\n      name: null,\n      type: value.type,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    };\n    return new ConstructorFragment(_constructorGuard, params);\n  }\n  static fromString(value) {\n    let params = {\n      type: \"constructor\"\n    };\n    value = parseGas(value, params);\n    let parens = value.match(regexParen);\n    if (!parens || parens[1].trim() !== \"constructor\") {\n      logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n    }\n    params.inputs = parseParams(parens[2].trim(), false);\n    parseModifiers(parens[3].trim(), params);\n    return ConstructorFragment.fromObject(params);\n  }\n  static isConstructorFragment(value) {\n    return value && value._isFragment && value.type === \"constructor\";\n  }\n}\nexport class FunctionFragment extends ConstructorFragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format))),\n        ouputs: this.outputs.map(output => JSON.parse(output.format(format)))\n      });\n    }\n    let result = \"\";\n    if (format !== FormatTypes.sighash) {\n      result += \"function \";\n    }\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n    if (format !== FormatTypes.sighash) {\n      if (this.stateMutability) {\n        if (this.stateMutability !== \"nonpayable\") {\n          result += this.stateMutability + \" \";\n        }\n      } else if (this.constant) {\n        result += \"view \";\n      }\n      if (this.outputs && this.outputs.length) {\n        result += \"returns (\" + this.outputs.map(output => output.format(format)).join(\", \") + \") \";\n      }\n      if (this.gas != null) {\n        result += \"@\" + this.gas.toString() + \" \";\n      }\n    }\n    return result.trim();\n  }\n  static from(value) {\n    if (typeof value === \"string\") {\n      return FunctionFragment.fromString(value);\n    }\n    return FunctionFragment.fromObject(value);\n  }\n  static fromObject(value) {\n    if (FunctionFragment.isFunctionFragment(value)) {\n      return value;\n    }\n    if (value.type !== \"function\") {\n      logger.throwArgumentError(\"invalid function object\", \"value\", value);\n    }\n    let state = verifyState(value);\n    const params = {\n      type: value.type,\n      name: verifyIdentifier(value.name),\n      constant: state.constant,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    };\n    return new FunctionFragment(_constructorGuard, params);\n  }\n  static fromString(value) {\n    let params = {\n      type: \"function\"\n    };\n    value = parseGas(value, params);\n    let comps = value.split(\" returns \");\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid function string\", \"value\", value);\n    }\n    let parens = comps[0].match(regexParen);\n    if (!parens) {\n      logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n    }\n    params.name = parens[1].trim();\n    if (params.name) {\n      verifyIdentifier(params.name);\n    }\n    params.inputs = parseParams(parens[2], false);\n    parseModifiers(parens[3].trim(), params);\n    // We have outputs\n    if (comps.length > 1) {\n      let returns = comps[1].match(regexParen);\n      if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n        logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n      }\n      params.outputs = parseParams(returns[2], false);\n    } else {\n      params.outputs = [];\n    }\n    return FunctionFragment.fromObject(params);\n  }\n  static isFunctionFragment(value) {\n    return value && value._isFragment && value.type === \"function\";\n  }\n}\n//export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  }\n  // @TODO: more verification\n  return type;\n}\nconst regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n  }\n  return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n  value = value.trim();\n  let result = [];\n  let accum = \"\";\n  let depth = 0;\n  for (let offset = 0; offset < value.length; offset++) {\n    let c = value[offset];\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n        if (depth === -1) {\n          logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n        }\n      }\n    }\n  }\n  if (accum) {\n    result.push(accum);\n  }\n  return result;\n}","map":{"version":3,"mappings":"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","names":["BigNumber","defineReadOnly","Logger","version","logger","_constructorGuard","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","type","name","indexOf","throwArgumentError","parseParamType","param","allowIndexed","originalParam","throwError","i","replace","newNode","parent","node","state","allowType","indexed","length","c","allowParams","verifyType","components","child","allowName","allowArray","sibling","push","readArray","populate","object","params","key","FormatTypes","Object","freeze","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","constructor","constructorGuard","errors","UNSUPPORTED_OPERATION","operation","match","arrayLength","parseInt","arrayChildren","fromObject","baseType","_isParamType","format","result","undefined","map","comp","JSON","parse","stringify","String","join","from","value","fromString","isParamType","ParamTypify","parseParams","allowIndex","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","trim","split","substring","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","log","verifyState","payble","toNumber","isConstructorFragment","parens","ouputs","outputs","output","toString","isFunctionFragment","returns","regexIdentifier","accum","depth","offset"],"sourceRoot":"","sources":["../src.ts/fragments.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}