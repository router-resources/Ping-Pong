{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\n * Returns the ECDSA signature of a message hash.\n */\nexports.ecsign = function (msgHash, privateKey, chainId) {\n  var sig = secp256k1.sign(msgHash, privateKey);\n  var recovery = sig.recovery;\n  var ret = {\n    r: sig.signature.slice(0, 32),\n    s: sig.signature.slice(32, 64),\n    v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27\n  };\n  return ret;\n};\n/**\n * ECDSA public key recovery from signature.\n * @returns Recovered public key\n */\nexports.ecrecover = function (msgHash, v, r, s, chainId) {\n  var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);\n  var recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * @returns Signature\n */\nexports.toRpcSig = function (v, r, s, chainId) {\n  var recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n  return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n */\nexports.fromRpcSig = function (sig) {\n  var buf = bytes_1.toBuffer(sig);\n  // NOTE: with potential introduction of chainId this might need to be updated\n  if (buf.length !== 65) {\n    throw new Error('Invalid signature length');\n  }\n  var v = buf[64];\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v += 27;\n  }\n  return {\n    v: v,\n    r: buf.slice(0, 32),\n    s: buf.slice(32, 64)\n  };\n};\n/**\n * Validate a ECDSA signature.\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {\n  if (homesteadOrLater === void 0) {\n    homesteadOrLater = true;\n  }\n  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false;\n  }\n  var rBN = new BN(r);\n  var sBN = new BN(s);\n  if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n    return false;\n  }\n  if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n    return false;\n  }\n  return true;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexports.hashPersonalMessage = function (message) {\n  var prefix = Buffer.from(\"\\u0019Ethereum Signed Message:\\n\" + message.length.toString(), 'utf-8');\n  return hash_1.keccak(Buffer.concat([prefix, message]));\n};\nfunction calculateSigRecovery(v, chainId) {\n  return chainId ? v - (2 * chainId + 35) : v - 27;\n}\nfunction isValidSigRecovery(recovery) {\n  return recovery === 0 || recovery === 1;\n}","map":{"version":3,"mappings":";;;;;;AAAA,IAAMA,SAAS,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AAClD;AACA;AACA;AAQA;;;AAGaC,cAAM,GAAG,UACpBC,OAAe,EACfC,UAAkB,EAClBC,OAAgB;EAEhB,IAAMC,GAAG,GAAGN,SAAS,CAACO,IAAI,CAACJ,OAAO,EAAEC,UAAU,CAAC;EAC/C,IAAMI,QAAQ,GAAWF,GAAG,CAACE,QAAQ;EAErC,IAAMC,GAAG,GAAG;IACVC,CAAC,EAAEJ,GAAG,CAACK,SAAS,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IAC7BC,CAAC,EAAEP,GAAG,CAACK,SAAS,CAACC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;IAC9BE,CAAC,EAAET,OAAO,GAAGG,QAAQ,IAAIH,OAAO,GAAG,CAAC,GAAG,EAAE,CAAC,GAAGG,QAAQ,GAAG;GACzD;EAED,OAAOC,GAAG;AACZ,CAAC;AAED;;;;AAIaP,iBAAS,GAAG,UACvBC,OAAe,EACfW,CAAS,EACTJ,CAAS,EACTG,CAAS,EACTR,OAAgB;EAEhB,IAAMM,SAAS,GAAGI,MAAM,CAACC,MAAM,CAAC,CAACC,iBAAS,CAACP,CAAC,EAAE,EAAE,CAAC,EAAEO,iBAAS,CAACJ,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;EACzE,IAAML,QAAQ,GAAGU,oBAAoB,CAACJ,CAAC,EAAET,OAAO,CAAC;EACjD,IAAI,CAACc,kBAAkB,CAACX,QAAQ,CAAC,EAAE;IACjC,MAAM,IAAIY,KAAK,CAAC,2BAA2B,CAAC;;EAE9C,IAAMC,YAAY,GAAGrB,SAAS,CAACsB,OAAO,CAACnB,OAAO,EAAEQ,SAAS,EAAEH,QAAQ,CAAC;EACpE,OAAOR,SAAS,CAACuB,gBAAgB,CAACF,YAAY,EAAE,KAAK,CAAC,CAACT,KAAK,CAAC,CAAC,CAAC;AACjE,CAAC;AAED;;;;AAIaV,gBAAQ,GAAG,UAASY,CAAS,EAAEJ,CAAS,EAAEG,CAAS,EAAER,OAAgB;EAChF,IAAMG,QAAQ,GAAGU,oBAAoB,CAACJ,CAAC,EAAET,OAAO,CAAC;EACjD,IAAI,CAACc,kBAAkB,CAACX,QAAQ,CAAC,EAAE;IACjC,MAAM,IAAIY,KAAK,CAAC,2BAA2B,CAAC;;EAG9C;EACA,OAAOH,mBAAW,CAACF,MAAM,CAACC,MAAM,CAAC,CAACC,qBAAa,CAACP,CAAC,EAAE,EAAE,CAAC,EAAEO,qBAAa,CAACJ,CAAC,EAAE,EAAE,CAAC,EAAEI,gBAAQ,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9F,CAAC;AAED;;;;AAIaZ,kBAAU,GAAG,UAASI,GAAW;EAC5C,IAAMkB,GAAG,GAAWP,gBAAQ,CAACX,GAAG,CAAC;EAEjC;EACA,IAAIkB,GAAG,CAACC,MAAM,KAAK,EAAE,EAAE;IACrB,MAAM,IAAIL,KAAK,CAAC,0BAA0B,CAAC;;EAG7C,IAAIN,CAAC,GAAGU,GAAG,CAAC,EAAE,CAAC;EACf;EACA,IAAIV,CAAC,GAAG,EAAE,EAAE;IACVA,CAAC,IAAI,EAAE;;EAGT,OAAO;IACLA,CAAC,EAAEA,CAAC;IACJJ,CAAC,EAAEc,GAAG,CAACZ,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IACnBC,CAAC,EAAEW,GAAG,CAACZ,KAAK,CAAC,EAAE,EAAE,EAAE;GACpB;AACH,CAAC;AAED;;;;AAIaV,wBAAgB,GAAG,UAC9BY,CAAS,EACTJ,CAAS,EACTG,CAAS,EACTa,gBAAgC,EAChCrB,OAAgB;EADhB;IAAAqB,uBAAgC;EAAA;EAGhC,IAAMC,iBAAiB,GAAG,IAAIC,EAAE,CAC9B,kEAAkE,EAClE,EAAE,CACH;EACD,IAAMC,WAAW,GAAG,IAAID,EAAE,CAAC,kEAAkE,EAAE,EAAE,CAAC;EAElG,IAAIlB,CAAC,CAACe,MAAM,KAAK,EAAE,IAAIZ,CAAC,CAACY,MAAM,KAAK,EAAE,EAAE;IACtC,OAAO,KAAK;;EAGd,IAAI,CAACN,kBAAkB,CAACD,oBAAoB,CAACJ,CAAC,EAAET,OAAO,CAAC,CAAC,EAAE;IACzD,OAAO,KAAK;;EAGd,IAAMyB,GAAG,GAAO,IAAIF,EAAE,CAAClB,CAAC,CAAC;EACzB,IAAMqB,GAAG,GAAO,IAAIH,EAAE,CAACf,CAAC,CAAC;EAEzB,IAAIiB,GAAG,CAACE,MAAM,EAAE,IAAIF,GAAG,CAACG,EAAE,CAACJ,WAAW,CAAC,IAAIE,GAAG,CAACC,MAAM,EAAE,IAAID,GAAG,CAACE,EAAE,CAACJ,WAAW,CAAC,EAAE;IAC9E,OAAO,KAAK;;EAGd,IAAIH,gBAAgB,IAAIK,GAAG,CAACG,GAAG,CAACP,iBAAiB,CAAC,KAAK,CAAC,EAAE;IACxD,OAAO,KAAK;;EAGd,OAAO,IAAI;AACb,CAAC;AAED;;;;;;AAMazB,2BAAmB,GAAG,UAASiC,OAAe;EACzD,IAAMC,MAAM,GAAGrB,MAAM,CAACsB,IAAI,CACxB,qCAAmCF,OAAO,CAACV,MAAM,CAACa,QAAQ,EAAI,EAC9D,OAAO,CACR;EACD,OAAOC,aAAM,CAACxB,MAAM,CAACC,MAAM,CAAC,CAACoB,MAAM,EAAED,OAAO,CAAC,CAAC,CAAC;AACjD,CAAC;AAED,SAASjB,oBAAoB,CAACJ,CAAS,EAAET,OAAgB;EACvD,OAAOA,OAAO,GAAGS,CAAC,IAAI,CAAC,GAAGT,OAAO,GAAG,EAAE,CAAC,GAAGS,CAAC,GAAG,EAAE;AAClD;AAEA,SAASK,kBAAkB,CAACX,QAAgB;EAC1C,OAAOA,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC;AACzC","names":["secp256k1","require","exports","msgHash","privateKey","chainId","sig","sign","recovery","ret","r","signature","slice","s","v","Buffer","concat","bytes_1","calculateSigRecovery","isValidSigRecovery","Error","senderPubKey","recover","publicKeyConvert","buf","length","homesteadOrLater","SECP256K1_N_DIV_2","BN","SECP256K1_N","rBN","sBN","isZero","gt","cmp","message","prefix","from","toString","hash_1"],"sourceRoot":"","sources":["../src/signature.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}