{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\nvar secp256k1v3 = require('./secp256k1v3-lib/index');\nvar der = require('./secp256k1v3-lib/der');\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\nexports.privateKeyVerify = function (privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\nexports.privateKeyExport = function (privateKey, compressed) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyImport = function (privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n  if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n  throw new Error(\"couldn't import from DER format\");\n};\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyNegate = function (privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyModInverse = function (privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nexports.privateKeyTweakMul = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyCreate = function (privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyConvert = function (publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nexports.publicKeyVerify = function (publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyCombine = function (publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureNormalize = function (signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureExport = function (signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureImport = function (signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureImportLax = function (signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n  var sigObj = der.signatureImportLax(signature);\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n  return secp256k1v3.signatureImport(sigObj);\n};\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\nexports.sign = function (message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n  var signOptions = undefined;\n  if (options) {\n    signOptions = {};\n    if (options.data === null) {\n      // validate option.data length\n      throw new TypeError('options.data should be a Buffer');\n    }\n    if (options.data) {\n      if (options.data.length != 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n      signOptions.data = new Uint8Array(options.data);\n    }\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n    if (options.noncefn) {\n      // convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n        var buffer = Buffer.from('');\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n        return new Uint8Array(buffer);\n      };\n    }\n  }\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nexports.verify = function (message, signature, publicKey) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.recover = function (message, signature, recid, compressed) {\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.ecdh = function (publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  }\n  // ensure valid privateKey length\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};","map":{"version":3,"mappings":"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","names":["secp256k1","require","secp256k1v3","der","exports","privateKey","length","privateKeyVerify","Uint8Array","from","compressed","RangeError","publicKey","privateKeyExport","privateKeyImport","Error","Buffer","privateKeyNegate","privateKeyModInverse","tweak","privateKeyTweakAdd","privateKeyTweakMul","publicKeyCreate","publicKeyConvert","publicKeyVerify","publicKeyTweakAdd","publicKeyTweakMul","publicKeys","keys","forEach","push","publicKeyCombine","signature","signatureNormalize","signatureExport","signatureImport","sigObj","signatureImportLax","message","options","TypeError","signOptions","undefined","data","noncefn","algo","attempt","bufferAlgo","bufferData","buffer","sig","ecdsaSign","recovery","recid","ecdsaVerify","ecdsaRecover","ecdh","ecdhUnsafe"],"sourceRoot":"","sources":["../src/secp256k1v3-adapter.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}