{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\nconst nacl = __importStar(require(\"tweetnacl\"));\nconst naclUtil = __importStar(require(\"tweetnacl-util\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encrypt(_ref) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref;\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        if (typeof data !== 'string') {\n          throw new Error('Message data must be given as a string');\n        }\n        // generate ephemeral keypair\n        const ephemeralKeyPair = nacl.box.keyPair();\n        // assemble encryption parameters - from string to UInt8\n        let pubKeyUInt8Array;\n        try {\n          pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n        const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n        const nonce = nacl.randomBytes(nacl.box.nonceLength);\n        // encrypt\n        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n        // handle encrypted data\n        const output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: naclUtil.encodeBase64(nonce),\n          ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: naclUtil.encodeBase64(encryptedMessage)\n        };\n        // return encrypted msg data\n        return output;\n      }\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encryptSafely(_ref2) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref2;\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n  }\n  // add padding\n  const dataWithPadding = {\n    data,\n    padding: ''\n  };\n  // calculate padding\n  const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n\n  dataWithPadding.padding = '0'.repeat(padLength);\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({\n    publicKey,\n    data: paddedMessage,\n    version\n  });\n}\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decrypt(_ref3) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref3;\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        // string to buffer to UInt8Array\n        const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;\n        // assemble decryption parameters\n        const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n        const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n        const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);\n        // decrypt\n        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);\n        // return decrypted msg data\n        let output;\n        try {\n          output = naclUtil.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n        if (output) {\n          return output;\n        }\n        throw new Error('Decryption failed.');\n      }\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decryptSafely(_ref4) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref4;\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  const dataWithPadding = JSON.parse(decrypt({\n    encryptedData,\n    privateKey\n  }));\n  return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nfunction getEncryptionPublicKey(privateKey) {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex) {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AASA;;;;;;;;;AASA,SAAgBA,OAAO,OAQtB;EAAA,IARuB;IACtBC,SAAS;IACTC,IAAI;IACJC;EAAO,CAKR;EACC,IAAIC,iBAAS,CAACH,SAAS,CAAC,EAAE;IACxB,MAAM,IAAII,KAAK,CAAC,6BAA6B,CAAC;GAC/C,MAAM,IAAID,iBAAS,CAACF,IAAI,CAAC,EAAE;IAC1B,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAID,iBAAS,CAACD,OAAO,CAAC,EAAE;IAC7B,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;;EAG9C,QAAQF,OAAO;IACb,KAAK,0BAA0B;MAAE;QAC/B,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;UAC5B,MAAM,IAAIG,KAAK,CAAC,wCAAwC,CAAC;;QAE3D;QACA,MAAMC,gBAAgB,GAAGC,IAAI,CAACC,GAAG,CAACC,OAAO,EAAE;QAE3C;QACA,IAAIC,gBAAgB;QACpB,IAAI;UACFA,gBAAgB,GAAGC,QAAQ,CAACC,YAAY,CAACX,SAAS,CAAC;SACpD,CAAC,OAAOY,GAAG,EAAE;UACZ,MAAM,IAAIR,KAAK,CAAC,gBAAgB,CAAC;;QAGnC,MAAMS,mBAAmB,GAAGH,QAAQ,CAACI,UAAU,CAACb,IAAI,CAAC;QACrD,MAAMc,KAAK,GAAGT,IAAI,CAACU,WAAW,CAACV,IAAI,CAACC,GAAG,CAACU,WAAW,CAAC;QAEpD;QACA,MAAMC,gBAAgB,GAAGZ,IAAI,CAACC,GAAG,CAC/BM,mBAAmB,EACnBE,KAAK,EACLN,gBAAgB,EAChBJ,gBAAgB,CAACc,SAAS,CAC3B;QAED;QACA,MAAMC,MAAM,GAAG;UACblB,OAAO,EAAE,0BAA0B;UACnCa,KAAK,EAAEL,QAAQ,CAACW,YAAY,CAACN,KAAK,CAAC;UACnCO,cAAc,EAAEZ,QAAQ,CAACW,YAAY,CAAChB,gBAAgB,CAACL,SAAS,CAAC;UACjEuB,UAAU,EAAEb,QAAQ,CAACW,YAAY,CAACH,gBAAgB;SACnD;QACD;QACA,OAAOE,MAAM;;IAGf;MACE,MAAM,IAAIhB,KAAK,CAAC,uCAAuC,CAAC;EAAC;AAE/D;AA1DAoB;AA4DA;;;;;;;;;;;;AAYA,SAAgBC,aAAa,QAQ5B;EAAA,IAR6B;IAC5BzB,SAAS;IACTC,IAAI;IACJC;EAAO,CAKR;EACC,IAAIC,iBAAS,CAACH,SAAS,CAAC,EAAE;IACxB,MAAM,IAAII,KAAK,CAAC,6BAA6B,CAAC;GAC/C,MAAM,IAAID,iBAAS,CAACF,IAAI,CAAC,EAAE;IAC1B,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAID,iBAAS,CAACD,OAAO,CAAC,EAAE;IAC7B,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;;EAG9C,MAAMsB,sBAAsB,GAAG,CAAC,IAAI,EAAE;EACtC,MAAMC,gBAAgB,GAAG,EAAE;EAE3B,IAAI,OAAO1B,IAAI,KAAK,QAAQ,IAAI,QAAQ,IAAIA,IAAI,EAAE;IAChD;IACA;IACA,MAAM,IAAIG,KAAK,CACb,qEAAqE,CACtE;;EAGH;EACA,MAAMwB,eAAe,GAAG;IACtB3B,IAAI;IACJ4B,OAAO,EAAE;GACV;EAED;EACA,MAAMC,UAAU,GAAGC,MAAM,CAACC,UAAU,CAClCC,IAAI,CAACC,SAAS,CAACN,eAAe,CAAC,EAC/B,OAAO,CACR;EACD,MAAMO,MAAM,GAAGL,UAAU,GAAGJ,sBAAsB;EAClD,IAAIU,SAAS,GAAG,CAAC;EACjB;EACA,IAAID,MAAM,GAAG,CAAC,EAAE;IACdC,SAAS,GAAGV,sBAAsB,GAAGS,MAAM,GAAGR,gBAAgB,CAAC,CAAC;;;EAElEC,eAAe,CAACC,OAAO,GAAG,GAAG,CAACQ,MAAM,CAACD,SAAS,CAAC;EAE/C,MAAME,aAAa,GAAGL,IAAI,CAACC,SAAS,CAACN,eAAe,CAAC;EACrD,OAAO7B,OAAO,CAAC;IAAEC,SAAS;IAAEC,IAAI,EAAEqC,aAAa;IAAEpC;EAAO,CAAE,CAAC;AAC7D;AAjDAsB;AAmDA;;;;;;;;AAQA,SAAgBe,OAAO,QAMtB;EAAA,IANuB;IACtBC,aAAa;IACbC;EAAU,CAIX;EACC,IAAItC,iBAAS,CAACqC,aAAa,CAAC,EAAE;IAC5B,MAAM,IAAIpC,KAAK,CAAC,iCAAiC,CAAC;GACnD,MAAM,IAAID,iBAAS,CAACsC,UAAU,CAAC,EAAE;IAChC,MAAM,IAAIrC,KAAK,CAAC,8BAA8B,CAAC;;EAGjD,QAAQoC,aAAa,CAACtC,OAAO;IAC3B,KAAK,0BAA0B;MAAE;QAC/B;QACA,MAAMwC,4BAA4B,GAAGC,cAAc,CAACF,UAAU,CAAC;QAC/D,MAAMG,4BAA4B,GAAGtC,IAAI,CAACC,GAAG,CAACC,OAAO,CAACqC,aAAa,CACjEH,4BAA4B,CAC7B,CAACvB,SAAS;QAEX;QACA,MAAMJ,KAAK,GAAGL,QAAQ,CAACC,YAAY,CAAC6B,aAAa,CAACzB,KAAK,CAAC;QACxD,MAAMQ,UAAU,GAAGb,QAAQ,CAACC,YAAY,CAAC6B,aAAa,CAACjB,UAAU,CAAC;QAClE,MAAMD,cAAc,GAAGZ,QAAQ,CAACC,YAAY,CAC1C6B,aAAa,CAAClB,cAAc,CAC7B;QAED;QACA,MAAMwB,gBAAgB,GAAGxC,IAAI,CAACC,GAAG,CAACwC,IAAI,CACpCxB,UAAU,EACVR,KAAK,EACLO,cAAc,EACdsB,4BAA4B,CAC7B;QAED;QACA,IAAIxB,MAAM;QACV,IAAI;UACFA,MAAM,GAAGV,QAAQ,CAACsC,UAAU,CAACF,gBAAgB,CAAC;SAC/C,CAAC,OAAOlC,GAAG,EAAE;UACZ,MAAM,IAAIR,KAAK,CAAC,oBAAoB,CAAC;;QAGvC,IAAIgB,MAAM,EAAE;UACV,OAAOA,MAAM;;QAEf,MAAM,IAAIhB,KAAK,CAAC,oBAAoB,CAAC;;IAGvC;MACE,MAAM,IAAIA,KAAK,CAAC,wCAAwC,CAAC;EAAC;AAEhE;AArDAoB;AAuDA;;;;;;;;AAQA,SAAgByB,aAAa,QAM5B;EAAA,IAN6B;IAC5BT,aAAa;IACbC;EAAU,CAIX;EACC,IAAItC,iBAAS,CAACqC,aAAa,CAAC,EAAE;IAC5B,MAAM,IAAIpC,KAAK,CAAC,iCAAiC,CAAC;GACnD,MAAM,IAAID,iBAAS,CAACsC,UAAU,CAAC,EAAE;IAChC,MAAM,IAAIrC,KAAK,CAAC,8BAA8B,CAAC;;EAGjD,MAAMwB,eAAe,GAAGK,IAAI,CAACiB,KAAK,CAACX,OAAO,CAAC;IAAEC,aAAa;IAAEC;EAAU,CAAE,CAAC,CAAC;EAC1E,OAAOb,eAAe,CAAC3B,IAAI;AAC7B;AAfAuB;AAiBA;;;;;;AAMA,SAAgB2B,sBAAsB,CAACV,UAAkB;EACvD,MAAMW,oBAAoB,GAAGT,cAAc,CAACF,UAAU,CAAC;EACvD,MAAMY,mBAAmB,GACvB/C,IAAI,CAACC,GAAG,CAACC,OAAO,CAACqC,aAAa,CAACO,oBAAoB,CAAC,CAACpD,SAAS;EAChE,OAAOU,QAAQ,CAACW,YAAY,CAACgC,mBAAmB,CAAC;AACnD;AALA7B;AAOA;;;;;;AAMA,SAASmB,cAAc,CAACW,MAAc;EACpC,MAAMC,SAAS,GAAGxB,MAAM,CAACyB,IAAI,CAACF,MAAM,EAAE,KAAK,CAAC,CAACG,QAAQ,CAAC,QAAQ,CAAC;EAC/D,OAAO/C,QAAQ,CAACC,YAAY,CAAC4C,SAAS,CAAC;AACzC","names":["encrypt","publicKey","data","version","utils_1","Error","ephemeralKeyPair","nacl","box","keyPair","pubKeyUInt8Array","naclUtil","decodeBase64","err","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","output","encodeBase64","ephemPublicKey","ciphertext","exports","encryptSafely","DEFAULT_PADDING_LENGTH","NACL_EXTRA_BYTES","dataWithPadding","padding","dataLength","Buffer","byteLength","JSON","stringify","modVal","padLength","repeat","paddedMessage","decrypt","encryptedData","privateKey","recieverPrivateKeyUint8Array","nacl_decodeHex","recieverEncryptionPrivateKey","fromSecretKey","decryptedMessage","open","encodeUTF8","decryptSafely","parse","getEncryptionPublicKey","privateKeyUint8Array","encryptionPublicKey","msgHex","msgBase64","from","toString"],"sourceRoot":"","sources":["../src/encryption.ts"],"sourcesContent":["import * as nacl from 'tweetnacl';\nimport * as naclUtil from 'tweetnacl-util';\n\nimport { isNullish } from './utils';\n\nexport interface EthEncryptedData {\n  version: string;\n  nonce: string;\n  ephemPublicKey: string;\n  ciphertext: string;\n}\n\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encrypt({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      if (typeof data !== 'string') {\n        throw new Error('Message data must be given as a string');\n      }\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair();\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array;\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n      } catch (err) {\n        throw new Error('Bad public key');\n      }\n\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n      const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey,\n      );\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage),\n      };\n      // return encrypted msg data\n      return output;\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encryptSafely({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error(\n      'Cannot encrypt with toJSON property.  Please remove toJSON property',\n    );\n  }\n\n  // add padding\n  const dataWithPadding = {\n    data,\n    padding: '',\n  };\n\n  // calculate padding\n  const dataLength = Buffer.byteLength(\n    JSON.stringify(dataWithPadding),\n    'utf-8',\n  );\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n  dataWithPadding.padding = '0'.repeat(padLength);\n\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({ publicKey, data: paddedMessage, version });\n}\n\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decrypt({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // string to buffer to UInt8Array\n      const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n      const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(\n        recieverPrivateKeyUint8Array,\n      ).secretKey;\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey,\n      );\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey,\n      );\n\n      // return decrypted msg data\n      let output;\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage);\n      } catch (err) {\n        throw new Error('Decryption failed.');\n      }\n\n      if (output) {\n        return output;\n      }\n      throw new Error('Decryption failed.');\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decryptSafely({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n  return dataWithPadding.data;\n}\n\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nexport function getEncryptionPublicKey(privateKey: string): string {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey =\n    nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex: string): Uint8Array {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}\n"]},"metadata":{},"sourceType":"script"}