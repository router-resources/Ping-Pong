{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAsyncMiddleware = void 0;\n/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback = null;\n    let nextWasCalled = false;\n    // This will be called by the consumer's async middleware.\n    const asyncNext = async () => {\n      nextWasCalled = true;\n      // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n      // eslint-disable-next-line node/callback-return\n      next(runReturnHandlersCallback => {\n        // This callback comes from JsonRpcEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\nexports.createAsyncMiddleware = createAsyncMiddleware;","map":{"version":3,"mappings":";;;;;;AAgBA;;;;;;;;;;;;;;;;;AAiBA,SAAgBA,qBAAqB,CACnCC,eAA6C;EAE7C,OAAO,OAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEC,GAAG,KAAI;IACnC;IACA;IACA;IACA,IAAIC,kBAA8B;IAClC,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAEC,OAAO,IAAI;MAC1CH,kBAAkB,GAAGG,OAAO;IAC9B,CAAC,CAAC;IAEF,IAAIC,qBAAqB,GAAY,IAAI;IACzC,IAAIC,aAAa,GAAG,KAAK;IAEzB;IACA,MAAMC,SAAS,GAAG,YAAW;MAC3BD,aAAa,GAAG,IAAI;MAEpB;MACA;MACA;MACAP,IAAI,CAAES,yBAAyB,IAAI;QACjC;QACAH,qBAAqB,GAAGG,yBAAyB;QACjDP,kBAAkB,EAAE;MACtB,CAAC,CAAC;MACF,MAAMC,WAAW;IACnB,CAAC;IAED,IAAI;MACF,MAAMN,eAAe,CAACC,GAAG,EAAEC,GAAG,EAAES,SAAS,CAAC;MAE1C,IAAID,aAAa,EAAE;QACjB,MAAMJ,WAAW,CAAC,CAAC;QAClBG,qBAA+C,CAAC,IAAI,CAAC;OACvD,MAAM;QACLL,GAAG,CAAC,IAAI,CAAC;;KAEZ,CAAC,OAAOS,KAAK,EAAE;MACd,IAAIJ,qBAAqB,EAAE;QACxBA,qBAA+C,CAACI,KAAK,CAAC;OACxD,MAAM;QACLT,GAAG,CAACS,KAAK,CAAC;;;EAGhB,CAAC;AACH;AA/CAC","names":["createAsyncMiddleware","asyncMiddleware","req","res","next","end","resolveNextPromise","nextPromise","Promise","resolve","returnHandlerCallback","nextWasCalled","asyncNext","runReturnHandlersCallback","error","exports"],"sourceRoot":"","sources":["../src/createAsyncMiddleware.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}