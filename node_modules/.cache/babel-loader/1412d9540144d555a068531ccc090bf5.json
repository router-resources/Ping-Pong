{"ast":null,"code":"const cacheUtils = require('./cache-utils.js');\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware');\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e'];\nmodule.exports = createBlockCacheMiddleware;\nfunction createBlockCacheMiddleware() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // validate options\n  const {\n    blockTracker\n  } = opts;\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified');\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy();\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache\n  };\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next();\n    }\n    // check type and matching strategy\n    const type = cacheUtils.cacheTypeForPayload(req);\n    const strategy = strategies[type];\n    // If there's no strategy in place, pass it down the chain.\n    if (!strategy) {\n      return next();\n    }\n    // If the strategy can't cache this request, ignore it.\n    if (!strategy.canCacheRequest(req)) {\n      return next();\n    }\n\n    // get block reference (number or keyword)\n    let blockTag = cacheUtils.blockTagForPayload(req);\n    if (!blockTag) blockTag = 'latest';\n\n    // get exact block number\n    let requestedBlockNumber;\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00';\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock();\n      // clear all cache before latest block\n      blockCache.clearBefore(latestBlockNumber);\n      requestedBlockNumber = latestBlockNumber;\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag;\n    }\n\n    // end on a hit, continue on a miss\n    const cacheResult = await strategy.get(req, requestedBlockNumber);\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next();\n      // add result to cache\n      await strategy.set(req, requestedBlockNumber, res.result);\n    } else {\n      // fill in result from cache\n      res.result = cacheResult;\n    }\n  });\n}\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  constructor() {\n    this.cache = {};\n  }\n  getBlockCacheForPayload(payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16);\n    let blockCache = this.cache[blockNumber];\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {};\n      this.cache[blockNumber] = newCache;\n      blockCache = newCache;\n    }\n    return blockCache;\n  }\n  async get(payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    if (!blockCache) return;\n    // lookup payload in block cache\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n    const cached = blockCache[identifier];\n    // may be undefined\n    return cached;\n  }\n  async set(payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result);\n    if (!canCache) return;\n    // set the value in the cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n    blockCache[identifier] = result;\n  }\n  canCacheRequest(payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false;\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload);\n    if (blockTag === 'pending') {\n      return false;\n    }\n    // can be cached\n    return true;\n  }\n  canCacheResult(payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return;\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false;\n      }\n    }\n    // otherwise true\n    return true;\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore(oldBlockHex) {\n    const self = this;\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16);\n    // clear old caches\n    Object.keys(self.cache).map(Number).filter(num => num < oldBlockNumber).forEach(num => delete self.cache[num]);\n  }\n}","map":{"version":3,"names":["cacheUtils","require","createAsyncMiddleware","emptyValues","undefined","module","exports","createBlockCacheMiddleware","opts","blockTracker","Error","blockCache","BlockCacheStrategy","strategies","perma","block","fork","req","res","next","skipCache","type","cacheTypeForPayload","strategy","canCacheRequest","blockTag","blockTagForPayload","requestedBlockNumber","latestBlockNumber","getLatestBlock","clearBefore","cacheResult","get","set","result","constructor","cache","getBlockCacheForPayload","payload","blockNumberHex","blockNumber","Number","parseInt","newCache","identifier","cacheIdentifierForPayload","cached","canCache","canCacheResult","includes","method","blockHash","oldBlockHex","self","oldBlockNumber","Object","keys","map","filter","num","forEach"],"sources":["/Users/shivamsoni/Desktop/router/pingspong/Ping-Pong/node_modules/eth-json-rpc-middleware/block-cache.js"],"sourcesContent":["const cacheUtils = require('./cache-utils.js')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e']\n\nmodule.exports = createBlockCacheMiddleware\n\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const { blockTracker } = opts\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy()\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache,\n  }\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next()\n    }\n    // check type and matching strategy\n    const type = cacheUtils.cacheTypeForPayload(req)\n    const strategy = strategies[type]\n    // If there's no strategy in place, pass it down the chain.\n    if (!strategy) {\n      return next()\n    }\n    // If the strategy can't cache this request, ignore it.\n    if (!strategy.canCacheRequest(req)) {\n      return next()\n    }\n\n    // get block reference (number or keyword)\n    let blockTag = cacheUtils.blockTagForPayload(req)\n    if (!blockTag) blockTag = 'latest'\n\n    // get exact block number\n    let requestedBlockNumber\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00'\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock()\n      // clear all cache before latest block\n      blockCache.clearBefore(latestBlockNumber)\n      requestedBlockNumber = latestBlockNumber\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag\n    }\n\n    // end on a hit, continue on a miss\n    const cacheResult = await strategy.get(req, requestedBlockNumber)\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next()\n      // add result to cache\n      await strategy.set(req, requestedBlockNumber, res.result)\n    } else {\n      // fill in result from cache\n      res.result = cacheResult\n    }\n  })\n}\n\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  \n  constructor () {\n    this.cache = {}\n  }\n\n  getBlockCacheForPayload (payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16)\n    let blockCache = this.cache[blockNumber]\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {}\n      this.cache[blockNumber] = newCache\n      blockCache = newCache\n    }\n    return blockCache\n  }\n\n  async get (payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    if (!blockCache) return\n    // lookup payload in block cache\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    const cached = blockCache[identifier]\n    // may be undefined\n    return cached\n  }\n\n  async set (payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result)\n    if (!canCache) return\n    // set the value in the cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    blockCache[identifier] = result\n  }\n\n  canCacheRequest (payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload)\n    if (blockTag === 'pending') {\n      return false\n    }\n    // can be cached\n    return true\n  }\n\n  canCacheResult (payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false\n      }\n    }\n    // otherwise true\n    return true\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore (oldBlockHex){\n    const self = this\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16)\n    // clear old caches\n    Object.keys(self.cache)\n      .map(Number)\n      .filter(num => num < oldBlockNumber)\n      .forEach(num => delete self.cache[num])\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}