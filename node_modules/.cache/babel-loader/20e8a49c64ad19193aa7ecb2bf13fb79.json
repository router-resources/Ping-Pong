{"ast":null,"code":"/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\n\nmodule.exports = function createAsyncMiddleware(asyncMiddleware) {\n  return (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback, nextWasCalled;\n    const asyncNext = async () => {\n      nextWasCalled = true;\n      next(callback => {\n        // eslint-disable-line callback-return\n        returnHandlerCallback = callback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n    asyncMiddleware(req, res, asyncNext).then(async () => {\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    }).catch(error => {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    });\n  };\n};","map":{"version":3,"names":["module","exports","createAsyncMiddleware","asyncMiddleware","req","res","next","end","resolveNextPromise","nextPromise","Promise","resolve","returnHandlerCallback","nextWasCalled","asyncNext","callback","then","catch","error"],"sources":["/Users/shivamsoni/Desktop/router/pingspong/Ping-Pong/node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createAsyncMiddleware.js"],"sourcesContent":["/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\n\nmodule.exports = function createAsyncMiddleware (asyncMiddleware) {\n  return (req, res, next, end) => {\n\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise\n    const nextPromise = new Promise((resolve) => {\n      resolveNextPromise = resolve\n    })\n\n    let returnHandlerCallback, nextWasCalled\n\n    const asyncNext = async () => {\n\n      nextWasCalled = true\n\n      next((callback) => { // eslint-disable-line callback-return\n        returnHandlerCallback = callback\n        resolveNextPromise()\n      })\n      await nextPromise\n    }\n\n    asyncMiddleware(req, res, asyncNext)\n      .then(async () => {\n        if (nextWasCalled) {\n          await nextPromise // we must wait until the return handler is called\n          returnHandlerCallback(null)\n        } else {\n          end(null)\n        }\n      })\n      .catch((error) => {\n        if (returnHandlerCallback) {\n          returnHandlerCallback(error)\n        } else {\n          end(error)\n        }\n      })\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAO,GAAG,SAASC,qBAAqB,CAAEC,eAAe,EAAE;EAChE,OAAO,CAACC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEC,GAAG,KAAK;IAE9B;IACA;IACA;IACA,IAAIC,kBAAkB;IACtB,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAEC,OAAO,IAAK;MAC3CH,kBAAkB,GAAGG,OAAO;IAC9B,CAAC,CAAC;IAEF,IAAIC,qBAAqB,EAAEC,aAAa;IAExC,MAAMC,SAAS,GAAG,YAAY;MAE5BD,aAAa,GAAG,IAAI;MAEpBP,IAAI,CAAES,QAAQ,IAAK;QAAE;QACnBH,qBAAqB,GAAGG,QAAQ;QAChCP,kBAAkB,EAAE;MACtB,CAAC,CAAC;MACF,MAAMC,WAAW;IACnB,CAAC;IAEDN,eAAe,CAACC,GAAG,EAAEC,GAAG,EAAES,SAAS,CAAC,CACjCE,IAAI,CAAC,YAAY;MAChB,IAAIH,aAAa,EAAE;QACjB,MAAMJ,WAAW,EAAC;QAClBG,qBAAqB,CAAC,IAAI,CAAC;MAC7B,CAAC,MAAM;QACLL,GAAG,CAAC,IAAI,CAAC;MACX;IACF,CAAC,CAAC,CACDU,KAAK,CAAEC,KAAK,IAAK;MAChB,IAAIN,qBAAqB,EAAE;QACzBA,qBAAqB,CAACM,KAAK,CAAC;MAC9B,CAAC,MAAM;QACLX,GAAG,CAACW,KAAK,CAAC;MACZ;IACF,CAAC,CAAC;EACN,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script"}