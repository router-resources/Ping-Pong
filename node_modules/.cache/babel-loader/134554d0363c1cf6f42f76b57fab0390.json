{"ast":null,"code":"const EthQuery = require('eth-query');\nconst pify = require('pify');\nconst BaseFilterWithHistory = require('./base-filter-history');\nconst {\n  bnToHex,\n  hexToInt,\n  incrementHexInt,\n  minBlockRef,\n  blockRefIsNumber\n} = require('./hexUtils');\nclass LogFilter extends BaseFilterWithHistory {\n  constructor(_ref) {\n    let {\n      provider,\n      params\n    } = _ref;\n    super();\n    this.type = 'log';\n    this.ethQuery = new EthQuery(provider);\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: []\n    }, params);\n    // normalize address parameter\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address];\n      }\n      // ensure lowercase\n      this.params.address = this.params.address.map(address => address.toLowerCase());\n    }\n  }\n  async initialize(_ref2) {\n    let {\n      currentBlock\n    } = _ref2;\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock;\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;\n    if ('earliest' === fromBlock) fromBlock = '0x0';\n    this.params.fromBlock = fromBlock;\n    // set toBlock for initial lookup\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock);\n    const params = Object.assign({}, this.params, {\n      toBlock\n    });\n    // fetch logs and add to results\n    const newLogs = await this._fetchLogs(params);\n    this.addInitialResults(newLogs);\n  }\n  async update(_ref3) {\n    let {\n      oldBlock,\n      newBlock\n    } = _ref3;\n    // configure params for this update\n    const toBlock = newBlock;\n    let fromBlock;\n    // oldBlock is empty on first sync\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock);\n    } else {\n      fromBlock = newBlock;\n    }\n    // fetch logs\n    const params = Object.assign({}, this.params, {\n      fromBlock,\n      toBlock\n    });\n    const newLogs = await this._fetchLogs(params);\n    const matchingLogs = newLogs.filter(log => this.matchLog(log));\n\n    // add to results\n    this.addResults(matchingLogs);\n  }\n  async _fetchLogs(params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))();\n    // add to results\n    return newLogs;\n  }\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false;\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false;\n\n    // address is correct:\n    const normalizedLogAddress = log.address && log.address.toLowerCase();\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false;\n\n    // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index];\n      if (!logTopic) return false;\n      logTopic = logTopic.toLowerCase();\n      // normalize subTopics\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];\n      // check for wild card\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);\n      if (subtopicsIncludeWildcard) return true;\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase());\n      // check each possible matching topic\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic);\n      return topicDoesMatch;\n    });\n    return topicsMatch;\n  }\n}\nmodule.exports = LogFilter;","map":{"version":3,"names":["EthQuery","require","pify","BaseFilterWithHistory","bnToHex","hexToInt","incrementHexInt","minBlockRef","blockRefIsNumber","LogFilter","constructor","provider","params","type","ethQuery","Object","assign","fromBlock","toBlock","address","undefined","topics","Array","isArray","map","toLowerCase","initialize","currentBlock","includes","newLogs","_fetchLogs","addInitialResults","update","oldBlock","newBlock","matchingLogs","filter","log","matchLog","addResults","cb","getLogs","blockNumber","normalizedLogAddress","topicsMatch","every","topicPattern","index","logTopic","subtopicsToMatch","subtopicsIncludeWildcard","topic","topicDoesMatch","module","exports"],"sources":["/Users/shivamsoni/Desktop/router/pingspong/Ping-Pong/node_modules/eth-json-rpc-filters/log-filter.js"],"sourcesContent":["const EthQuery = require('eth-query')\nconst pify = require('pify')\nconst BaseFilterWithHistory = require('./base-filter-history')\nconst { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require('./hexUtils')\n\nclass LogFilter extends BaseFilterWithHistory {\n\n  constructor ({ provider, params }) {\n    super()\n    this.type = 'log'\n    this.ethQuery = new EthQuery(provider)\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: [],\n    }, params)\n    // normalize address parameter\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address]\n      }\n      // ensure lowercase\n      this.params.address = this.params.address.map(address => address.toLowerCase())\n    }\n  }\n\n  async initialize({ currentBlock }) {\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock\n    if ('earliest' === fromBlock) fromBlock = '0x0'\n    this.params.fromBlock = fromBlock\n    // set toBlock for initial lookup\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock)\n    const params = Object.assign({}, this.params, { toBlock })\n    // fetch logs and add to results\n    const newLogs = await this._fetchLogs(params)\n    this.addInitialResults(newLogs)\n  }\n\n  async update ({ oldBlock, newBlock }) {\n    // configure params for this update\n    const toBlock = newBlock\n    let fromBlock\n    // oldBlock is empty on first sync\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock)\n    } else {\n      fromBlock = newBlock\n    }\n    // fetch logs\n    const params = Object.assign({}, this.params, { fromBlock, toBlock })\n    const newLogs = await this._fetchLogs(params)\n    const matchingLogs = newLogs.filter(log => this.matchLog(log))\n\n    // add to results\n    this.addResults(matchingLogs)\n  }\n\n  async _fetchLogs (params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))()\n    // add to results\n    return newLogs\n  }\n\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false\n\n    // address is correct:\n    const normalizedLogAddress = log.address && log.address.toLowerCase()\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false\n\n    // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index]\n      if (!logTopic) return false\n      logTopic = logTopic.toLowerCase()\n      // normalize subTopics\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]\n      // check for wild card\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null)\n      if (subtopicsIncludeWildcard) return true\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase())\n      // check each possible matching topic\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic)\n      return topicDoesMatch\n    })\n\n    return topicsMatch\n  }\n\n}\n\nmodule.exports = LogFilter\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}