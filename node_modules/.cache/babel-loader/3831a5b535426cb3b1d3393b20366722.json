{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, get, setAPIKey, setEmbedHost } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport JsonStringify from 'json-stable-stringify';\nimport { keccak256, toChecksumAddress } from 'web3-utils';\nimport loglevel from 'loglevel';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nvar log = loglevel.getLogger('torus.js');\nlog.disableAll();\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nvar SomeError = /*#__PURE__*/function (_Error) {\n  _inherits(SomeError, _Error);\n  var _super = _createSuper$1(SomeError);\n  function SomeError(_ref) {\n    var _this;\n    var errors = _ref.errors,\n      responses = _ref.responses,\n      predicate = _ref.predicate;\n    _classCallCheck(this, SomeError);\n    _this = _super.call(this, 'Unable to resolve enough promises.');\n    _this.errors = errors;\n    _this.responses = responses;\n    _this.predicate = predicate;\n    return _this;\n  }\n  return _createClass(SomeError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar Some = function Some(promises, predicate) {\n  return new Promise(function (resolve, reject) {\n    var finishedCount = 0;\n    var sharedState = {\n      resolved: false\n    };\n    var errorArr = new Array(promises.length).fill(undefined);\n    var resultArr = new Array(promises.length).fill(undefined);\n    var predicateError;\n    promises.forEach(function (x, index) {\n      x.then(function (resp) {\n        resultArr[index] = resp;\n        return undefined;\n      }).catch(function (error) {\n        errorArr[index] = error;\n      }).finally(function () {\n        if (sharedState.resolved) return;\n        predicate(resultArr.slice(0), sharedState).then(function (data) {\n          sharedState.resolved = true;\n          resolve(data);\n          return undefined;\n        }).catch(function (error) {\n          // log only the last predicate error\n          predicateError = error;\n        }).finally(function (_) {\n          finishedCount += 1;\n          if (finishedCount === promises.length) {\n            var errors = Object.values(resultArr.reduce(function (acc, z) {\n              var _error$data;\n              var _ref2 = z || {},\n                id = _ref2.id,\n                error = _ref2.error;\n              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith('Error occurred while verifying params')) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n              return acc;\n            }, {}));\n            if (errors.length > 0) {\n              // Format-able errors\n              var msg = errors.length > 1 ? \"\\n\".concat(errors.map(function (it) {\n                return \"\\u2022 \".concat(it);\n              }).join('\\n')) : errors[0];\n              reject(new Error(msg));\n            } else {\n              var _predicateError;\n              reject(new SomeError({\n                errors: errorArr,\n                responses: resultArr,\n                predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n              }));\n            }\n          }\n        });\n      });\n    });\n  });\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar GetOrSetNonceError = /*#__PURE__*/function (_Error) {\n  _inherits(GetOrSetNonceError, _Error);\n  var _super = _createSuper(GetOrSetNonceError);\n  function GetOrSetNonceError() {\n    _classCallCheck(this, GetOrSetNonceError);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(GetOrSetNonceError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar kCombinations = function kCombinations(s, k) {\n  var set = s;\n  if (typeof set === 'number') {\n    set = Array.from({\n      length: set\n    }, function (_, i) {\n      return i;\n    });\n  }\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n  if (k === set.length) {\n    return [set];\n  }\n  if (k === 1) {\n    return set.reduce(function (acc, cur) {\n      return [].concat(_toConsumableArray(acc), [[cur]]);\n    }, []);\n  }\n  var combs = [];\n  var tailCombs = [];\n  for (var i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n    for (var j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i]].concat(_toConsumableArray(tailCombs[j])));\n    }\n  }\n  return combs;\n};\nvar thresholdSame = function thresholdSame(arr, t) {\n  var hashMap = {};\n  for (var i = 0; i < arr.length; i += 1) {\n    var str = JsonStringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n  return undefined;\n};\nvar keyLookup = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(endpoints, verifier, verifierId) {\n    var lookupPromises;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            lookupPromises = endpoints.map(function (x) {\n              return post(x, generateJsonRPCObject('VerifierLookupRequest', {\n                verifier: verifier,\n                verifier_id: verifierId.toString()\n              })).catch(function (err) {\n                return log.error('lookup request failed', err);\n              });\n            });\n            return _context.abrupt(\"return\", Some(lookupPromises, function (lookupResults) {\n              var lookupShares = lookupResults.filter(function (x1) {\n                return x1;\n              });\n              var errorResult = thresholdSame(lookupShares.map(function (x2) {\n                return x2 && x2.error;\n              }), ~~(endpoints.length / 2) + 1);\n              var keyResult = thresholdSame(lookupShares.map(function (x3) {\n                return x3 && x3.result;\n              }), ~~(endpoints.length / 2) + 1);\n              if (keyResult || errorResult) {\n                return Promise.resolve({\n                  keyResult: keyResult,\n                  errorResult: errorResult\n                });\n              }\n              return Promise.reject(new Error(\"invalid results \".concat(JSON.stringify(lookupResults))));\n            }));\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return function keyLookup(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar waitKeyLookup = function waitKeyLookup(endpoints, verifier, verifierId, timeout) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);\n    }, timeout);\n  });\n};\nvar keyAssign = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId, signerHost, nodeNum, initialPoint, data, signedData, acceptedErrorMsgs;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            endpoints = _ref2.endpoints, torusNodePubs = _ref2.torusNodePubs, lastPoint = _ref2.lastPoint, firstPoint = _ref2.firstPoint, verifier = _ref2.verifier, verifierId = _ref2.verifierId, signerHost = _ref2.signerHost;\n            if (lastPoint === undefined) {\n              nodeNum = Math.floor(Math.random() * endpoints.length);\n              initialPoint = nodeNum;\n            } else {\n              nodeNum = lastPoint % endpoints.length;\n            }\n            if (!(nodeNum === firstPoint)) {\n              _context2.next = 4;\n              break;\n            }\n            throw new Error('Looped through all');\n          case 4:\n            if (firstPoint !== undefined) initialPoint = firstPoint;\n            data = generateJsonRPCObject('KeyAssign', {\n              verifier: verifier,\n              verifier_id: verifierId.toString()\n            });\n            _context2.prev = 6;\n            _context2.next = 9;\n            return post(signerHost, data, {\n              headers: {\n                pubKeyX: torusNodePubs[nodeNum].X,\n                pubKeyY: torusNodePubs[nodeNum].Y\n              }\n            }, {\n              useAPIKey: true\n            });\n          case 9:\n            signedData = _context2.sent;\n            return _context2.abrupt(\"return\", post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {\n              headers: {\n                'Content-Type': 'application/json; charset=utf-8'\n              }\n            }));\n          case 13:\n            _context2.prev = 13;\n            _context2.t0 = _context2[\"catch\"](6);\n            log.error(_context2.t0);\n            acceptedErrorMsgs = [\n            // Slow node\n            'Timed out',\n            // Happens when the node is not reachable (dns issue etc)\n            'TypeError: Failed to fetch',\n            // All except iOS and Firefox\n            'TypeError: cancelled',\n            // iOS\n            'TypeError: NetworkError when attempting to fetch resource.' // Firefox\n            ];\n\n            if (!acceptedErrorMsgs.includes(_context2.t0.message)) {\n              _context2.next = 19;\n              break;\n            }\n            return _context2.abrupt(\"return\", keyAssign({\n              endpoints: endpoints,\n              torusNodePubs: torusNodePubs,\n              lastPoint: nodeNum + 1,\n              firstPoint: initialPoint,\n              verifier: verifier,\n              verifierId: verifierId,\n              signerHost: signerHost\n            }));\n          case 19:\n            throw new Error(\"Sorry, the Torus Network that powers Web3Auth is currently very busy.\\n    We will generate your key in time. Pls try again later. \\n\\n    \".concat(_context2.t0.message || ''));\n          case 20:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[6, 13]]);\n  }));\n  return function keyAssign(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n// of Torus nodes to handle malicious node responses\n\nvar Torus = /*#__PURE__*/function () {\n  function Torus() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$enableOneKey = _ref.enableOneKey,\n      enableOneKey = _ref$enableOneKey === void 0 ? false : _ref$enableOneKey,\n      _ref$metadataHost = _ref.metadataHost,\n      metadataHost = _ref$metadataHost === void 0 ? 'https://metadata.tor.us' : _ref$metadataHost,\n      _ref$allowHost = _ref.allowHost,\n      allowHost = _ref$allowHost === void 0 ? 'https://signer.tor.us/api/allow' : _ref$allowHost,\n      _ref$signerHost = _ref.signerHost,\n      signerHost = _ref$signerHost === void 0 ? 'https://signer.tor.us/api/sign' : _ref$signerHost,\n      _ref$serverTimeOffset = _ref.serverTimeOffset,\n      serverTimeOffset = _ref$serverTimeOffset === void 0 ? 0 : _ref$serverTimeOffset;\n    _classCallCheck(this, Torus);\n    this.ec = new ec('secp256k1');\n    this.metadataHost = metadataHost;\n    this.allowHost = allowHost;\n    this.enableOneKey = enableOneKey;\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n\n    this.signerHost = signerHost;\n  }\n  _createClass(Torus, [{\n    key: \"getUserTypeAndAddress\",\n    value:\n    /**\n     * Note: use this function only for openlogin tkey account lookups.\n     */\n    function () {\n      var _getUserTypeAndAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(endpoints, torusNodePubs, _ref2) {\n        var verifier,\n          verifierId,\n          doesKeyAssign,\n          _ref3,\n          keyResult,\n          errorResult,\n          isNewKey,\n          finalKeyResult,\n          assignResult,\n          _finalKeyResult$keys$,\n          X,\n          Y,\n          typeOfUser,\n          nonce,\n          pubNonce,\n          modifiedPubKey,\n          upgraded,\n          _yield$this$getOrSetN,\n          finalX,\n          finalY,\n          address,\n          _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                verifier = _ref2.verifier, verifierId = _ref2.verifierId;\n                doesKeyAssign = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;\n                _context.next = 4;\n                return keyLookup(endpoints, verifier, verifierId);\n              case 4:\n                _context.t0 = _context.sent;\n                if (_context.t0) {\n                  _context.next = 7;\n                  break;\n                }\n                _context.t0 = {};\n              case 7:\n                _ref3 = _context.t0;\n                keyResult = _ref3.keyResult;\n                errorResult = _ref3.errorResult;\n                isNewKey = false;\n                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned'))) {\n                  _context.next = 26;\n                  break;\n                }\n                if (doesKeyAssign) {\n                  _context.next = 14;\n                  break;\n                }\n                throw new Error('Verifier + VerifierID has not yet been assigned');\n              case 14:\n                _context.next = 16;\n                return keyAssign({\n                  endpoints: endpoints,\n                  torusNodePubs: torusNodePubs,\n                  lastPoint: undefined,\n                  firstPoint: undefined,\n                  verifier: verifier,\n                  verifierId: verifierId,\n                  signerHost: this.signerHost\n                });\n              case 16:\n                _context.next = 18;\n                return waitKeyLookup(endpoints, verifier, verifierId, 1000);\n              case 18:\n                _context.t1 = _context.sent;\n                if (_context.t1) {\n                  _context.next = 21;\n                  break;\n                }\n                _context.t1 = {};\n              case 21:\n                assignResult = _context.t1;\n                finalKeyResult = assignResult.keyResult;\n                isNewKey = true;\n                _context.next = 31;\n                break;\n              case 26:\n                if (!keyResult) {\n                  _context.next = 30;\n                  break;\n                }\n                finalKeyResult = keyResult;\n                _context.next = 31;\n                break;\n              case 30:\n                throw new Error(\"node results do not match at first lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n              case 31:\n                if (!finalKeyResult) {\n                  _context.next = 61;\n                  break;\n                }\n                _finalKeyResult$keys$ = finalKeyResult.keys[0], X = _finalKeyResult$keys$.pub_key_X, Y = _finalKeyResult$keys$.pub_key_Y;\n                _context.prev = 33;\n                _context.next = 37;\n                return this.getOrSetNonce(X, Y, undefined, !isNewKey);\n              case 37:\n                _yield$this$getOrSetN = _context.sent;\n                typeOfUser = _yield$this$getOrSetN.typeOfUser;\n                nonce = _yield$this$getOrSetN.nonce;\n                pubNonce = _yield$this$getOrSetN.pubNonce;\n                upgraded = _yield$this$getOrSetN.upgraded;\n                nonce = new BN(nonce || '0', 16);\n                _context.next = 48;\n                break;\n              case 45:\n                _context.prev = 45;\n                _context.t2 = _context[\"catch\"](33);\n                throw new GetOrSetNonceError();\n              case 48:\n                if (!(typeOfUser === 'v1')) {\n                  _context.next = 52;\n                  break;\n                }\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n                _context.next = 57;\n                break;\n              case 52:\n                if (!(typeOfUser === 'v2')) {\n                  _context.next = 56;\n                  break;\n                }\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPublic({\n                  x: pubNonce.x,\n                  y: pubNonce.y\n                }).getPublic());\n                _context.next = 57;\n                break;\n              case 56:\n                throw new Error('getOrSetNonce should always return typeOfUser.');\n              case 57:\n                finalX = modifiedPubKey.getX().toString(16);\n                finalY = modifiedPubKey.getY().toString(16);\n                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n                return _context.abrupt(\"return\", {\n                  typeOfUser: typeOfUser,\n                  nonce: nonce,\n                  pubNonce: pubNonce,\n                  upgraded: upgraded,\n                  X: finalX,\n                  Y: finalY,\n                  address: address\n                });\n              case 61:\n                throw new Error(\"node results do not match at final lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n              case 62:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[33, 45]]);\n      }));\n      function getUserTypeAndAddress(_x, _x2, _x3) {\n        return _getUserTypeAndAddress.apply(this, arguments);\n      }\n      return getUserTypeAndAddress;\n    }()\n  }, {\n    key: \"setCustomKey\",\n    value: function () {\n      var _setCustomKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref4) {\n        var privKeyHex, metadataNonce, torusKeyHex, customKeyHex, torusKey, privKey, customKey, newMetadataNonce, data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                privKeyHex = _ref4.privKeyHex, metadataNonce = _ref4.metadataNonce, torusKeyHex = _ref4.torusKeyHex, customKeyHex = _ref4.customKeyHex;\n                if (torusKeyHex) {\n                  torusKey = new BN(torusKeyHex, 16);\n                } else {\n                  privKey = new BN(privKeyHex, 16);\n                  torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);\n                }\n                customKey = new BN(customKeyHex, 16);\n                newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);\n                data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey.toString(16));\n                _context2.next = 7;\n                return this.setMetadata(data);\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function setCustomKey(_x4) {\n        return _setCustomKey.apply(this, arguments);\n      }\n      return setCustomKey;\n    }()\n  }, {\n    key: \"retrieveShares\",\n    value: function () {\n      var _retrieveShares = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(endpoints, indexes, verifier, verifierParams, idToken) {\n        var _this = this;\n        var extraParams,\n          promiseArr,\n          tmpKey,\n          pubKey,\n          pubKeyX,\n          pubKeyY,\n          tokenCommitment,\n          i,\n          p,\n          _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                extraParams = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : {};\n                promiseArr = [];\n                _context5.next = 4;\n                return get(this.allowHost, {\n                  headers: {\n                    verifier: verifier,\n                    verifier_id: verifierParams.verifier_id\n                  }\n                }, {\n                  useAPIKey: true\n                });\n              case 4:\n                /*\n                  CommitmentRequestParams struct {\n                    MessagePrefix      string `json:\"messageprefix\"`\n                    TokenCommitment    string `json:\"tokencommitment\"`\n                    TempPubX           string `json:\"temppubx\"`\n                    TempPubY           string `json:\"temppuby\"`\n                    VerifierIdentifier string `json:\"verifieridentifier\"`\n                  } \n                  */\n                // generate temporary private and public key that is used to secure receive shares\n                tmpKey = generatePrivate();\n                pubKey = getPublic(tmpKey).toString('hex');\n                pubKeyX = pubKey.slice(2, 66);\n                pubKeyY = pubKey.slice(66);\n                tokenCommitment = keccak256(idToken); // make commitment requests to endpoints\n\n                for (i = 0; i < endpoints.length; i += 1) {\n                  p = post(endpoints[i], generateJsonRPCObject('CommitmentRequest', {\n                    messageprefix: 'mug00',\n                    tokencommitment: tokenCommitment.slice(2),\n                    temppubx: pubKeyX,\n                    temppuby: pubKeyY,\n                    verifieridentifier: verifier\n                  })).catch(function (err) {\n                    return log.error('commitment', err);\n                  });\n                  promiseArr.push(p);\n                }\n                /*\n                  ShareRequestParams struct {\n                    Item []bijson.RawMessage `json:\"item\"`\n                  }\n                  ShareRequestItem struct {\n                    IDToken            string          `json:\"idtoken\"`\n                    NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n                    VerifierIdentifier string          `json:\"verifieridentifier\"`\n                  }\n                  NodeSignature struct {\n                    Signature   string\n                    Data        string\n                    NodePubKeyX string\n                    NodePubKeyY string\n                  }\n                  CommitmentRequestResult struct {\n                    Signature string `json:\"signature\"`\n                    Data      string `json:\"data\"`\n                    NodePubX  string `json:\"nodepubx\"`\n                    NodePubY  string `json:\"nodepuby\"`\n                  }\n                  */\n                // send share request once k + t number of commitment requests have completed\n\n                return _context5.abrupt(\"return\", Some(promiseArr, function (resultArr) {\n                  var completedRequests = resultArr.filter(function (x) {\n                    if (!x || _typeof(x) !== 'object') {\n                      return false;\n                    }\n                    if (x.error) {\n                      return false;\n                    }\n                    return true;\n                  });\n                  if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n                    return Promise.resolve(resultArr);\n                  }\n                  return Promise.reject(new Error(\"invalid \".concat(JSON.stringify(resultArr))));\n                }).then(function (responses) {\n                  var promiseArrRequest = [];\n                  var nodeSigs = [];\n                  for (var _i = 0; _i < responses.length; _i += 1) {\n                    if (responses[_i]) nodeSigs.push(responses[_i].result);\n                  }\n                  for (var _i2 = 0; _i2 < endpoints.length; _i2 += 1) {\n                    // eslint-disable-next-line promise/no-nesting\n                    var _p = post(endpoints[_i2], generateJsonRPCObject('ShareRequest', {\n                      encrypted: 'yes',\n                      item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n                        idtoken: idToken,\n                        nodesignatures: nodeSigs,\n                        verifieridentifier: verifier\n                      }, extraParams)]\n                    })).catch(function (err) {\n                      return log.error('share req', err);\n                    });\n                    promiseArrRequest.push(_p);\n                  }\n                  return Some(promiseArrRequest, /*#__PURE__*/function () {\n                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(shareResponses, sharedState) {\n                      var completedRequests, thresholdPublicKey, sharePromises, nodeIndex, _i3, metadata, sharesResolved, decryptedShares, allCombis, privateKey, _loop, j, _ret;\n                      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              /*\n                                  ShareRequestResult struct {\n                                    Keys []KeyAssignment\n                                  }\n                                          / KeyAssignmentPublic -\n                                  type KeyAssignmentPublic struct {\n                                    Index     big.Int\n                                    PublicKey common.Point\n                                    Threshold int\n                                    Verifiers map[string][]string // Verifier => VerifierID\n                                  }\n                                   // KeyAssignment -\n                                  type KeyAssignment struct {\n                                    KeyAssignmentPublic\n                                    Share big.Int // Or Si\n                                  }\n                                */\n                              // check if threshold number of nodes have returned the same user public key\n                              completedRequests = shareResponses.filter(function (x) {\n                                return x;\n                              });\n                              thresholdPublicKey = thresholdSame(shareResponses.map(function (x) {\n                                return x && x.result && x.result.keys[0].PublicKey;\n                              }), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received\n                              // this is matched against the user public key to ensure that shares are consistent\n\n                              if (!(completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey)) {\n                                _context3.next = 25;\n                                break;\n                              }\n                              sharePromises = [];\n                              nodeIndex = [];\n                              for (_i3 = 0; _i3 < shareResponses.length; _i3 += 1) {\n                                if (shareResponses[_i3] && shareResponses[_i3].result && shareResponses[_i3].result.keys && shareResponses[_i3].result.keys.length > 0) {\n                                  shareResponses[_i3].result.keys.sort(function (a, b) {\n                                    return new BN(a.Index, 16).cmp(new BN(b.Index, 16));\n                                  });\n                                  if (shareResponses[_i3].result.keys[0].Metadata) {\n                                    metadata = {\n                                      ephemPublicKey: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.ephemPublicKey, 'hex'),\n                                      iv: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.iv, 'hex'),\n                                      mac: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mac, 'hex'),\n                                      mode: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mode, 'hex')\n                                    };\n                                    sharePromises.push(\n                                    // eslint-disable-next-line promise/no-nesting\n                                    decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {\n                                      ciphertext: Buffer.from(atob(shareResponses[_i3].result.keys[0].Share).padStart(64, '0'), 'hex')\n                                    })).catch(function (err) {\n                                      return log.debug('share decryption', err);\n                                    }));\n                                  } else {\n                                    sharePromises.push(Promise.resolve(Buffer.from(shareResponses[_i3].result.keys[0].Share.padStart(64, '0'), 'hex')));\n                                  }\n                                } else {\n                                  sharePromises.push(Promise.resolve(undefined));\n                                }\n                                nodeIndex.push(new BN(indexes[_i3], 16));\n                              }\n                              _context3.next = 8;\n                              return Promise.all(sharePromises);\n                            case 8:\n                              sharesResolved = _context3.sent;\n                              if (!sharedState.resolved) {\n                                _context3.next = 11;\n                                break;\n                              }\n                              return _context3.abrupt(\"return\", undefined);\n                            case 11:\n                              decryptedShares = sharesResolved.reduce(function (acc, curr, index) {\n                                if (curr) acc.push({\n                                  index: nodeIndex[index],\n                                  value: new BN(curr)\n                                });\n                                return acc;\n                              }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n\n                              // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n                              allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);\n                              _loop = function _loop(j) {\n                                var currentCombi = allCombis[j];\n                                var currentCombiShares = decryptedShares.filter(function (v, index) {\n                                  return currentCombi.includes(index);\n                                });\n                                var shares = currentCombiShares.map(function (x) {\n                                  return x.value;\n                                });\n                                var indices = currentCombiShares.map(function (x) {\n                                  return x.index;\n                                });\n                                var derivedPrivateKey = _this.lagrangeInterpolation(shares, indices);\n                                var decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex');\n                                var decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n                                var decryptedPubKeyY = decryptedPubKey.slice(66);\n                                if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n                                  privateKey = derivedPrivateKey;\n                                  return \"break\";\n                                }\n                              };\n                              j = 0;\n                            case 15:\n                              if (!(j < allCombis.length)) {\n                                _context3.next = 22;\n                                break;\n                              }\n                              _ret = _loop(j);\n                              if (!(_ret === \"break\")) {\n                                _context3.next = 19;\n                                break;\n                              }\n                              return _context3.abrupt(\"break\", 22);\n                            case 19:\n                              j += 1;\n                              _context3.next = 15;\n                              break;\n                            case 22:\n                              if (!(privateKey === undefined)) {\n                                _context3.next = 24;\n                                break;\n                              }\n                              throw new Error('could not derive private key');\n                            case 24:\n                              return _context3.abrupt(\"return\", privateKey);\n                            case 25:\n                              throw new Error('invalid');\n                            case 26:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3);\n                    }));\n                    return function (_x10, _x11) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }());\n                }).then( /*#__PURE__*/function () {\n                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(returnedKey) {\n                    var privateKey, decryptedPubKey, decryptedPubKeyX, decryptedPubKeyY, metadataNonce, _yield$_this$getNonce, nonce, ethAddress;\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            privateKey = returnedKey;\n                            decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), 'hex')).toString('hex');\n                            decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n                            decryptedPubKeyY = decryptedPubKey.slice(66);\n                            if (!_this.enableOneKey) {\n                              _context4.next = 12;\n                              break;\n                            }\n                            _context4.next = 7;\n                            return _this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);\n                          case 7:\n                            _yield$_this$getNonce = _context4.sent;\n                            nonce = _yield$_this$getNonce.nonce;\n                            metadataNonce = new BN(nonce || '0', 16);\n                            _context4.next = 15;\n                            break;\n                          case 12:\n                            _context4.next = 14;\n                            return _this.getMetadata({\n                              pub_key_X: decryptedPubKeyX,\n                              pub_key_Y: decryptedPubKeyY\n                            });\n                          case 14:\n                            metadataNonce = _context4.sent;\n                          case 15:\n                            log.debug('> torus.js/retrieveShares', {\n                              privKey: privateKey.toString(16),\n                              metadataNonce: metadataNonce.toString(16)\n                            });\n                            privateKey = privateKey.add(metadataNonce).umod(_this.ec.curve.n);\n                            ethAddress = _this.generateAddressFromPrivKey(privateKey);\n                            log.debug('> torus.js/retrieveShares', {\n                              ethAddress: ethAddress,\n                              privKey: privateKey.toString(16)\n                            }); // return reconstructed private key and ethereum address\n\n                            return _context4.abrupt(\"return\", {\n                              ethAddress: ethAddress,\n                              privKey: privateKey.toString('hex', 64),\n                              metadataNonce: metadataNonce\n                            });\n                          case 20:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n                  return function (_x12) {\n                    return _ref6.apply(this, arguments);\n                  };\n                }()));\n              case 11:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function retrieveShares(_x5, _x6, _x7, _x8, _x9) {\n        return _retrieveShares.apply(this, arguments);\n      }\n      return retrieveShares;\n    }()\n  }, {\n    key: \"getMetadata\",\n    value: function () {\n      var _getMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(data, options) {\n        var metadataResponse;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return post(\"\".concat(this.metadataHost, \"/get\"), data, options, {\n                  useAPIKey: true\n                });\n              case 3:\n                metadataResponse = _context6.sent;\n                if (!(!metadataResponse || !metadataResponse.message)) {\n                  _context6.next = 6;\n                  break;\n                }\n                return _context6.abrupt(\"return\", new BN(0));\n              case 6:\n                return _context6.abrupt(\"return\", new BN(metadataResponse.message, 16));\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](0);\n                log.error('get metadata error', _context6.t0);\n                return _context6.abrupt(\"return\", new BN(0));\n              case 13:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 9]]);\n      }));\n      function getMetadata(_x13, _x14) {\n        return _getMetadata.apply(this, arguments);\n      }\n      return getMetadata;\n    }()\n  }, {\n    key: \"generateMetadataParams\",\n    value: function generateMetadataParams(message, privateKey) {\n      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64));\n      var setData = {\n        data: message,\n        timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)\n      };\n      var sig = key.sign(keccak256(JsonStringify(setData)).slice(2));\n      return {\n        pub_key_X: key.getPublic().getX().toString('hex'),\n        pub_key_Y: key.getPublic().getY().toString('hex'),\n        set_data: setData,\n        signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(sig.v).toString(16, 2), 'hex').toString('base64')\n      };\n    }\n  }, {\n    key: \"setMetadata\",\n    value: function () {\n      var _setMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data, options) {\n        var metadataResponse;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return post(\"\".concat(this.metadataHost, \"/set\"), data, options, {\n                  useAPIKey: true\n                });\n              case 3:\n                metadataResponse = _context7.sent;\n                return _context7.abrupt(\"return\", metadataResponse.message);\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](0);\n                log.error('set metadata error', _context7.t0);\n                return _context7.abrupt(\"return\", '');\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 7]]);\n      }));\n      function setMetadata(_x15, _x16) {\n        return _setMetadata.apply(this, arguments);\n      }\n      return setMetadata;\n    }()\n  }, {\n    key: \"lagrangeInterpolation\",\n    value: function lagrangeInterpolation(shares, nodeIndex) {\n      if (shares.length !== nodeIndex.length) {\n        return null;\n      }\n      var secret = new BN(0);\n      for (var i = 0; i < shares.length; i += 1) {\n        var upper = new BN(1);\n        var lower = new BN(1);\n        for (var j = 0; j < shares.length; j += 1) {\n          if (i !== j) {\n            upper = upper.mul(nodeIndex[j].neg());\n            upper = upper.umod(this.ec.curve.n);\n            var temp = nodeIndex[i].sub(nodeIndex[j]);\n            temp = temp.umod(this.ec.curve.n);\n            lower = lower.mul(temp).umod(this.ec.curve.n);\n          }\n        }\n        var delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);\n        delta = delta.mul(shares[i]).umod(this.ec.curve.n);\n        secret = secret.add(delta);\n      }\n      return secret.umod(this.ec.curve.n);\n    }\n  }, {\n    key: \"generateAddressFromPrivKey\",\n    value: function generateAddressFromPrivKey(privateKey) {\n      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex');\n      var publicKey = key.getPublic().encode('hex').slice(2);\n      var ethAddressLower = \"0x\".concat(keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38));\n      return toChecksumAddress(ethAddressLower);\n    }\n  }, {\n    key: \"generateAddressFromPubKey\",\n    value: function generateAddressFromPubKey(publicKeyX, publicKeyY) {\n      var key = this.ec.keyFromPublic({\n        x: publicKeyX.toString('hex', 64),\n        y: publicKeyY.toString('hex', 64)\n      });\n      var publicKey = key.getPublic().encode('hex').slice(2);\n      var ethAddressLower = \"0x\".concat(keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38));\n      return toChecksumAddress(ethAddressLower);\n    }\n    /**\n     * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n     */\n  }, {\n    key: \"getPublicAddress\",\n    value: function () {\n      var _getPublicAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(endpoints, torusNodePubs, _ref7) {\n        var verifier,\n          verifierId,\n          isExtended,\n          finalKeyResult,\n          isNewKey,\n          _ref8,\n          keyResult,\n          errorResult,\n          assignResult,\n          _nonce,\n          _finalKeyResult$keys$2,\n          X,\n          Y,\n          typeOfUser,\n          nonce,\n          pubNonce,\n          modifiedPubKey,\n          upgraded,\n          _yield$this$getOrSetN2,\n          address,\n          _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                verifier = _ref7.verifier, verifierId = _ref7.verifierId;\n                isExtended = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : false;\n                log.debug('> torus.js/getPublicAddress', {\n                  endpoints: endpoints,\n                  torusNodePubs: torusNodePubs,\n                  verifier: verifier,\n                  verifierId: verifierId,\n                  isExtended: isExtended\n                });\n                isNewKey = false;\n                _context8.next = 6;\n                return keyLookup(endpoints, verifier, verifierId);\n              case 6:\n                _context8.t0 = _context8.sent;\n                if (_context8.t0) {\n                  _context8.next = 9;\n                  break;\n                }\n                _context8.t0 = {};\n              case 9:\n                _ref8 = _context8.t0;\n                keyResult = _ref8.keyResult;\n                errorResult = _ref8.errorResult;\n                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier not supported'))) {\n                  _context8.next = 16;\n                  break;\n                }\n                throw new Error(\"Verifier not supported. Check if you: \\n\\n      1. Are on the right network (Torus testnet/mainnet) \\n\\n      2. Have setup a verifier on dashboard.web3auth.io?\");\n              case 16:\n                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned'))) {\n                  _context8.next = 29;\n                  break;\n                }\n                _context8.next = 19;\n                return keyAssign({\n                  endpoints: endpoints,\n                  torusNodePubs: torusNodePubs,\n                  lastPoint: undefined,\n                  firstPoint: undefined,\n                  verifier: verifier,\n                  verifierId: verifierId,\n                  signerHost: this.signerHost\n                });\n              case 19:\n                _context8.next = 21;\n                return waitKeyLookup(endpoints, verifier, verifierId, 1000);\n              case 21:\n                _context8.t1 = _context8.sent;\n                if (_context8.t1) {\n                  _context8.next = 24;\n                  break;\n                }\n                _context8.t1 = {};\n              case 24:\n                assignResult = _context8.t1;\n                finalKeyResult = assignResult.keyResult;\n                isNewKey = true;\n                _context8.next = 34;\n                break;\n              case 29:\n                if (!keyResult) {\n                  _context8.next = 33;\n                  break;\n                }\n                finalKeyResult = keyResult;\n                _context8.next = 34;\n                break;\n              case 33:\n                throw new Error(\"node results do not match at first lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n              case 34:\n                log.debug('> torus.js/getPublicAddress', {\n                  finalKeyResult: finalKeyResult,\n                  isNewKey: isNewKey\n                });\n                if (!finalKeyResult) {\n                  _context8.next = 76;\n                  break;\n                }\n                _finalKeyResult$keys$2 = finalKeyResult.keys[0], X = _finalKeyResult$keys$2.pub_key_X, Y = _finalKeyResult$keys$2.pub_key_Y;\n                if (!this.enableOneKey) {\n                  _context8.next = 64;\n                  break;\n                }\n                _context8.prev = 38;\n                _context8.next = 42;\n                return this.getOrSetNonce(X, Y, undefined, !isNewKey);\n              case 42:\n                _yield$this$getOrSetN2 = _context8.sent;\n                typeOfUser = _yield$this$getOrSetN2.typeOfUser;\n                nonce = _yield$this$getOrSetN2.nonce;\n                pubNonce = _yield$this$getOrSetN2.pubNonce;\n                upgraded = _yield$this$getOrSetN2.upgraded;\n                nonce = new BN(nonce || '0', 16);\n                _context8.next = 53;\n                break;\n              case 50:\n                _context8.prev = 50;\n                _context8.t2 = _context8[\"catch\"](38);\n                throw new GetOrSetNonceError();\n              case 53:\n                if (!(typeOfUser === 'v1')) {\n                  _context8.next = 57;\n                  break;\n                }\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n                _context8.next = 62;\n                break;\n              case 57:\n                if (!(typeOfUser === 'v2')) {\n                  _context8.next = 61;\n                  break;\n                }\n                if (upgraded) {\n                  // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n                  modifiedPubKey = this.ec.keyFromPublic({\n                    x: X.toString(16),\n                    y: Y.toString(16)\n                  }).getPublic();\n                } else {\n                  modifiedPubKey = this.ec.keyFromPublic({\n                    x: X.toString(16),\n                    y: Y.toString(16)\n                  }).getPublic().add(this.ec.keyFromPublic({\n                    x: pubNonce.x,\n                    y: pubNonce.y\n                  }).getPublic());\n                }\n                _context8.next = 62;\n                break;\n              case 61:\n                throw new Error('getOrSetNonce should always return typeOfUser.');\n              case 62:\n                _context8.next = 69;\n                break;\n              case 64:\n                typeOfUser = 'v1';\n                _context8.next = 67;\n                return this.getMetadata({\n                  pub_key_X: X,\n                  pub_key_Y: Y\n                });\n              case 67:\n                nonce = _context8.sent;\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n              case 69:\n                X = modifiedPubKey.getX().toString(16);\n                Y = modifiedPubKey.getY().toString(16);\n                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n                log.debug('> torus.js/getPublicAddress', {\n                  X: X,\n                  Y: Y,\n                  address: address,\n                  typeOfUser: typeOfUser,\n                  nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),\n                  pubNonce: pubNonce\n                });\n                if (isExtended) {\n                  _context8.next = 75;\n                  break;\n                }\n                return _context8.abrupt(\"return\", address);\n              case 75:\n                return _context8.abrupt(\"return\", {\n                  typeOfUser: typeOfUser,\n                  address: address,\n                  X: X,\n                  Y: Y,\n                  metadataNonce: nonce,\n                  pubNonce: pubNonce\n                });\n              case 76:\n                throw new Error(\"node results do not match at final lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n              case 77:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[38, 50]]);\n      }));\n      function getPublicAddress(_x17, _x18, _x19) {\n        return _getPublicAddress.apply(this, arguments);\n      }\n      return getPublicAddress;\n    }()\n    /**\n     * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n     */\n  }, {\n    key: \"getOrSetNonce\",\n    value: function () {\n      var _getOrSetNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(X, Y, privKey) {\n        var getOnly,\n          data,\n          msg,\n          _args9 = arguments;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                getOnly = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : false;\n                msg = getOnly ? 'getNonce' : 'getOrSetNonce';\n                if (privKey) {\n                  data = this.generateMetadataParams(msg, privKey);\n                } else {\n                  data = {\n                    pub_key_X: X,\n                    pub_key_Y: Y,\n                    set_data: {\n                      data: msg\n                    }\n                  };\n                }\n                return _context9.abrupt(\"return\", post(\"\".concat(this.metadataHost, \"/get_or_set_nonce\"), data, undefined, {\n                  useAPIKey: true\n                }));\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function getOrSetNonce(_x20, _x21, _x22) {\n        return _getOrSetNonce.apply(this, arguments);\n      }\n      return getOrSetNonce;\n    }()\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(X, Y, privKey) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this.getOrSetNonce(X, Y, privKey, true));\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n      function getNonce(_x23, _x24, _x25) {\n        return _getNonce.apply(this, arguments);\n      }\n      return getNonce;\n    }()\n  }, {\n    key: \"getPostboxKeyFrom1OutOf1\",\n    value: function getPostboxKeyFrom1OutOf1(privKey, nonce) {\n      var privKeyBN = new BN(privKey, 16);\n      var nonceBN = new BN(nonce, 16);\n      return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString('hex');\n    }\n  }], [{\n    key: \"enableLogging\",\n    value: function enableLogging() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (v) log.enableAll();else log.disableAll();\n    }\n  }, {\n    key: \"setAPIKey\",\n    value: function setAPIKey$1(apiKey) {\n      setAPIKey(apiKey);\n    }\n  }, {\n    key: \"setEmbedHost\",\n    value: function setEmbedHost$1(embedHost) {\n      setEmbedHost(embedHost);\n    }\n  }, {\n    key: \"isGetOrSetNonceError\",\n    value: function isGetOrSetNonceError(err) {\n      return err instanceof GetOrSetNonceError;\n    }\n  }]);\n  return Torus;\n}();\nexport { Torus as default, keyAssign, keyLookup, waitKeyLookup };","map":{"version":3,"mappings":"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","names":["log","loglevel","getLogger","disableAll","capitalizeFirstLetter","str","charAt","toUpperCase","slice","SomeError","_inherits","errors","responses","predicate","_classCallCheck","_this","Error","Some","promises","Promise","resolve","reject","finishedCount","sharedState","resolved","errorArr","Array","length","fill","undefined","resultArr","predicateError","forEach","x","index","then","resp","catch","error","finally","data","_","Object","values","reduce","acc","z","id","startsWith","msg","map","it","join","message","GetOrSetNonceError","kCombinations","s","k","set","from","i","cur","combs","tailCombs","j","push","thresholdSame","arr","t","hashMap","JsonStringify","keyLookup","endpoints","verifier","verifierId","lookupPromises","post","generateJsonRPCObject","verifier_id","toString","err","lookupResults","lookupShares","filter","x1","errorResult","x2","keyResult","x3","result","JSON","stringify","waitKeyLookup","timeout","setTimeout","keyAssign","torusNodePubs","lastPoint","firstPoint","signerHost","nodeNum","Math","floor","random","initialPoint","_context2","headers","pubKeyX","X","pubKeyY","Y","useAPIKey","signedData","acceptedErrorMsgs","includes","Torus","_ref$enableOneKey","enableOneKey","_ref$metadataHost","metadataHost","_ref$allowHost","allowHost","_ref$signerHost","_ref$serverTimeOffset","serverTimeOffset","ec","EC","doesKeyAssign","_ref3","isNewKey","finalKeyResult","assignResult","_finalKeyResult$keys$","typeOfUser","nonce","pubNonce","modifiedPubKey","upgraded","_yield$this$getOrSetN","finalX","finalY","address","_args","_context","keys","pub_key_X","pub_key_Y","getOrSetNonce","BN","keyFromPublic","y","getPublic","add","keyFromPrivate","getX","getY","generateAddressFromPubKey","privKeyHex","metadataNonce","torusKeyHex","customKeyHex","torusKey","privKey","sub","umod","curve","n","customKey","newMetadataNonce","generateMetadataParams","setMetadata","indexes","verifierParams","idToken","promiseArr","tmpKey","pubKey","tokenCommitment","p","_args5","extraParams","_context5","get","generatePrivate","keccak256","messageprefix","tokencommitment","temppubx","temppuby","verifieridentifier","completedRequests","_typeof","promiseArrRequest","nodeSigs","encrypted","item","idtoken","nodesignatures","shareResponses","thresholdPublicKey","PublicKey","_context3","sharePromises","nodeIndex","sort","a","b","Index","cmp","Metadata","metadata","ephemPublicKey","Buffer","iv","mac","mode","decrypt","ciphertext","atob","Share","padStart","debug","all","sharesResolved","decryptedShares","curr","value","allCombis","_loop","currentCombi","currentCombiShares","v","shares","indices","derivedPrivateKey","lagrangeInterpolation","decryptedPubKey","decryptedPubKeyX","decryptedPubKeyY","privateKey","_ret","returnedKey","_context4","getNonce","_yield$_this$getNonce","getMetadata","ethAddress","generateAddressFromPrivKey","options","_context6","metadataResponse","key","setData","timestamp","Date","now","sig","sign","set_data","signature","r","_context7","secret","upper","lower","mul","neg","temp","delta","invm","publicKey","encode","ethAddressLower","toChecksumAddress","publicKeyX","publicKeyY","isExtended","_ref8","_nonce","_finalKeyResult$keys$2","_yield$this$getOrSetN2","_args8","_context8","_args9","getOnly","privKeyBN","nonceBN","enableAll","apiKey","setAPIKey","embedHost","setEmbedHost"],"sources":["../src/loglevel.js","../src/some.js","../src/utils.js","../src/torus.js"],"sourcesContent":["import loglevel from 'loglevel'\n\nconst log = loglevel.getLogger('torus.js')\nlog.disableAll()\n\nexport default log\n","function capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport class SomeError extends Error {\n  constructor({ errors, responses, predicate }) {\n    super('Unable to resolve enough promises.')\n    this.errors = errors\n    this.responses = responses\n    this.predicate = predicate\n  }\n}\n\nexport const Some = (promises, predicate) =>\n  new Promise((resolve, reject) => {\n    let finishedCount = 0\n    const sharedState = { resolved: false }\n    const errorArr = new Array(promises.length).fill(undefined)\n    const resultArr = new Array(promises.length).fill(undefined)\n    let predicateError\n    promises.forEach((x, index) => {\n      x.then((resp) => {\n        resultArr[index] = resp\n        return undefined\n      })\n        .catch((error) => {\n          errorArr[index] = error\n        })\n        .finally(() => {\n          if (sharedState.resolved) return\n          predicate(resultArr.slice(0), sharedState)\n            .then((data) => {\n              sharedState.resolved = true\n              resolve(data)\n              return undefined\n            })\n            .catch((error) => {\n              // log only the last predicate error\n              predicateError = error\n            })\n            .finally((_) => {\n              finishedCount += 1\n              if (finishedCount === promises.length) {\n                const errors = Object.values(\n                  resultArr.reduce((acc, z) => {\n                    const { id, error } = z || {}\n                    if (error?.data?.length > 0) {\n                      if (error.data.startsWith('Error occurred while verifying params')) acc[id] = capitalizeFirstLetter(error.data)\n                      else acc[id] = error.data\n                    }\n                    return acc\n                  }, {})\n                )\n\n                if (errors.length > 0) {\n                  // Format-able errors\n                  const msg = errors.length > 1 ? `\\n${errors.map((it) => `• ${it}`).join('\\n')}` : errors[0]\n                  reject(new Error(msg))\n                } else {\n                  reject(\n                    new SomeError({\n                      errors: errorArr,\n                      responses: resultArr,\n                      predicate: predicateError?.message || predicateError,\n                    })\n                  )\n                }\n              }\n            })\n        })\n    })\n  })\n","import { generateJsonRPCObject, post } from '@toruslabs/http-helpers'\nimport JsonStringify from 'json-stable-stringify'\n\nimport log from './loglevel'\nimport { Some } from './some'\n\nexport class GetOrSetNonceError extends Error {}\n\nexport const kCombinations = (s, k) => {\n  let set = s\n  if (typeof set === 'number') {\n    set = Array.from({ length: set }, (_, i) => i)\n  }\n  if (k > set.length || k <= 0) {\n    return []\n  }\n\n  if (k === set.length) {\n    return [set]\n  }\n\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], [])\n  }\n\n  const combs = []\n  let tailCombs = []\n\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1)\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]])\n    }\n  }\n\n  return combs\n}\n\nexport const thresholdSame = (arr, t) => {\n  const hashMap = {}\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i])\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1\n    if (hashMap[str] === t) {\n      return arr[i]\n    }\n  }\n  return undefined\n}\n\nexport const keyLookup = async (endpoints, verifier, verifierId) => {\n  const lookupPromises = endpoints.map((x) =>\n    post(\n      x,\n      generateJsonRPCObject('VerifierLookupRequest', {\n        verifier,\n        verifier_id: verifierId.toString(),\n      })\n    ).catch((err) => log.error('lookup request failed', err))\n  )\n  return Some(lookupPromises, (lookupResults) => {\n    const lookupShares = lookupResults.filter((x1) => x1)\n    const errorResult = thresholdSame(\n      lookupShares.map((x2) => x2 && x2.error),\n      ~~(endpoints.length / 2) + 1\n    )\n    const keyResult = thresholdSame(\n      lookupShares.map((x3) => x3 && x3.result),\n      ~~(endpoints.length / 2) + 1\n    )\n    if (keyResult || errorResult) {\n      return Promise.resolve({ keyResult, errorResult })\n    }\n    return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`))\n  })\n}\n\nexport const waitKeyLookup = (endpoints, verifier, verifierId, timeout) =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject)\n    }, timeout)\n  })\n\nexport const keyAssign = async ({ endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId, signerHost }) => {\n  let nodeNum\n  let initialPoint\n  if (lastPoint === undefined) {\n    nodeNum = Math.floor(Math.random() * endpoints.length)\n    initialPoint = nodeNum\n  } else {\n    nodeNum = lastPoint % endpoints.length\n  }\n  if (nodeNum === firstPoint) throw new Error('Looped through all')\n  if (firstPoint !== undefined) initialPoint = firstPoint\n\n  const data = generateJsonRPCObject('KeyAssign', {\n    verifier,\n    verifier_id: verifierId.toString(),\n  })\n  try {\n    const signedData = await post(\n      signerHost,\n      data,\n      {\n        headers: {\n          pubKeyX: torusNodePubs[nodeNum].X,\n          pubKeyY: torusNodePubs[nodeNum].Y,\n        },\n      },\n      { useAPIKey: true }\n    )\n    return post(\n      endpoints[nodeNum],\n      { ...data, ...signedData },\n      {\n        headers: {\n          'Content-Type': 'application/json; charset=utf-8',\n        },\n      }\n    )\n  } catch (error) {\n    log.error(error)\n    const acceptedErrorMsgs = [\n      // Slow node\n      'Timed out',\n      // Happens when the node is not reachable (dns issue etc)\n      'TypeError: Failed to fetch', // All except iOS and Firefox\n      'TypeError: cancelled', // iOS\n      'TypeError: NetworkError when attempting to fetch resource.', // Firefox\n    ]\n    if (acceptedErrorMsgs.includes(error.message))\n      return keyAssign({ endpoints, torusNodePubs, lastPoint: nodeNum + 1, firstPoint: initialPoint, verifier, verifierId, signerHost })\n    throw new Error(\n      `Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || ''}`\n    )\n  }\n}\n","import { decrypt, generatePrivate, getPublic } from '@toruslabs/eccrypto'\nimport { generateJsonRPCObject, get, post, setAPIKey, setEmbedHost } from '@toruslabs/http-helpers'\nimport BN from 'bn.js'\nimport { ec as EC } from 'elliptic'\nimport stringify from 'json-stable-stringify'\nimport { keccak256, toChecksumAddress } from 'web3-utils'\n\nimport log from './loglevel'\nimport { Some } from './some'\nimport { GetOrSetNonceError, kCombinations, keyAssign, keyLookup, thresholdSame, waitKeyLookup } from './utils'\n\n// Implement threshold logic wrappers around public APIs\n// of Torus nodes to handle malicious node responses\nclass Torus {\n  constructor({\n    enableOneKey = false,\n    metadataHost = 'https://metadata.tor.us',\n    allowHost = 'https://signer.tor.us/api/allow',\n    signerHost = 'https://signer.tor.us/api/sign',\n    serverTimeOffset = 0,\n  } = {}) {\n    this.ec = new EC('secp256k1')\n    this.metadataHost = metadataHost\n    this.allowHost = allowHost\n    this.enableOneKey = enableOneKey\n    this.serverTimeOffset = serverTimeOffset || 0 // ms\n    this.signerHost = signerHost\n  }\n\n  static enableLogging(v = true) {\n    if (v) log.enableAll()\n    else log.disableAll()\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey)\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost)\n  }\n\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n  async getUserTypeAndAddress(endpoints, torusNodePubs, { verifier, verifierId }, doesKeyAssign = false) {\n    const { keyResult, errorResult } = (await keyLookup(endpoints, verifier, verifierId)) || {}\n    let isNewKey = false\n    let finalKeyResult\n    if (errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned')) {\n      if (!doesKeyAssign) {\n        throw new Error('Verifier + VerifierID has not yet been assigned')\n      }\n      await keyAssign({ endpoints, torusNodePubs, lastPoint: undefined, firstPoint: undefined, verifier, verifierId, signerHost: this.signerHost })\n      const assignResult = (await waitKeyLookup(endpoints, verifier, verifierId, 1000)) || {}\n      finalKeyResult = assignResult.keyResult\n      isNewKey = true\n    } else if (keyResult) {\n      finalKeyResult = keyResult\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n    }\n    if (finalKeyResult) {\n      const { pub_key_X: X, pub_key_Y: Y } = finalKeyResult.keys[0]\n      let typeOfUser\n      let nonce\n      let pubNonce\n      let modifiedPubKey\n      let upgraded\n\n      try {\n        ;({ typeOfUser, nonce, pubNonce, upgraded } = await this.getOrSetNonce(X, Y, undefined, !isNewKey))\n        nonce = new BN(nonce || '0', 16)\n      } catch {\n        throw new GetOrSetNonceError()\n      }\n      if (typeOfUser === 'v1') {\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n      } else if (typeOfUser === 'v2') {\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPublic({ x: pubNonce.x, y: pubNonce.y }).getPublic())\n      } else {\n        throw new Error('getOrSetNonce should always return typeOfUser.')\n      }\n      const finalX = modifiedPubKey.getX().toString(16)\n      const finalY = modifiedPubKey.getY().toString(16)\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY())\n      return { typeOfUser, nonce, pubNonce, upgraded, X: finalX, Y: finalY, address }\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n  }\n\n  async setCustomKey({ privKeyHex, metadataNonce, torusKeyHex, customKeyHex }) {\n    let torusKey\n    if (torusKeyHex) {\n      torusKey = new BN(torusKeyHex, 16)\n    } else {\n      const privKey = new BN(privKeyHex, 16)\n      torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n)\n    }\n    const customKey = new BN(customKeyHex, 16)\n    const newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n)\n    const data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey.toString(16))\n    await this.setMetadata(data)\n  }\n\n  async retrieveShares(endpoints, indexes, verifier, verifierParams, idToken, extraParams = {}) {\n    const promiseArr = []\n    await get(\n      this.allowHost,\n      {\n        headers: {\n          verifier,\n          verifier_id: verifierParams.verifier_id,\n        },\n      },\n      { useAPIKey: true }\n    )\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      } \n      */\n\n    // generate temporary private and public key that is used to secure receive shares\n    const tmpKey = generatePrivate()\n    const pubKey = getPublic(tmpKey).toString('hex')\n    const pubKeyX = pubKey.slice(2, 66)\n    const pubKeyY = pubKey.slice(66)\n    const tokenCommitment = keccak256(idToken)\n\n    // make commitment requests to endpoints\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(\n        endpoints[i],\n        generateJsonRPCObject('CommitmentRequest', {\n          messageprefix: 'mug00',\n          tokencommitment: tokenCommitment.slice(2),\n          temppubx: pubKeyX,\n          temppuby: pubKeyY,\n          verifieridentifier: verifier,\n        })\n      ).catch((err) => log.error('commitment', err))\n      promiseArr.push(p)\n    }\n    /*\n      ShareRequestParams struct {\n        Item []bijson.RawMessage `json:\"item\"`\n      }\n      ShareRequestItem struct {\n        IDToken            string          `json:\"idtoken\"`\n        NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n        VerifierIdentifier string          `json:\"verifieridentifier\"`\n      }\n      NodeSignature struct {\n        Signature   string\n        Data        string\n        NodePubKeyX string\n        NodePubKeyY string\n      }\n      CommitmentRequestResult struct {\n        Signature string `json:\"signature\"`\n        Data      string `json:\"data\"`\n        NodePubX  string `json:\"nodepubx\"`\n        NodePubY  string `json:\"nodepuby\"`\n      }\n      */\n    // send share request once k + t number of commitment requests have completed\n    return Some(promiseArr, (resultArr) => {\n      const completedRequests = resultArr.filter((x) => {\n        if (!x || typeof x !== 'object') {\n          return false\n        }\n        if (x.error) {\n          return false\n        }\n        return true\n      })\n      if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n        return Promise.resolve(resultArr)\n      }\n      return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`))\n    })\n      .then((responses) => {\n        const promiseArrRequest = []\n        const nodeSigs = []\n        for (let i = 0; i < responses.length; i += 1) {\n          if (responses[i]) nodeSigs.push(responses[i].result)\n        }\n        for (let i = 0; i < endpoints.length; i += 1) {\n          // eslint-disable-next-line promise/no-nesting\n          const p = post(\n            endpoints[i],\n            generateJsonRPCObject('ShareRequest', {\n              encrypted: 'yes',\n              item: [{ ...verifierParams, idtoken: idToken, nodesignatures: nodeSigs, verifieridentifier: verifier, ...extraParams }],\n            })\n          ).catch((err) => log.error('share req', err))\n          promiseArrRequest.push(p)\n        }\n        return Some(promiseArrRequest, async (shareResponses, sharedState) => {\n          /*\n              ShareRequestResult struct {\n                Keys []KeyAssignment\n              }\n                      / KeyAssignmentPublic -\n              type KeyAssignmentPublic struct {\n                Index     big.Int\n                PublicKey common.Point\n                Threshold int\n                Verifiers map[string][]string // Verifier => VerifierID\n              }\n\n              // KeyAssignment -\n              type KeyAssignment struct {\n                KeyAssignmentPublic\n                Share big.Int // Or Si\n              }\n            */\n          // check if threshold number of nodes have returned the same user public key\n          const completedRequests = shareResponses.filter((x) => x)\n          const thresholdPublicKey = thresholdSame(\n            shareResponses.map((x) => x && x.result && x.result.keys[0].PublicKey),\n            ~~(endpoints.length / 2) + 1\n          )\n          // optimistically run lagrange interpolation once threshold number of shares have been received\n          // this is matched against the user public key to ensure that shares are consistent\n          if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n            const sharePromises = []\n            const nodeIndex = []\n            for (let i = 0; i < shareResponses.length; i += 1) {\n              if (shareResponses[i] && shareResponses[i].result && shareResponses[i].result.keys && shareResponses[i].result.keys.length > 0) {\n                shareResponses[i].result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)))\n                if (shareResponses[i].result.keys[0].Metadata) {\n                  const metadata = {\n                    ephemPublicKey: Buffer.from(shareResponses[i].result.keys[0].Metadata.ephemPublicKey, 'hex'),\n                    iv: Buffer.from(shareResponses[i].result.keys[0].Metadata.iv, 'hex'),\n                    mac: Buffer.from(shareResponses[i].result.keys[0].Metadata.mac, 'hex'),\n                    mode: Buffer.from(shareResponses[i].result.keys[0].Metadata.mode, 'hex'),\n                  }\n                  sharePromises.push(\n                    // eslint-disable-next-line promise/no-nesting\n                    decrypt(tmpKey, {\n                      ...metadata,\n                      ciphertext: Buffer.from(atob(shareResponses[i].result.keys[0].Share).padStart(64, '0'), 'hex'),\n                    }).catch((err) => log.debug('share decryption', err))\n                  )\n                } else {\n                  sharePromises.push(Promise.resolve(Buffer.from(shareResponses[i].result.keys[0].Share.padStart(64, '0'), 'hex')))\n                }\n              } else {\n                sharePromises.push(Promise.resolve(undefined))\n              }\n              nodeIndex.push(new BN(indexes[i], 16))\n            }\n            const sharesResolved = await Promise.all(sharePromises)\n            if (sharedState.resolved) return undefined\n\n            const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n              if (curr) acc.push({ index: nodeIndex[index], value: new BN(curr) })\n              return acc\n            }, [])\n            // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n            const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1)\n            let privateKey\n            for (let j = 0; j < allCombis.length; j += 1) {\n              const currentCombi = allCombis[j]\n              const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index))\n              const shares = currentCombiShares.map((x) => x.value)\n              const indices = currentCombiShares.map((x) => x.index)\n              const derivedPrivateKey = this.lagrangeInterpolation(shares, indices)\n              const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex')\n              const decryptedPubKeyX = decryptedPubKey.slice(2, 66)\n              const decryptedPubKeyY = decryptedPubKey.slice(66)\n              if (\n                new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 &&\n                new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0\n              ) {\n                privateKey = derivedPrivateKey\n                break\n              }\n            }\n            if (privateKey === undefined) {\n              throw new Error('could not derive private key')\n            }\n            return privateKey\n          }\n          throw new Error('invalid')\n        })\n      })\n      .then(async (returnedKey) => {\n        let privateKey = returnedKey\n        const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), 'hex')).toString('hex')\n        const decryptedPubKeyX = decryptedPubKey.slice(2, 66)\n        const decryptedPubKeyY = decryptedPubKey.slice(66)\n        let metadataNonce\n        if (this.enableOneKey) {\n          const { nonce } = await this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey)\n          metadataNonce = new BN(nonce || '0', 16)\n        } else {\n          metadataNonce = await this.getMetadata({ pub_key_X: decryptedPubKeyX, pub_key_Y: decryptedPubKeyY })\n        }\n        log.debug('> torus.js/retrieveShares', { privKey: privateKey.toString(16), metadataNonce: metadataNonce.toString(16) })\n\n        privateKey = privateKey.add(metadataNonce).umod(this.ec.curve.n)\n\n        const ethAddress = this.generateAddressFromPrivKey(privateKey)\n        log.debug('> torus.js/retrieveShares', { ethAddress, privKey: privateKey.toString(16) })\n\n        // return reconstructed private key and ethereum address\n        return {\n          ethAddress,\n          privKey: privateKey.toString('hex', 64),\n          metadataNonce,\n        }\n      })\n  }\n\n  async getMetadata(data, options) {\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/get`, data, options, { useAPIKey: true })\n      if (!metadataResponse || !metadataResponse.message) {\n        return new BN(0)\n      }\n      return new BN(metadataResponse.message, 16) // nonce\n    } catch (error) {\n      log.error('get metadata error', error)\n      return new BN(0)\n    }\n  }\n\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString('hex', 64))\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16),\n    }\n    const sig = key.sign(keccak256(stringify(setData)).slice(2))\n    return {\n      pub_key_X: key.getPublic().getX().toString('hex'),\n      pub_key_Y: key.getPublic().getY().toString('hex'),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(sig.v).toString(16, 2), 'hex').toString('base64'),\n    }\n  }\n\n  async setMetadata(data, options) {\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/set`, data, options, { useAPIKey: true })\n      return metadataResponse.message // IPFS hash\n    } catch (error) {\n      log.error('set metadata error', error)\n      return ''\n    }\n  }\n\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null\n    }\n    let secret = new BN(0)\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1)\n      let lower = new BN(1)\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg())\n          upper = upper.umod(this.ec.curve.n)\n          let temp = nodeIndex[i].sub(nodeIndex[j])\n          temp = temp.umod(this.ec.curve.n)\n          lower = lower.mul(temp).umod(this.ec.curve.n)\n        }\n      }\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n)\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n)\n      secret = secret.add(delta)\n    }\n    return secret.umod(this.ec.curve.n)\n  }\n\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex')\n    const publicKey = key.getPublic().encode('hex').slice(2)\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38)}`\n    return toChecksumAddress(ethAddressLower)\n  }\n\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({ x: publicKeyX.toString('hex', 64), y: publicKeyY.toString('hex', 64) })\n    const publicKey = key.getPublic().encode('hex').slice(2)\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38)}`\n    return toChecksumAddress(ethAddressLower)\n  }\n\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n  async getPublicAddress(endpoints, torusNodePubs, { verifier, verifierId }, isExtended = false) {\n    log.debug('> torus.js/getPublicAddress', { endpoints, torusNodePubs, verifier, verifierId, isExtended })\n\n    let finalKeyResult\n    let isNewKey = false\n\n    const { keyResult, errorResult } = (await keyLookup(endpoints, verifier, verifierId)) || {}\n    if (errorResult && JSON.stringify(errorResult).includes('Verifier not supported')) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`)\n    } else if (errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned')) {\n      await keyAssign({ endpoints, torusNodePubs, lastPoint: undefined, firstPoint: undefined, verifier, verifierId, signerHost: this.signerHost })\n      const assignResult = (await waitKeyLookup(endpoints, verifier, verifierId, 1000)) || {}\n      finalKeyResult = assignResult.keyResult\n      isNewKey = true\n    } else if (keyResult) {\n      finalKeyResult = keyResult\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n    }\n    log.debug('> torus.js/getPublicAddress', { finalKeyResult, isNewKey })\n\n    if (finalKeyResult) {\n      let { pub_key_X: X, pub_key_Y: Y } = finalKeyResult.keys[0]\n      let typeOfUser\n      let nonce\n      let pubNonce\n      let modifiedPubKey\n      if (this.enableOneKey) {\n        let upgraded\n        try {\n          ;({ typeOfUser, nonce, pubNonce, upgraded } = await this.getOrSetNonce(X, Y, undefined, !isNewKey))\n          nonce = new BN(nonce || '0', 16)\n        } catch {\n          throw new GetOrSetNonceError()\n        }\n        if (typeOfUser === 'v1') {\n          modifiedPubKey = this.ec\n            .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n            .getPublic()\n            .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n        } else if (typeOfUser === 'v2') {\n          if (upgraded) {\n            // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n            modifiedPubKey = this.ec.keyFromPublic({ x: X.toString(16), y: Y.toString(16) }).getPublic()\n          } else {\n            modifiedPubKey = this.ec\n              .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n              .getPublic()\n              .add(this.ec.keyFromPublic({ x: pubNonce.x, y: pubNonce.y }).getPublic())\n          }\n        } else {\n          throw new Error('getOrSetNonce should always return typeOfUser.')\n        }\n      } else {\n        typeOfUser = 'v1'\n        nonce = await this.getMetadata({ pub_key_X: X, pub_key_Y: Y })\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n      }\n\n      X = modifiedPubKey.getX().toString(16)\n      Y = modifiedPubKey.getY().toString(16)\n\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY())\n      log.debug('> torus.js/getPublicAddress', { X, Y, address, typeOfUser, nonce: nonce?.toString(16), pubNonce })\n\n      if (!isExtended) return address\n      return {\n        typeOfUser,\n        address,\n        X,\n        Y,\n        metadataNonce: nonce,\n        pubNonce,\n      }\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n  }\n\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError\n  }\n\n  async getOrSetNonce(X, Y, privKey, getOnly = false) {\n    let data\n    const msg = getOnly ? 'getNonce' : 'getOrSetNonce'\n    if (privKey) {\n      data = this.generateMetadataParams(msg, privKey)\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: { data: msg },\n      }\n    }\n    return post(`${this.metadataHost}/get_or_set_nonce`, data, undefined, { useAPIKey: true })\n  }\n\n  async getNonce(X, Y, privKey) {\n    return this.getOrSetNonce(X, Y, privKey, true)\n  }\n\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16)\n    const nonceBN = new BN(nonce, 16)\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString('hex')\n  }\n}\n\nexport default Torus\n"]},"metadata":{},"sourceType":"module"}