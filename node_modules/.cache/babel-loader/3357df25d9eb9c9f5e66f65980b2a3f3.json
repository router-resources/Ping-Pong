{"ast":null,"code":"/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\n\nconst waterfall = require('async/waterfall');\nconst parallel = require('async/parallel');\nconst inherits = require('util').inherits;\nconst ethUtil = require('ethereumjs-util');\nconst sigUtil = require('eth-sig-util');\nconst extend = require('xtend');\nconst Semaphore = require('semaphore');\nconst Subprovider = require('./subprovider.js');\nconst estimateGas = require('../util/estimate-gas.js');\nconst hexRegex = /^[0-9A-Fa-f]+$/g;\nmodule.exports = HookedWalletSubprovider;\n\n// handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   eth_signTypedData_v3\n//   eth_signTypedData_v4\n//   personal_sign\n//   eth_decryptMessage\n//   encryption_public_key\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\ninherits(HookedWalletSubprovider, Subprovider);\nfunction HookedWalletSubprovider(opts) {\n  const self = this;\n  // control flow\n  self.nonceLock = Semaphore(1);\n\n  // data lookup\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts;\n  // high level override\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction;\n  if (opts.processMessage) self.processMessage = opts.processMessage;\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage;\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage;\n  // approval hooks\n  self.approveTransaction = opts.approveTransaction || self.autoApprove;\n  self.approveMessage = opts.approveMessage || self.autoApprove;\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove;\n  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove;\n  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove;\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove;\n  // actually perform the signature\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction || mustProvideInConstructor('signTransaction');\n  if (opts.signMessage) self.signMessage = opts.signMessage || mustProvideInConstructor('signMessage');\n  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor('signPersonalMessage');\n  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage || mustProvideInConstructor('decryptMessage');\n  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor('encryptionPublicKey');\n  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor('signTypedMessage');\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature;\n  // publish to network\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction;\n  // gas options\n  self.estimateGas = opts.estimateGas || self.estimateGas;\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice;\n}\nHookedWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n  self._parityRequests = {};\n  self._parityRequestCount = 0;\n\n  // switch statement is not block scoped\n  // sp we cant repeat var declarations\n  let txParams, msgParams, extraParams;\n  let message, address;\n  switch (payload.method) {\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        let result = accounts[0] || null;\n        end(null, result);\n      });\n      return;\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        end(null, accounts);\n      });\n      return;\n    case 'eth_sendTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processTransaction(txParams, cb)], end);\n      return;\n    case 'eth_signTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processSignTransaction(txParams, cb)], end);\n      return;\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0];\n      message = payload.params[1];\n      // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n      extraParams = payload.params[2] || {};\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message\n      });\n      waterfall([cb => self.validateMessage(msgParams, cb), cb => self.processMessage(msgParams, cb)], end);\n      return;\n    case 'personal_sign':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1];\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `;\n          warning += `[message, address]. This was previously handled incorrectly, `;\n          warning += `and has been corrected automatically. `;\n          warning += `Please switch this param order for smooth behavior in the future.`;\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validatePersonalMessage(msgParams, cb), cb => self.processPersonalMessage(msgParams, cb)], end);\n      }();\n    case 'eth_decryptMessage':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1];\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_decryptMessage method requires params ordered `;\n          warning += `[message, address]. This was previously handled incorrectly, `;\n          warning += `and has been corrected automatically. `;\n          warning += `Please switch this param order for smooth behavior in the future.`;\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validateDecryptMessage(msgParams, cb), cb => self.processDecryptMessage(msgParams, cb)], end);\n      }();\n    case 'encryption_public_key':\n      return function () {\n        const address = payload.params[0];\n        waterfall([cb => self.validateEncryptionPublicKey(address, cb), cb => self.processEncryptionPublicKey(address, cb)], end);\n      }();\n    case 'personal_ecRecover':\n      return function () {\n        message = payload.params[0];\n        let signature = payload.params[1];\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message\n        });\n        self.recoverPersonalSignature(msgParams, end);\n      }();\n    case 'eth_signTypedData':\n    case 'eth_signTypedData_v3':\n    case 'eth_signTypedData_v4':\n      return function () {\n        // process normally\n\n        const first = payload.params[0];\n        const second = payload.params[1];\n        if (resemblesAddress(first)) {\n          address = first;\n          message = second;\n        } else {\n          message = first;\n          address = second;\n        }\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validateTypedMessage(msgParams, cb), cb => self.processTypedMessage(msgParams, cb)], end);\n      }();\n    case 'parity_postTransaction':\n      txParams = payload.params[0];\n      self.parityPostTransaction(txParams, end);\n      return;\n    case 'parity_postSign':\n      address = payload.params[0];\n      message = payload.params[1];\n      self.parityPostSign(address, message, end);\n      return;\n    case 'parity_checkRequest':\n      return function () {\n        const requestId = payload.params[0];\n        self.parityCheckRequest(requestId, end);\n      }();\n    case 'parity_defaultAccount':\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        const account = accounts[0] || null;\n        end(null, account);\n      });\n      return;\n    default:\n      next();\n      return;\n  }\n};\n\n//\n// data lookup\n//\n\nHookedWalletSubprovider.prototype.getAccounts = function (cb) {\n  cb(null, []);\n};\n\n//\n// \"process\" high level flow\n//\n\nHookedWalletSubprovider.prototype.processTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeAndSubmitTx(txParams, cb)], cb);\n};\nHookedWalletSubprovider.prototype.processSignTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeTx(txParams, cb)], cb);\n};\nHookedWalletSubprovider.prototype.processMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signMessage(msgParams, cb)], cb);\n};\nHookedWalletSubprovider.prototype.processPersonalMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approvePersonalMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signPersonalMessage(msgParams, cb)], cb);\n};\nHookedWalletSubprovider.prototype.processDecryptMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveDecryptMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb), cb => self.decryptMessage(msgParams, cb)], cb);\n};\nHookedWalletSubprovider.prototype.processEncryptionPublicKey = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveEncryptionPublicKey(msgParams, cb), (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb), cb => self.encryptionPublicKey(msgParams, cb)], cb);\n};\nHookedWalletSubprovider.prototype.processTypedMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTypedMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signTypedMessage(msgParams, cb)], cb);\n};\n\n//\n// approval\n//\n\nHookedWalletSubprovider.prototype.autoApprove = function (txParams, cb) {\n  cb(null, true);\n};\nHookedWalletSubprovider.prototype.checkApproval = function (type, didApprove, cb) {\n  cb(didApprove ? null : new Error('User denied ' + type + ' signature.'));\n};\n\n//\n// parity\n//\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function (txParams, cb) {\n  const self = this;\n\n  // get next id\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n    const txHash = res.result;\n    self._parityRequests[reqId] = txHash;\n  });\n  cb(null, reqId);\n};\nHookedWalletSubprovider.prototype.parityPostSign = function (address, message, cb) {\n  const self = this;\n\n  // get next id\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n    const result = res.result;\n    self._parityRequests[reqId] = result;\n  });\n  cb(null, reqId);\n};\nHookedWalletSubprovider.prototype.parityCheckRequest = function (reqId, cb) {\n  const self = this;\n  const result = self._parityRequests[reqId] || null;\n  // tx not handled yet\n  if (!result) return cb(null, null);\n  // tx was rejected (or other error)\n  if (result.error) return cb(result.error);\n  // tx sent\n  cb(null, result);\n};\n\n//\n// signature and recovery\n//\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function (msgParams, cb) {\n  let senderHex;\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams);\n  } catch (err) {\n    return cb(err);\n  }\n  cb(null, senderHex);\n};\n\n//\n// validation\n//\n\nHookedWalletSubprovider.prototype.validateTransaction = function (txParams, cb) {\n  const self = this;\n  // shortcut: undefined sender is invalid\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`));\n  self.validateSender(txParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validatePersonalMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`));\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateDecryptMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`));\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateEncryptionPublicKey = function (address, cb) {\n  const self = this;\n  self.validateSender(address, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: \"${address}\"`));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateTypedMessage = function (msgParams, cb) {\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`));\n  this.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\nHookedWalletSubprovider.prototype.validateSender = function (senderAddress, cb) {\n  const self = this;\n  // shortcut: undefined sender is invalid\n  if (!senderAddress) return cb(null, false);\n  self.getAccounts(function (err, accounts) {\n    if (err) return cb(err);\n    const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;\n    cb(null, senderIsValid);\n  });\n};\n\n//\n// tx helpers\n//\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function (txParams, cb) {\n  const self = this;\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self), self.publishTransaction.bind(self)], function (err, txHash) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, txHash);\n    });\n  });\n};\nHookedWalletSubprovider.prototype.finalizeTx = function (txParams, cb) {\n  const self = this;\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self)], function (err, signedTx) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, {\n        raw: signedTx,\n        tx: txParams\n      });\n    });\n  });\n};\nHookedWalletSubprovider.prototype.publishTransaction = function (rawTx, cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx]\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\nHookedWalletSubprovider.prototype.estimateGas = function (txParams, cb) {\n  const self = this;\n  estimateGas(self.engine, txParams, cb);\n};\nHookedWalletSubprovider.prototype.getGasPrice = function (cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_gasPrice',\n    params: []\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\nHookedWalletSubprovider.prototype.fillInTxExtras = function (txParams, cb) {\n  const self = this;\n  const address = txParams.from;\n  // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {};\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self);\n  }\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending']\n    });\n  }\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams));\n  }\n  parallel(tasks, function (err, taskResults) {\n    if (err) return cb(err);\n    const result = {};\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice;\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result;\n    if (taskResults.gas) result.gas = taskResults.gas;\n    cb(null, extend(txParams, result));\n  });\n};\n\n// util\n\n// we use this to clean any custom params from the txParams\nfunction cloneTxParams(txParams) {\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce\n  };\n}\nfunction toLowerCase(string) {\n  return string.toLowerCase();\n}\nfunction resemblesAddress(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValid = ethUtil.isValidAddress(fixed);\n  return isValid;\n}\n\n// Returns true if resembles hex data\n// but definitely not a valid address.\nfunction resemblesData(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValidAddress = ethUtil.isValidAddress(fixed);\n  return !isValidAddress && isValidHex(string);\n}\nfunction isValidHex(data) {\n  const isString = typeof data === 'string';\n  if (!isString) return false;\n  const isHexPrefixed = data.slice(0, 2) === '0x';\n  if (!isHexPrefixed) return false;\n  const nonPrefixed = data.slice(2);\n  const isValid = nonPrefixed.match(hexRegex);\n  return isValid;\n}\nfunction mustProvideInConstructor(methodName) {\n  return function (params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'));\n  };\n}","map":{"version":3,"names":["waterfall","require","parallel","inherits","ethUtil","sigUtil","extend","Semaphore","Subprovider","estimateGas","hexRegex","module","exports","HookedWalletSubprovider","opts","self","nonceLock","getAccounts","processTransaction","processMessage","processPersonalMessage","processTypedMessage","approveTransaction","autoApprove","approveMessage","approvePersonalMessage","approveDecryptMessage","approveEncryptionPublicKey","approveTypedMessage","signTransaction","mustProvideInConstructor","signMessage","signPersonalMessage","decryptMessage","encryptionPublicKey","signTypedMessage","recoverPersonalSignature","publishTransaction","getGasPrice","prototype","handleRequest","payload","next","end","_parityRequests","_parityRequestCount","txParams","msgParams","extraParams","message","address","method","err","accounts","result","params","cb","validateTransaction","processSignTransaction","from","data","validateMessage","first","second","resemblesData","resemblesAddress","warning","console","warn","validatePersonalMessage","validateDecryptMessage","processDecryptMessage","validateEncryptionPublicKey","processEncryptionPublicKey","signature","sig","validateTypedMessage","parityPostTransaction","parityPostSign","requestId","parityCheckRequest","account","didApprove","checkApproval","finalizeAndSubmitTx","finalizeTx","type","Error","count","reqId","toString","emitPayload","error","res","txHash","senderHex","undefined","validateSender","senderIsValid","isValidHex","senderAddress","map","toLowerCase","indexOf","take","fillInTxExtras","bind","leave","signedTx","raw","tx","rawTx","engine","tasks","gasPrice","nonce","gas","cloneTxParams","taskResults","to","value","string","fixed","addHexPrefix","isValid","isValidAddress","isString","isHexPrefixed","slice","nonPrefixed","match","methodName"],"sources":["/Users/shivamsoni/Desktop/router/pingspong/Ping-Pong/node_modules/web3-provider-engine/subproviders/hooked-wallet.js"],"sourcesContent":["/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\n\nconst waterfall = require('async/waterfall')\nconst parallel = require('async/parallel')\nconst inherits = require('util').inherits\nconst ethUtil = require('ethereumjs-util')\nconst sigUtil = require('eth-sig-util')\nconst extend = require('xtend')\nconst Semaphore = require('semaphore')\nconst Subprovider = require('./subprovider.js')\nconst estimateGas = require('../util/estimate-gas.js')\nconst hexRegex = /^[0-9A-Fa-f]+$/g\n\nmodule.exports = HookedWalletSubprovider\n\n// handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   eth_signTypedData_v3\n//   eth_signTypedData_v4\n//   personal_sign\n//   eth_decryptMessage\n//   encryption_public_key\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\n\ninherits(HookedWalletSubprovider, Subprovider)\n\nfunction HookedWalletSubprovider(opts){\n  const self = this\n  // control flow\n  self.nonceLock = Semaphore(1)\n\n  // data lookup\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts\n  // high level override\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction\n  if (opts.processMessage) self.processMessage = opts.processMessage\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage\n  // approval hooks\n  self.approveTransaction = opts.approveTransaction || self.autoApprove\n  self.approveMessage = opts.approveMessage || self.autoApprove\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove\n  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove\n  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove\n  // actually perform the signature\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction  || mustProvideInConstructor('signTransaction')\n  if (opts.signMessage) self.signMessage = opts.signMessage  || mustProvideInConstructor('signMessage')\n  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage  || mustProvideInConstructor('signPersonalMessage')\n  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage  || mustProvideInConstructor('decryptMessage')\n  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey  || mustProvideInConstructor('encryptionPublicKey')\n  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage  || mustProvideInConstructor('signTypedMessage')\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature\n  // publish to network\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction\n  // gas options\n  self.estimateGas = opts.estimateGas || self.estimateGas\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n  self._parityRequests = {}\n  self._parityRequestCount = 0\n\n  // switch statement is not block scoped\n  // sp we cant repeat var declarations\n  let txParams, msgParams, extraParams\n  let message, address\n\n  switch(payload.method) {\n\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        let result = accounts[0] || null\n        end(null, result)\n      })\n      return\n\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        end(null, accounts)\n      })\n      return\n\n    case 'eth_sendTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_signTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processSignTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0]\n      message = payload.params[1]\n      // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n      extraParams = payload.params[2] || {}\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message,\n      })\n      waterfall([\n        (cb) => self.validateMessage(msgParams, cb),\n        (cb) => self.processMessage(msgParams, cb),\n      ], end)\n      return\n\n    case 'personal_sign':\n      return (function(){\n        // process normally\n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `\n          warning += `[message, address]. This was previously handled incorrectly, `\n          warning += `and has been corrected automatically. `\n          warning += `Please switch this param order for smooth behavior in the future.`\n          console.warn(warning)\n\n          address = payload.params[0]\n          message = payload.params[1]\n        } else {\n          message = payload.params[0]\n          address = payload.params[1]\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validatePersonalMessage(msgParams, cb),\n          (cb) => self.processPersonalMessage(msgParams, cb),\n        ], end)\n      })()\n\n    case 'eth_decryptMessage':\n      return (function(){\n        // process normally\n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_decryptMessage method requires params ordered `\n          warning += `[message, address]. This was previously handled incorrectly, `\n          warning += `and has been corrected automatically. `\n          warning += `Please switch this param order for smooth behavior in the future.`\n          console.warn(warning)\n\n          address = payload.params[0]\n          message = payload.params[1]\n        } else {\n          message = payload.params[0]\n          address = payload.params[1]\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validateDecryptMessage(msgParams, cb),\n          (cb) => self.processDecryptMessage(msgParams, cb),\n        ], end)\n      })()\n      \n    case 'encryption_public_key':\n      return (function(){\n        const address = payload.params[0]\n        \n        waterfall([\n          (cb) => self.validateEncryptionPublicKey(address, cb),\n          (cb) => self.processEncryptionPublicKey(address, cb),\n        ], end)\n      })()\n      \n    case 'personal_ecRecover':\n      return (function(){    \n        message = payload.params[0]\n        let signature = payload.params[1]\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message,\n        })\n        self.recoverPersonalSignature(msgParams, end)\n      })()\n\n    case 'eth_signTypedData':\n    case 'eth_signTypedData_v3':\n    case 'eth_signTypedData_v4':\n      return (function(){ \n        // process normally\n      \n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        if (resemblesAddress(first)) {\n          address = first\n          message = second\n        } else {\n          message = first\n          address = second\n        }\n\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validateTypedMessage(msgParams, cb),\n          (cb) => self.processTypedMessage(msgParams, cb),\n        ], end)\n      })()\n\n    case 'parity_postTransaction':\n      txParams = payload.params[0]\n      self.parityPostTransaction(txParams, end)\n      return\n\n    case 'parity_postSign':\n      address = payload.params[0]\n      message = payload.params[1]\n      self.parityPostSign(address, message, end)\n      return\n\n    case 'parity_checkRequest':\n      return (function(){\n        const requestId = payload.params[0]\n        self.parityCheckRequest(requestId, end)\n      })()\n\n    case 'parity_defaultAccount':\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        const account = accounts[0] || null\n        end(null, account)\n      })\n      return\n\n    default:\n      next()\n      return\n\n  }\n}\n\n//\n// data lookup\n//\n\nHookedWalletSubprovider.prototype.getAccounts = function(cb) {\n  cb(null, [])\n}\n\n\n//\n// \"process\" high level flow\n//\n\nHookedWalletSubprovider.prototype.processTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeAndSubmitTx(txParams, cb),\n  ], cb)\n}\n\n\nHookedWalletSubprovider.prototype.processSignTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeTx(txParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processPersonalMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approvePersonalMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signPersonalMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processDecryptMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveDecryptMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb),\n    (cb) => self.decryptMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processEncryptionPublicKey = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveEncryptionPublicKey(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb),\n    (cb) => self.encryptionPublicKey(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processTypedMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTypedMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signTypedMessage(msgParams, cb),\n  ], cb)\n}\n\n//\n// approval\n//\n\nHookedWalletSubprovider.prototype.autoApprove = function(txParams, cb) {\n  cb(null, true)\n}\n\nHookedWalletSubprovider.prototype.checkApproval = function(type, didApprove, cb) {\n  cb( didApprove ? null : new Error('User denied '+type+' signature.') )\n}\n\n//\n// parity\n//\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function(txParams, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const txHash = res.result\n    self._parityRequests[reqId] = txHash\n  })\n\n  cb(null, reqId)\n}\n\n\nHookedWalletSubprovider.prototype.parityPostSign = function(address, message, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const result = res.result\n    self._parityRequests[reqId] = result\n  })\n\n  cb(null, reqId)\n}\n\nHookedWalletSubprovider.prototype.parityCheckRequest = function(reqId, cb) {\n  const self = this\n  const result = self._parityRequests[reqId] || null\n  // tx not handled yet\n  if (!result) return cb(null, null)\n  // tx was rejected (or other error)\n  if (result.error) return cb(result.error)\n  // tx sent\n  cb(null, result)\n}\n\n//\n// signature and recovery\n//\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function(msgParams, cb) {\n  let senderHex\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams)\n  } catch (err) {\n    return cb(err)\n  }\n  cb(null, senderHex)\n}\n\n//\n// validation\n//\n\nHookedWalletSubprovider.prototype.validateTransaction = function(txParams, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`))\n  self.validateSender(txParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validatePersonalMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`))\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateDecryptMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`))\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateEncryptionPublicKey = function(address, cb){\n  const self = this\n\n  self.validateSender(address, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: \"${address}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateTypedMessage = function(msgParams, cb){\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`))\n  this.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateSender = function(senderAddress, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (!senderAddress) return cb(null, false)\n  self.getAccounts(function(err, accounts){\n    if (err) return cb(err)\n    const senderIsValid = (accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1)\n    cb(null, senderIsValid)\n  })\n}\n\n//\n// tx helpers\n//\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n      self.publishTransaction.bind(self),\n    ], function(err, txHash){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, txHash)\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.finalizeTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n    ], function(err, signedTx){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, {raw: signedTx, tx: txParams})\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.publishTransaction = function(rawTx, cb) {\n  const self = this\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx],\n  }, function(err, res){\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.estimateGas = function(txParams, cb) {\n  const self = this\n  estimateGas(self.engine, txParams, cb)\n}\n\nHookedWalletSubprovider.prototype.getGasPrice = function(cb) {\n  const self = this\n  self.emitPayload({ method: 'eth_gasPrice', params: [] }, function (err, res) {\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function(txParams, cb){\n  const self = this\n  const address = txParams.from\n  // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {}\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self)\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, { method: 'eth_getTransactionCount', params: [address, 'pending'] })\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams))\n  }\n\n  parallel(tasks, function(err, taskResults) {\n    if (err) return cb(err)\n\n    const result = {}\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result\n    if (taskResults.gas) result.gas = taskResults.gas\n\n    cb(null, extend(txParams, result))\n  })\n}\n\n// util\n\n// we use this to clean any custom params from the txParams\nfunction cloneTxParams(txParams){\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce,\n  }\n}\n\nfunction toLowerCase(string){\n  return string.toLowerCase()\n}\n\nfunction resemblesAddress (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValid = ethUtil.isValidAddress(fixed)\n  return isValid\n}\n\n// Returns true if resembles hex data\n// but definitely not a valid address.\nfunction resemblesData (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValidAddress = ethUtil.isValidAddress(fixed)\n  return !isValidAddress && isValidHex(string)\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string'\n  if (!isString) return false\n  const isHexPrefixed = data.slice(0,2) === '0x'\n  if (!isHexPrefixed) return false\n  const nonPrefixed = data.slice(2)\n  const isValid = nonPrefixed.match(hexRegex)\n  return isValid\n}\n\nfunction mustProvideInConstructor(methodName) {\n  return function(params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}