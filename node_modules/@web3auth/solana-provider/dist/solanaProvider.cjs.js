module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("eth-rpc-errors");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/openlogin-jrpc");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("bs58");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/base");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@solana/web3.js");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/base-controllers");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/base-provider");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/tweetnacl-js");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "PhantomInjectedProvider", function() { return /* reexport */ phantomInjectedProvider_PhantomInjectedProvider; });
__webpack_require__.d(__webpack_exports__, "TorusInjectedProvider", function() { return /* reexport */ torusInjectedProvider_TorusInjectedProvider; });
__webpack_require__.d(__webpack_exports__, "SolanaPrivateKeyProvider", function() { return /* reexport */ solanaPrivateKeyProvider_SolanaPrivateKeyProvider; });
__webpack_require__.d(__webpack_exports__, "SolanaWallet", function() { return /* reexport */ solanaWallet_SolanaWallet; });

// CONCATENATED MODULE: ./src/interface.ts

// CONCATENATED MODULE: ./src/providers/injectedProviders/interface.ts

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(4);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "@toruslabs/base-controllers"
var base_controllers_ = __webpack_require__(6);

// EXTERNAL MODULE: external "@toruslabs/openlogin-jrpc"
var openlogin_jrpc_ = __webpack_require__(1);

// EXTERNAL MODULE: external "@web3auth/base"
var base_ = __webpack_require__(3);

// EXTERNAL MODULE: external "@web3auth/base-provider"
var base_provider_ = __webpack_require__(7);

// CONCATENATED MODULE: ./src/rpc/solanaRpcMiddlewares.ts

function createGetAccountsMiddleware(_ref) {
  let {
    getAccounts
  } = _ref;
  return Object(openlogin_jrpc_["createAsyncMiddleware"])(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "getAccounts") return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided"); // This calls from the prefs controller

    const accounts = await getAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createRequestAccountsMiddleware(_ref2) {
  let {
    requestAccounts
  } = _ref2;
  return Object(openlogin_jrpc_["createAsyncMiddleware"])(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "requestAccounts") return next();
    if (!requestAccounts) throw new Error("WalletMiddleware - opts.requestAccounts not provided"); // This calls the UI login function

    const accounts = await requestAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createGenericJRPCMiddleware(targetMethod, handler) {
  return Object(openlogin_jrpc_["createAsyncMiddleware"])(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== targetMethod) return next();
    if (!handler) throw new Error("WalletMiddleware - ".concat(targetMethod, " not provided"));
    const result = await handler(request);
    response.result = result;
    return undefined;
  });
}
function createSolanaMiddleware(providerHandlers) {
  const {
    getAccounts,
    requestAccounts,
    signTransaction,
    signAndSendTransaction,
    signAllTransactions,
    signMessage,
    getPrivateKey
  } = providerHandlers;
  return Object(openlogin_jrpc_["mergeMiddleware"])([createRequestAccountsMiddleware({
    requestAccounts
  }), createGetAccountsMiddleware({
    getAccounts
  }), createGenericJRPCMiddleware("signTransaction", signTransaction), createGenericJRPCMiddleware("signAndSendTransaction", signAndSendTransaction), createGenericJRPCMiddleware("signAllTransactions", signAllTransactions), createGenericJRPCMiddleware("signMessage", signMessage), createGenericJRPCMiddleware("solanaPrivateKey", getPrivateKey)]);
}
function createChainSwitchMiddleware(_ref3) {
  let {
    addNewChainConfig,
    switchSolanaChain
  } = _ref3;
  return Object(openlogin_jrpc_["mergeMiddleware"])([createGenericJRPCMiddleware("addSolanaChain", addNewChainConfig), createGenericJRPCMiddleware("switchSolanaChain", switchSolanaChain)]);
}
function createAccountMiddleware(_ref4) {
  let {
    updatePrivatekey
  } = _ref4;
  return Object(openlogin_jrpc_["mergeMiddleware"])([createGenericJRPCMiddleware("updateAccount", updatePrivatekey)]);
}
// CONCATENATED MODULE: ./src/providers/injectedProviders/injectedProviderProxy.ts


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


function createInjectedProviderProxyMiddleware(provider) {
  return Object(openlogin_jrpc_["createAsyncMiddleware"])(async (req, res, _next) => {
    const result = await provider.request(_objectSpread({}, req));
    res.result = result;
  });
}
// EXTERNAL MODULE: external "@solana/web3.js"
var web3_js_ = __webpack_require__(5);

// EXTERNAL MODULE: external "bs58"
var external_bs58_ = __webpack_require__(2);
var external_bs58_default = /*#__PURE__*/__webpack_require__.n(external_bs58_);

// EXTERNAL MODULE: external "eth-rpc-errors"
var external_eth_rpc_errors_ = __webpack_require__(0);

// CONCATENATED MODULE: ./src/providers/injectedProviders/phantom/providerHandlers.ts



const getPhantomHandlers = injectedProvider => {
  const providerHandlers = {
    requestAccounts: async () => {
      return injectedProvider.publicKey ? [external_bs58_default.a.encode(injectedProvider.publicKey.toBytes())] : [];
    },
    getAccounts: async () => injectedProvider.publicKey ? [external_bs58_default.a.encode(injectedProvider.publicKey.toBytes())] : [],
    getPrivateKey: async () => {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    },
    signTransaction: async req => {
      const message = external_bs58_default.a.decode(req.params.message);
      const txn = web3_js_["Transaction"].from(message);
      const transaction = await injectedProvider.signTransaction(txn);
      return transaction;
    },
    signMessage: async req => {
      var _req$params;

      const message = await injectedProvider.request({
        method: "signMessage",
        params: {
          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message
        }
      });
      return message;
    },
    signAndSendTransaction: async req => {
      const message = external_bs58_default.a.decode(req.params.message);
      const txn = web3_js_["Transaction"].from(message);
      const txRes = await injectedProvider.signAndSendTransaction(txn);
      return {
        signature: txRes.signature
      };
    },
    signAllTransactions: async req => {
      var _req$params2, _req$params3;

      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const txns = req.params.message.map(msg => {
        const decodedMsg = external_bs58_default.a.decode(msg);
        return web3_js_["Transaction"].from(decodedMsg);
      });
      const transaction = await injectedProvider.signAllTransactions(txns);
      return transaction;
    }
  };
  return providerHandlers;
};
// CONCATENATED MODULE: ./src/providers/injectedProviders/phantom/phantomInjectedProvider.ts


function phantomInjectedProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function phantomInjectedProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? phantomInjectedProvider_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : phantomInjectedProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }








class phantomInjectedProvider_PhantomInjectedProvider extends base_provider_["BaseProvider"] {
  constructor(_ref) {
    let {
      config,
      state
    } = _ref;
    super({
      config: {
        chainConfig: phantomInjectedProvider_objectSpread(phantomInjectedProvider_objectSpread({}, config.chainConfig), {}, {
          chainNamespace: base_["CHAIN_NAMESPACES"].SOLANA
        })
      },
      state
    });
  }

  async switchChain(_) {
    return Promise.resolve();
  }

  async setupProvider(injectedProvider) {
    const providerHandlers = getPhantomHandlers(injectedProvider);
    const solanaMiddleware = createSolanaMiddleware(providerHandlers);
    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);
    const engine = new openlogin_jrpc_["JRPCEngine"]();
    engine.push(solanaMiddleware);
    engine.push(injectedProviderProxy);
    const provider = Object(base_controllers_["providerFromEngine"])(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork(injectedProvider);
  }

  async lookupNetwork(_) {
    const {
      chainConfig
    } = this.config;
    this.update({
      chainId: chainConfig.chainId
    });
    return chainConfig.chainId || ""; // const genesisHash = await phantomProvider.request<string>({
    //   method: "getGenesisHash",
    //   params: [],
    // });
    // const { chainConfig } = this.config;
    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);
    // if (chainConfig.chainId !== genesisHash.substring(0, 32))
    //   throw WalletInitializationError.invalidNetwork(
    //     `Wallet is connected to wrong network,Please change your network to ${
    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName
    //     } from phantom wallet extention.`
    //   );
    // return genesisHash.substring(0, 32);
  }

}
// CONCATENATED MODULE: ./src/providers/injectedProviders/torus/providerHandlers.ts



const getTorusHandlers = injectedProvider => {
  const providerHandlers = {
    requestAccounts: async () => {
      const accounts = await injectedProvider.request({
        method: "solana_requestAccounts",
        params: {}
      });
      return accounts;
    },
    getAccounts: async () => {
      const accounts = await injectedProvider.request({
        method: "solana_accounts",
        params: {}
      });
      return accounts;
    },
    getPrivateKey: async () => {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    },
    signMessage: async req => {
      var _req$params;

      const message = await injectedProvider.request({
        method: "sign_message",
        params: {
          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message
        }
      });
      return message;
    },
    signTransaction: async req => {
      var _req$params2;

      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const message = external_bs58_default.a.decode(req.params.message).toString("hex");
      const response = await injectedProvider.request({
        method: "sign_transaction",
        params: {
          message
        }
      });
      const buf = Buffer.from(response, "hex");
      const sendTx = web3_js_["Transaction"].from(buf);
      return sendTx;
    },
    signAndSendTransaction: async req => {
      var _req$params3;

      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const message = external_bs58_default.a.decode(req.params.message).toString("hex");
      const response = await injectedProvider.request({
        method: "send_transaction",
        params: {
          message
        }
      });
      return {
        signature: response
      };
    },
    signAllTransactions: async req => {
      var _req$params4, _req$params5;

      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const messages = [];

      for (const transaction of req.params.message) {
        const message = external_bs58_default.a.decode(transaction).toString("hex");
        messages.push(message);
      }

      const response = await injectedProvider.request({
        method: "sign_all_transactions",
        params: {
          message: messages
        }
      });
      return response;
    }
  };
  return providerHandlers;
};
// CONCATENATED MODULE: ./src/providers/injectedProviders/torus/torusInjectedProvider.ts


function torusInjectedProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function torusInjectedProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? torusInjectedProvider_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : torusInjectedProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









class torusInjectedProvider_TorusInjectedProvider extends base_provider_["BaseProvider"] {
  constructor(_ref) {
    let {
      config,
      state
    } = _ref;
    super({
      config: {
        chainConfig: torusInjectedProvider_objectSpread(torusInjectedProvider_objectSpread({}, config.chainConfig), {}, {
          chainNamespace: base_["CHAIN_NAMESPACES"].SOLANA
        })
      },
      state
    });
  }

  async switchChain(_) {
    return Promise.resolve();
  }

  async setupProvider(injectedProvider) {
    this.handleInjectedProviderUpdate(injectedProvider);
    await this.setupEngine(injectedProvider);
  }

  async lookupNetwork() {
    if (!this.provider) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Torus solana provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    const connectedChainId = await this.provider.request({
      method: "solana_chainId"
    });
    const connectedHexChainId = Object(base_["isHexStrict"])(connectedChainId.toString()) ? connectedChainId : "0x".concat(parseInt(connectedChainId, 10).toString(16));
    if (chainId !== connectedHexChainId) throw base_["WalletInitializationError"].rpcConnectionError("Invalid network, net_version is: ".concat(connectedHexChainId, ", expected: ").concat(chainId));
    this.update({
      chainId: connectedHexChainId
    });
    this.provider.emit("connect", {
      chainId: this.state.chainId
    });
    this.provider.emit("chainChanged", this.state.chainId);
    return this.state.chainId;
  }

  async setupEngine(injectedProvider) {
    const providerHandlers = getTorusHandlers(injectedProvider);
    const solanaMiddleware = createSolanaMiddleware(providerHandlers);
    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);
    const engine = new openlogin_jrpc_["JRPCEngine"]();
    engine.push(solanaMiddleware);
    engine.push(injectedProviderProxy);
    const provider = Object(base_controllers_["providerFromEngine"])(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }

  async handleInjectedProviderUpdate(injectedProvider) {
    injectedProvider.on("accountsChanged", async accounts => {
      this.provider.emit("accountsChanged", accounts);
    });
    injectedProvider.on("chainChanged", async chainId => {
      const connectedHexChainId = Object(base_["isHexStrict"])(chainId) ? chainId : "0x".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event

      this.configure({
        chainConfig: torusInjectedProvider_objectSpread(torusInjectedProvider_objectSpread({}, this.config.chainConfig), {}, {
          chainId: connectedHexChainId
        })
      });
      await this.setupProvider(injectedProvider);
    });
  }

}
// CONCATENATED MODULE: ./src/providers/injectedProviders/index.ts



// CONCATENATED MODULE: ./src/rpc/JrpcClient.ts


function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "solana_chainId") {
      res.result = chainId;
      return end();
    }

    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "solana_provider_config") {
      res.result = providerConfig;
      return end();
    }

    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  const {
    chainId,
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = Object(base_controllers_["createFetchMiddleware"])({
    rpcTarget
  });
  const networkMiddleware = Object(openlogin_jrpc_["mergeMiddleware"])([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
// EXTERNAL MODULE: external "@toruslabs/tweetnacl-js"
var tweetnacl_js_ = __webpack_require__(8);
var tweetnacl_js_default = /*#__PURE__*/__webpack_require__.n(tweetnacl_js_);

// CONCATENATED MODULE: ./src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts





async function getProviderHandlers(_ref) {
  let {
    privKey,
    getProviderEngineProxy
  } = _ref;

  const transactionGenerator = serializedTx => {
    const decodedTx = external_bs58_default.a.decode(serializedTx);
    const tx = web3_js_["Transaction"].populate(web3_js_["Message"].from(decodedTx));
    return tx;
  };

  const keyPairGenerator = () => {
    return web3_js_["Keypair"].fromSecretKey(Buffer.from(privKey, "hex"));
  };

  if (typeof privKey !== "string") throw base_["WalletInitializationError"].invalidParams("privKey must be a string");
  const keyPair = keyPairGenerator();
  const providerHandlers = {
    requestAccounts: async () => {
      return [keyPair.publicKey.toBase58()];
    },
    getAccounts: async () => [keyPair.publicKey.toBase58()],
    getPrivateKey: async () => privKey,
    signTransaction: async req => {
      var _req$params, _req$params2;

      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);
      transaction.partialSign(keyPair);
      return transaction;
    },
    signMessage: async req => {
      var _req$params3;

      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const signedMsg = tweetnacl_js_default.a.sign.detached(req.params.message, keyPair.secretKey);
      return signedMsg;
    },
    signAndSendTransaction: async req => {
      var _req$params4, _req$params5;

      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const _providerEngineProxy = getProviderEngineProxy();

      if (!_providerEngineProxy) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);
      transaction.sign(keyPair);
      const sig = await _providerEngineProxy.request({
        method: "sendTransaction",
        params: [external_bs58_default.a.encode(transaction.serialize())]
      });
      return {
        signature: sig
      };
    },
    signAllTransactions: async req => {
      var _req$params6, _req$params7;

      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {
        throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("message");
      }

      const signedTransactions = [];

      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {
        var _req$params8;

        const transaction = transactionGenerator(tx);
        transaction.partialSign(keyPair);
        signedTransactions.push(transaction);
      }

      return signedTransactions;
    }
  };
  return providerHandlers;
}
// CONCATENATED MODULE: ./src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts


function solanaPrivateKeyProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function solanaPrivateKeyProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? solanaPrivateKeyProvider_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : solanaPrivateKeyProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









class solanaPrivateKeyProvider_SolanaPrivateKeyProvider extends base_provider_["BaseProvider"] {
  constructor(_ref) {
    let {
      config,
      state
    } = _ref;
    super({
      config: {
        chainConfig: solanaPrivateKeyProvider_objectSpread(solanaPrivateKeyProvider_objectSpread({}, config.chainConfig), {}, {
          chainNamespace: base_["CHAIN_NAMESPACES"].SOLANA
        })
      },
      state
    });
  }

  async enable() {
    if (!this.state.privateKey) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }

  async setupProvider(privKey) {
    const providerHandlers = await getProviderHandlers({
      privKey,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const solanaMiddleware = createSolanaMiddleware(providerHandlers);
    const engine = new openlogin_jrpc_["JRPCEngine"]();
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(this.getChainSwitchMiddleware());
    engine.push(this.getAccountMiddleware());
    engine.push(solanaMiddleware);
    engine.push(networkMiddleware);
    const provider = Object(base_controllers_["providerFromEngine"])(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }

  async updateAccount(params) {
    if (!this._providerEngineProxy) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const existingKey = await this._providerEngineProxy.request({
      method: "solanaPrivateKey"
    });

    if (existingKey !== params.privateKey) {
      await this.setupProvider(params.privateKey);

      this._providerEngineProxy.emit("accountsChanged", {
        accounts: await this._providerEngineProxy.request({
          method: "requestAccounts"
        })
      });
    }
  }

  async switchChain(params) {
    if (!this._providerEngineProxy) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const privKey = await this._providerEngineProxy.request({
      method: "solanaPrivateKey"
    });
    await this.setupProvider(privKey);
  }

  async lookupNetwork() {
    if (!this._providerEngineProxy) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const health = await this._providerEngineProxy.request({
      method: "getHealth",
      params: []
    });
    const {
      chainConfig
    } = this.config;
    if (health !== "ok") throw base_["WalletInitializationError"].rpcConnectionError("Failed to lookup network for following rpc target: ".concat(chainConfig.rpcTarget));
    this.update({
      chainId: chainConfig.chainId
    });

    if (this.state.chainId !== chainConfig.chainId) {
      this.provider.emit("chainChanged", this.state.chainId);
      this.provider.emit("connect", {
        chainId: this.state.chainId
      });
    }

    return this.state.chainId;
  }

  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addNewChainConfig: async req => {
        if (!req.params) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing request params");
        const {
          chainId,
          chainName,
          rpcUrls,
          blockExplorerUrls,
          nativeCurrency
        } = req.params;
        if (!chainId) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing chainId in chainParams");
        if (!rpcUrls || rpcUrls.length === 0) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing rpcUrls in chainParams");
        if (!nativeCurrency) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing nativeCurrency in chainParams");
        this.addChain({
          chainNamespace: base_["CHAIN_NAMESPACES"].SOLANA,
          chainId,
          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "SOL",
          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Solana",
          displayName: chainName,
          rpcTarget: rpcUrls[0],
          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || ""
        });
      },
      switchSolanaChain: async req => {
        if (!req.params) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing request params");
        if (!req.params.chainId) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing chainId");
        await this.switchChain(req.params);
      }
    };
    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }

  getAccountMiddleware() {
    const accountHandlers = {
      updatePrivatekey: async req => {
        if (!req.params) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing request params");
        if (!req.params.privateKey) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing privateKey");
        const {
          privateKey
        } = req.params;
        await this.updateAccount({
          privateKey
        });
      }
    };
    return createAccountMiddleware(accountHandlers);
  }

}

defineProperty_default()(solanaPrivateKeyProvider_SolanaPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new solanaPrivateKeyProvider_SolanaPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});
// CONCATENATED MODULE: ./src/providers/privateKeyProvider/index.ts

// CONCATENATED MODULE: ./src/providers/index.ts


// CONCATENATED MODULE: ./src/solanaWallet.ts


class solanaWallet_SolanaWallet {
  constructor(provider) {
    defineProperty_default()(this, "provider", void 0);

    this.provider = provider;
  }

  async requestAccounts() {
    const accounts = await this.provider.request({
      method: "requestAccounts",
      params: {}
    });
    return accounts;
  }

  async signAndSendTransaction(transaction) {
    const {
      signature
    } = await this.provider.request({
      method: "signAndSendTransaction",
      params: {
        message: external_bs58_default.a.encode(transaction.serialize({
          requireAllSignatures: false
        }))
      }
    });
    return {
      signature
    };
  }

  async signTransaction(transaction) {
    const signedTransaction = await this.provider.request({
      method: "signTransaction",
      params: {
        message: external_bs58_default.a.encode(transaction.serialize({
          requireAllSignatures: false
        }))
      }
    });
    return signedTransaction;
  }

  async signAllTransactions(transactions) {
    const messages = transactions.map(transaction => {
      return external_bs58_default.a.encode(transaction.serialize({
        requireAllSignatures: false
      }));
    });
    const signedTransaction = await this.provider.request({
      method: "signAllTransactions",
      params: {
        message: messages
      }
    });
    return signedTransaction;
  }

  async signMessage(data) {
    const response = await this.provider.request({
      method: "signMessage",
      params: {
        message: data
      }
    });
    return response;
  }

  async request(args) {
    const result = await this.provider.request(args);
    return result;
  }

}
// CONCATENATED MODULE: ./src/index.ts




/***/ })
/******/ ]);
//# sourceMappingURL=solanaProvider.cjs.js.map