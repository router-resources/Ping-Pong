{"version":3,"sources":["webpack://Core/webpack/bootstrap","webpack://Core/external \"@web3auth/base\"","webpack://Core/external \"loglevel\"","webpack://Core/external \"@babel/runtime/helpers/defineProperty\"","webpack://Core/external \"@toruslabs/openlogin-jrpc\"","webpack://Core/./src/core.ts"],"names":["ADAPTER_CACHE_KEY","Web3AuthCore","SafeEventEmitter","constructor","options","ADAPTER_STATUS","NOT_READY","chainConfig","chainNamespace","Object","values","CHAIN_NAMESPACES","includes","WalletInitializationError","invalidParams","cachedAdapter","storageAvailable","window","sessionStorage","getItem","coreOptions","getChainConfig","chainId","subscribeToAdapterEvents","bind","provider","status","CONNECTED","connectedAdapterName","adapter","walletAdapters","_","Error","init","initPromises","keys","map","adapterName","chainConfigProxy","providedChainConfig","setChainConfig","autoConnect","catch","e","log","error","READY","Promise","all","configureAdapter","checkInitRequirements","adapterAlreadyExists","name","duplicateAdapterError","adapterNamespace","ADAPTER_NAMESPACES","MULTICHAIN","incompatibleChainNameSpace","currentChainNamespace","clearCache","removeItem","connectTo","walletName","loginParams","notFound","connect","logout","cleanup","WalletLoginError","notConnectedError","disconnect","getUserInfo","debug","walletAdapter","on","ADAPTER_EVENTS","data","cacheWallet","emit","DISCONNECTED","CONNECTING","ERRORED","ADAPTER_DATA_UPDATED","notReady","setItem"],"mappings":"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","file":"core.cjs.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = require(\"@web3auth/base\");","module.exports = require(\"loglevel\");","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","module.exports = require(\"@toruslabs/openlogin-jrpc\");","import { SafeEventEmitter } from \"@toruslabs/openlogin-jrpc\";\nimport {\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  CHAIN_NAMESPACES,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  getChainConfig,\n  IAdapter,\n  SafeEventEmitterProvider,\n  storageAvailable,\n  UserInfo,\n  WALLET_ADAPTER_TYPE,\n  WalletInitializationError,\n  WalletLoginError,\n} from \"@web3auth/base\";\nimport log from \"loglevel\";\n\nexport interface Web3AuthCoreOptions {\n  /**\n   * custom chain configuration for chainNamespace\n   *\n   * @defaultValue mainnet config of provided chainNamespace\n   */\n  chainConfig: Partial<CustomChainConfig> & Pick<CustomChainConfig, \"chainNamespace\">;\n}\n\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nexport class Web3AuthCore extends SafeEventEmitter {\n  readonly coreOptions: Web3AuthCoreOptions;\n\n  public connectedAdapterName: string | null = null;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public cachedAdapter: string | null = null;\n\n  protected walletAdapters: Record<string, IAdapter<unknown>> = {};\n\n  constructor(options: Web3AuthCoreOptions) {\n    super();\n    if (!options.chainConfig?.chainNamespace || !Object.values(CHAIN_NAMESPACES).includes(options.chainConfig?.chainNamespace))\n      throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n\n    this.cachedAdapter = storageAvailable(\"sessionStorage\") ? window.sessionStorage.getItem(ADAPTER_CACHE_KEY) : null;\n\n    this.coreOptions = {\n      ...options,\n      chainConfig: {\n        ...getChainConfig(options.chainConfig?.chainNamespace, options.chainConfig?.chainId),\n        ...options.chainConfig,\n      },\n    };\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n    return null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  public async init(): Promise<void> {\n    const initPromises = Object.keys(this.walletAdapters).map((adapterName) => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]);\n      // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n        const chainConfig = {\n          ...getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId),\n          ...providedChainConfig,\n        } as CustomChainConfig;\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n      return this.walletAdapters[adapterName].init({ autoConnect: this.cachedAdapter === adapterName }).catch((e) => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  public configureAdapter(adapter: IAdapter<unknown>): Web3AuthCore {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(`Wallet adapter for ${adapter.name} already exists`);\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace)\n      throw WalletInitializationError.incompatibleChainNameSpace(\n        `This wallet adapter belongs to ${adapter.adapterNamespace} which is incompatible with currently used namespace: ${providedChainConfig.chainNamespace}`\n      );\n\n    if (\n      adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN &&\n      adapter.currentChainNamespace &&\n      providedChainConfig.chainNamespace !== adapter.currentChainNamespace\n    ) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig as CustomChainConfig);\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  public clearCache() {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n  async connectTo<T>(walletName: WALLET_ADAPTER_TYPE, loginParams?: T): Promise<SafeEventEmitterProvider | null> {\n    if (!this.walletAdapters[walletName])\n      throw WalletInitializationError.notFound(`Please add wallet adapter for ${walletName} wallet, before connecting`);\n    return this.walletAdapters[walletName].connect(loginParams);\n  }\n\n  async logout(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  protected subscribeToAdapterEvents(walletAdapter: IAdapter<unknown>): void {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, (data: CONNECTED_EVENT_DATA) => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      this.emit(ADAPTER_EVENTS.CONNECTED, { ...data } as CONNECTED_EVENT_DATA);\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n    });\n\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, (data) => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n      if (storageAvailable(\"sessionStorage\")) {\n        const cachedAdapter = window.sessionStorage.getItem(ADAPTER_CACHE_KEY);\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, (data) => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, (data) => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, (data) => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n\n  protected checkInitRequirements(): void {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  private cacheWallet(walletName: string) {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n}\n"],"sourceRoot":""}