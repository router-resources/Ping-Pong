module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		0: 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + chunkId + ".web3auth.cjs.js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonpWeb3auth"] = window["webpackJsonpWeb3auth"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/base");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("loglevel");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/openlogin");

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultSolanaDappModalConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return defaultEvmDappModalConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return defaultSolanaWalletModalConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return defaultEvmWalletModalConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OPENLOGIN_PROVIDERS; });
/* harmony import */ var _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_web3auth_base__WEBPACK_IMPORTED_MODULE_1__);


const defaultSolanaDappModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_1__["CHAIN_NAMESPACES"].SOLANA,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["SOLANA_ADAPTERS"].TORUS_SOLANA]: {
      label: "Torus Solana Wallet",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["SOLANA_ADAPTERS"].OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["SOLANA_ADAPTERS"].PHANTOM]: {
      label: "Phantom",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const defaultEvmDappModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_1__["CHAIN_NAMESPACES"].EIP155,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["EVM_ADAPTERS"].TORUS_EVM]: {
      label: "Torus Wallet",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["EVM_ADAPTERS"].METAMASK]: {
      label: "MetaMask",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["EVM_ADAPTERS"].OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["EVM_ADAPTERS"].WALLET_CONNECT_V1]: {
      label: "Wallet Connect",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const defaultSolanaWalletModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_1__["CHAIN_NAMESPACES"].SOLANA,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["SOLANA_ADAPTERS"].OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const defaultEvmWalletModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_1__["CHAIN_NAMESPACES"].EIP155,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_1__["EVM_ADAPTERS"].OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const OPENLOGIN_PROVIDERS = [_toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].GOOGLE, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].FACEBOOK, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].TWITTER, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].REDDIT, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].DISCORD, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].TWITCH, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].APPLE, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].LINE, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].GITHUB, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].KAKAO, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].LINKEDIN, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].WEIBO, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].WECHAT, _toruslabs_openlogin__WEBPACK_IMPORTED_MODULE_0__["LOGIN_PROVIDER"].EMAIL_PASSWORDLESS];

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/ui");

/***/ }),
/* 6 */
/***/ (function(module, exports) {



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ modalManager_Web3Auth; });

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(4);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "@web3auth/base"
var base_ = __webpack_require__(0);

// EXTERNAL MODULE: external "@web3auth/core"
var core_ = __webpack_require__(8);

// EXTERNAL MODULE: external "@web3auth/ui"
var ui_ = __webpack_require__(5);
var ui_default = /*#__PURE__*/__webpack_require__.n(ui_);

// EXTERNAL MODULE: external "loglevel"
var external_loglevel_ = __webpack_require__(1);
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(3);

// CONCATENATED MODULE: ./src/default.ts


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


const getDefaultAdapterModule = async params => {
  const {
    name,
    customChainConfig,
    clientId
  } = params;
  if (!Object.values(base_["CHAIN_NAMESPACES"]).includes(customChainConfig.chainNamespace)) throw new Error("Invalid chainNamespace: ".concat(customChainConfig.chainNamespace));

  const finalChainConfig = _objectSpread(_objectSpread({}, Object(base_["getChainConfig"])(customChainConfig.chainNamespace, customChainConfig === null || customChainConfig === void 0 ? void 0 : customChainConfig.chainId)), customChainConfig || {});

  if (name === base_["WALLET_ADAPTERS"].TORUS_EVM) {
    const {
      TorusWalletAdapter
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(null, 10, 7));
    const adapter = new TorusWalletAdapter({
      chainConfig: finalChainConfig
    });
    return adapter;
  } else if (name === base_["WALLET_ADAPTERS"].TORUS_SOLANA) {
    const {
      SolanaWalletAdapter
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(null, 11, 7));
    const adapter = new SolanaWalletAdapter({
      chainConfig: finalChainConfig
    });
    return adapter;
  } else if (name === base_["WALLET_ADAPTERS"].METAMASK) {
    const {
      MetamaskAdapter
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(null, 12, 7));
    const adapter = new MetamaskAdapter({
      chainConfig: finalChainConfig
    });
    return adapter;
  } else if (name === base_["WALLET_ADAPTERS"].PHANTOM) {
    const {
      PhantomAdapter
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(null, 13, 7));
    const adapter = new PhantomAdapter({
      chainConfig: finalChainConfig
    });
    return adapter;
  } else if (name === base_["WALLET_ADAPTERS"].WALLET_CONNECT_V1) {
    const {
      WalletConnectV1Adapter
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(null, 14, 7));
    const adapter = new WalletConnectV1Adapter({
      chainConfig: finalChainConfig
    });
    return adapter;
  } else if (name === base_["WALLET_ADAPTERS"].OPENLOGIN) {
    const {
      OpenloginAdapter,
      getOpenloginDefaultOptions
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(null, 15, 7));
    const defaultOptions = getOpenloginDefaultOptions(customChainConfig.chainNamespace, customChainConfig === null || customChainConfig === void 0 ? void 0 : customChainConfig.chainId);
    const adapter = new OpenloginAdapter(_objectSpread(_objectSpread({}, defaultOptions), {}, {
      chainConfig: _objectSpread(_objectSpread({}, defaultOptions.chainConfig || {}), finalChainConfig),
      adapterSettings: _objectSpread(_objectSpread({}, defaultOptions.adapterSettings), {}, {
        clientId
      })
    }));
    return adapter;
  }

  throw new Error("Invalid wallet adapter name");
};
// CONCATENATED MODULE: ./src/utils.ts


function utils_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function utils_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? utils_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : utils_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




const getAdapterSocialLogins = function (adapterName, adapter) {
  let loginMethodsConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const finalLoginMethodsConfig = {};

  if (adapterName === base_["WALLET_ADAPTERS"].OPENLOGIN) {
    config["a" /* OPENLOGIN_PROVIDERS */].forEach(loginMethod => {
      const currentLoginMethodConfig = loginMethodsConfig[loginMethod] || {
        name: loginMethod,
        showOnMobile: true,
        showOnModal: true,
        showOnDesktop: true
      };
      finalLoginMethodsConfig[loginMethod] = utils_objectSpread({}, currentLoginMethodConfig);
      external_loglevel_default.a.debug("OpenLogin login method ui config", finalLoginMethodsConfig);
    });
  } else {
    throw new Error("".concat(adapterName, " is not a valid adapter"));
  }

  return finalLoginMethodsConfig;
};
// CONCATENATED MODULE: ./src/modalManager.ts


function modalManager_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function modalManager_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? modalManager_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : modalManager_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }








external_loglevel_default.a.enableAll();
external_loglevel_default.a.setLevel("debug");
class modalManager_Web3Auth extends core_["Web3AuthCore"] {
  constructor(options) {
    var _this$options$uiConfi, _this$options$uiConfi2;

    super(options);

    defineProperty_default()(this, "loginModal", void 0);

    defineProperty_default()(this, "options", void 0);

    defineProperty_default()(this, "modalConfig", config["b" /* defaultEvmDappModalConfig */]);

    this.options = modalManager_objectSpread({}, options);
    const providedChainConfig = this.options.chainConfig;

    if (providedChainConfig.chainNamespace === base_["CHAIN_NAMESPACES"].SOLANA) {
      if (options.authMode === "WALLET") {
        // default config for solana wallet modal
        this.modalConfig = config["e" /* defaultSolanaWalletModalConfig */];
      } else {
        // default config for solana dapp modal
        this.modalConfig = config["d" /* defaultSolanaDappModalConfig */];
      }
    } else if (providedChainConfig.chainNamespace === base_["CHAIN_NAMESPACES"].EIP155) {
      if (options.authMode === "WALLET") {
        // default config for evm wallet modal
        this.modalConfig = config["c" /* defaultEvmWalletModalConfig */];
      } else {
        // default config for evm dapp modal
        this.modalConfig = config["b" /* defaultEvmDappModalConfig */];
      }
    } else {
      throw new Error("Invalid chainNamespace provided: ".concat(providedChainConfig.chainNamespace));
    }

    this.loginModal = new ui_default.a({
      theme: (_this$options$uiConfi = this.options.uiConfig) === null || _this$options$uiConfi === void 0 ? void 0 : _this$options$uiConfi.theme,
      appLogo: ((_this$options$uiConfi2 = this.options.uiConfig) === null || _this$options$uiConfi2 === void 0 ? void 0 : _this$options$uiConfi2.appLogo) || "",
      version: "",
      adapterListener: this
    });
    this.subscribeToLoginModalEvents();
  }

  async initModal(params) {
    super.checkInitRequirements();
    await this.loginModal.initModal();
    const providedChainConfig = this.options.chainConfig; // merge default adapters with the custom configured adapters.

    const allAdapters = [...new Set([...Object.keys(this.modalConfig.adapters || {}), ...Object.keys(this.walletAdapters)])];
    const adapterConfigurationPromises = allAdapters.map(async adapterName => {
      var _this$modalConfig$ada, _params$modalConfig, _this$modalConfig$ada2, _this$modalConfig$ada3;

      // start with the default config of adapter.
      let adapterConfig = ((_this$modalConfig$ada = this.modalConfig.adapters) === null || _this$modalConfig$ada === void 0 ? void 0 : _this$modalConfig$ada[adapterName]) || {
        label: adapterName,
        showOnModal: true,
        showOnMobile: true,
        showOnDesktop: true
      }; // override the default config of adapter if some config is being provided by the user.

      if (params !== null && params !== void 0 && (_params$modalConfig = params.modalConfig) !== null && _params$modalConfig !== void 0 && _params$modalConfig[adapterName]) {
        adapterConfig = modalManager_objectSpread(modalManager_objectSpread({}, adapterConfig), params.modalConfig[adapterName]);
      }

      this.modalConfig.adapters[adapterName] = adapterConfig; // check if adapter is configured/added by user and exist in walletAdapters map.

      const adapter = this.walletAdapters[adapterName];
      external_loglevel_default.a.debug("adapter config", adapterName, (_this$modalConfig$ada2 = this.modalConfig.adapters) === null || _this$modalConfig$ada2 === void 0 ? void 0 : _this$modalConfig$ada2[adapterName].showOnModal); // if adapter is not custom configured then check if it is available in default adapters.
      // and if adapter is not hidden by user

      if (!adapter && (_this$modalConfig$ada3 = this.modalConfig.adapters) !== null && _this$modalConfig$ada3 !== void 0 && _this$modalConfig$ada3[adapterName].showOnModal) {
        // if adapter is not configured and some default configuration is available, use it.
        const ad = await getDefaultAdapterModule({
          name: adapterName,
          customChainConfig: this.options.chainConfig,
          clientId: this.options.clientId
        });
        this.walletAdapters[adapterName] = ad;
        return adapterName;
      } else if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === base_["ADAPTER_CATEGORY"].IN_APP || (adapter === null || adapter === void 0 ? void 0 : adapter.type) === base_["ADAPTER_CATEGORY"].EXTERNAL || adapterName === this.cachedAdapter) {
        var _this$modalConfig$ada4;

        if (!((_this$modalConfig$ada4 = this.modalConfig.adapters) !== null && _this$modalConfig$ada4 !== void 0 && _this$modalConfig$ada4[adapterName].showOnModal)) return; // add client id to openlogin adapter, same web3auth client id can be used in openlogin.
        // this id is being overridden if user is also passing client id in openlogin's adapter constructor.

        if (adapterName === base_["WALLET_ADAPTERS"].OPENLOGIN) {
          this.walletAdapters[adapterName].setAdapterSettings({
            clientId: this.options.clientId
          });
        } // if adapter doesn't have any chainConfig then we will set the chainConfig based of passed chainNamespace
        // and chainNamespace.


        if (!adapter.chainConfigProxy) {
          var _this$coreOptions$cha;

          const chainConfig = modalManager_objectSpread(modalManager_objectSpread({}, Object(base_["getChainConfig"])(providedChainConfig.chainNamespace, (_this$coreOptions$cha = this.coreOptions.chainConfig) === null || _this$coreOptions$cha === void 0 ? void 0 : _this$coreOptions$cha.chainId)), this.coreOptions.chainConfig);

          this.walletAdapters[adapterName].setChainConfig(chainConfig);
        }

        return adapterName;
      }
    });
    const adapterNames = await Promise.all(adapterConfigurationPromises);
    const hasInAppWallets = Object.values(this.walletAdapters).some(adapter => {
      if (adapter.type !== base_["ADAPTER_CATEGORY"].IN_APP) return false;
      if (this.modalConfig.adapters[adapter.name].showOnModal !== true) return false;
      if (!this.modalConfig.adapters[adapter.name].loginMethods) return true;
      if (Object.values(this.modalConfig.adapters[adapter.name].loginMethods).some(method => method.showOnModal)) return true;
      return false;
    });
    external_loglevel_default.a.debug(hasInAppWallets, this.walletAdapters, "hasInAppWallets"); // Now, initialize the adapters.

    const initPromises = adapterNames.map(async adapterName => {
      if (!adapterName) return;

      try {
        const adapter = this.walletAdapters[adapterName]; // only initialize a external adapter here if it is a cached adapter.

        if (this.cachedAdapter !== adapterName && adapter.type === base_["ADAPTER_CATEGORY"].EXTERNAL) {
          return;
        } // in-app wallets or cached wallet (being connected or already connected) are initialized first.
        // if adapter is configured thn only initialize in app or cached adapter.
        // external wallets are initialized on INIT_EXTERNAL_WALLET event.


        this.subscribeToAdapterEvents(adapter);
        if (adapter.status === base_["ADAPTER_STATUS"].NOT_READY) await adapter.init({
          autoConnect: this.cachedAdapter === adapterName
        }); // note: not adding cachedWallet to modal if it is external wallet.
        // adding it later if no in-app wallets are available.

        if (adapter.type === base_["ADAPTER_CATEGORY"].IN_APP) {
          this.initializeInAppWallet(adapterName);
        }
      } catch (error) {
        external_loglevel_default.a.error(error, "error while initializing adapter");
      }
    });
    this.status = base_["ADAPTER_STATUS"].READY;
    await Promise.all(initPromises);
    const hasExternalWallets = allAdapters.some(adapterName => {
      var _this$walletAdapters$, _this$modalConfig$ada5;

      return ((_this$walletAdapters$ = this.walletAdapters[adapterName]) === null || _this$walletAdapters$ === void 0 ? void 0 : _this$walletAdapters$.type) === base_["ADAPTER_CATEGORY"].EXTERNAL && ((_this$modalConfig$ada5 = this.modalConfig.adapters) === null || _this$modalConfig$ada5 === void 0 ? void 0 : _this$modalConfig$ada5[adapterName].showOnModal);
    });

    if (hasExternalWallets) {
      this.loginModal.initExternalWalletContainer();
    } // variable to check if we have any in app wallets
    // currently all default in app and external wallets can be hidden or shown based on config.


    if (!hasInAppWallets && hasExternalWallets) {
      // if no in app wallet is available then initialize external wallets in modal
      await this.initExternalWalletAdapters(false, {
        showExternalWalletsOnly: true
      });
    }
  }

  async connect() {
    // if (!this.loginModal.initialized) throw new Error("Login modal is not initialized");
    // if already connected return provider
    if (this.provider) return this.provider;
    this.loginModal.open();
    return new Promise((resolve, reject) => {
      this.once(base_["ADAPTER_EVENTS"].CONNECTED, () => {
        return resolve(this.provider);
      });
      this.once(base_["ADAPTER_EVENTS"].ERRORED, err => {
        return reject(err);
      });
    });
  }

  async initExternalWalletAdapters(externalWalletsInitialized, options) {
    if (externalWalletsInitialized) return;
    const adaptersConfig = {};
    const adaptersData = {};
    const adapterPromises = Object.keys(this.walletAdapters).map(async adapterName => {
      try {
        const adapter = this.walletAdapters[adapterName];

        if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === base_["ADAPTER_CATEGORY"].EXTERNAL) {
          external_loglevel_default.a.debug("init external wallet", this.cachedAdapter, adapterName);
          this.subscribeToAdapterEvents(adapter); // we are not initializing cached adapter here as it is already being initialized in initModal before.

          if (this.cachedAdapter === adapterName) {
            return;
          }

          if (adapter.status === base_["ADAPTER_STATUS"].NOT_READY) await adapter.init({
            autoConnect: this.cachedAdapter === adapterName
          });
          adaptersConfig[adapterName] = this.modalConfig.adapters[adapterName];
          adaptersData[adapterName] = adapter.adapterData || {};
          return adapterName;
        }
      } catch (error) {
        external_loglevel_default.a.error(error, "error while initializing adapter");
      }
    });
    const adapterInitResults = await Promise.all(adapterPromises);
    const finalAdaptersConfig = {};
    adapterInitResults.forEach(result => {
      if (result) {
        finalAdaptersConfig[result] = adaptersConfig[result];
      }
    });
    this.loginModal.addWalletLogins(finalAdaptersConfig, {
      showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly)
    });
  }

  initializeInAppWallet(adapterName) {
    external_loglevel_default.a.info("adapterInitResults", adapterName);

    if (this.walletAdapters[adapterName].type === base_["ADAPTER_CATEGORY"].IN_APP) {
      var _adapterName, _this$options$uiConfi3;

      this.loginModal.addSocialLogins(adapterName, getAdapterSocialLogins(adapterName, this.walletAdapters[adapterName], (_adapterName = this.modalConfig.adapters[adapterName]) === null || _adapterName === void 0 ? void 0 : _adapterName.loginMethods), ((_this$options$uiConfi3 = this.options.uiConfig) === null || _this$options$uiConfi3 === void 0 ? void 0 : _this$options$uiConfi3.loginMethodsOrder) || config["a" /* OPENLOGIN_PROVIDERS */]);
    }
  }

  subscribeToLoginModalEvents() {
    this.loginModal.on(ui_["LOGIN_MODAL_EVENTS"].LOGIN, async params => {
      try {
        await this.connectTo(params.adapter, params.loginParams);
      } catch (error) {
        external_loglevel_default.a.error("Error while connecting to adapter: ".concat(params.adapter), error);
      }
    });
    this.loginModal.on(ui_["LOGIN_MODAL_EVENTS"].INIT_EXTERNAL_WALLETS, async params => {
      await this.initExternalWalletAdapters(params.externalWalletsInitialized);
    });
    this.loginModal.on(ui_["LOGIN_MODAL_EVENTS"].DISCONNECT, async () => {
      try {
        await this.logout();
      } catch (error) {
        external_loglevel_default.a.error("Error while disconnecting", error);
      }
    });
    this.loginModal.on(ui_["LOGIN_MODAL_EVENTS"].MODAL_VISIBILITY, async visibility => {
      var _this$walletAdapters$2;

      external_loglevel_default.a.debug("is login modal visible", visibility);
      this.emit(ui_["LOGIN_MODAL_EVENTS"].MODAL_VISIBILITY, visibility);
      const walletConnectStatus = (_this$walletAdapters$2 = this.walletAdapters[base_["WALLET_ADAPTERS"].WALLET_CONNECT_V1]) === null || _this$walletAdapters$2 === void 0 ? void 0 : _this$walletAdapters$2.status;

      if (visibility && walletConnectStatus === base_["ADAPTER_STATUS"].READY) {
        // refreshing session for wallet connect whenever modal is opened.
        try {
          this.walletAdapters[base_["WALLET_ADAPTERS"].WALLET_CONNECT_V1].connect();
        } catch (error) {
          external_loglevel_default.a.error("Error while disconnecting to wallet connect in core", error);
        }
      }
    });
  }

}

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/core");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultSolanaDappModalConfig", function() { return _config__WEBPACK_IMPORTED_MODULE_0__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultEvmDappModalConfig", function() { return _config__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultSolanaWalletModalConfig", function() { return _config__WEBPACK_IMPORTED_MODULE_0__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultEvmWalletModalConfig", function() { return _config__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OPENLOGIN_PROVIDERS", function() { return _config__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_interface__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _interface__WEBPACK_IMPORTED_MODULE_1__) if(["default","defaultSolanaDappModalConfig","defaultEvmDappModalConfig","defaultSolanaWalletModalConfig","defaultEvmWalletModalConfig","OPENLOGIN_PROVIDERS"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _interface__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _modalManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Web3Auth", function() { return _modalManager__WEBPACK_IMPORTED_MODULE_2__["a"]; });





/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/torus-evm-adapter");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/torus-solana-adapter");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/metamask-adapter");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/phantom-adapter");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/wallet-connect-v1-adapter");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/openlogin-adapter");

/***/ })
/******/ ]);
//# sourceMappingURL=web3auth.cjs.js.map