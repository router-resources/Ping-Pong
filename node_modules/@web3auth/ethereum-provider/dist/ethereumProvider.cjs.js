module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("eth-rpc-errors");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/openlogin-jrpc");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("loglevel");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@metamask/eth-sig-util");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/base");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/base-controllers");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@web3auth/base-provider");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@ethereumjs/common");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@ethereumjs/tx");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("ethereumjs-util");

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "WalletConnectProvider", function() { return /* reexport */ WalletConnectProvider_WalletConnectProvider; });
__webpack_require__.d(__webpack_exports__, "EthereumPrivateKeyProvider", function() { return /* reexport */ EthereumPrivateKeyProvider_EthereumPrivateKeyProvider; });

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(4);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "@toruslabs/base-controllers"
var base_controllers_ = __webpack_require__(6);

// EXTERNAL MODULE: external "@toruslabs/openlogin-jrpc"
var openlogin_jrpc_ = __webpack_require__(1);

// EXTERNAL MODULE: external "@web3auth/base"
var base_ = __webpack_require__(5);

// EXTERNAL MODULE: external "@web3auth/base-provider"
var base_provider_ = __webpack_require__(7);

// EXTERNAL MODULE: external "eth-rpc-errors"
var external_eth_rpc_errors_ = __webpack_require__(0);

// CONCATENATED MODULE: ./src/rpc/walletMidddleware.ts


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




function resemblesAddress(str) {
  // hex prefix 2 + 20 bytes
  return str.length === 2 + 20 * 2;
}

function createWalletMiddleware(_ref) {
  let {
    getAccounts,
    getPrivateKey,
    processDecryptMessage,
    processEncryptionPublicKey,
    processEthSignMessage,
    processPersonalMessage,
    processTransaction,
    processSignTransaction,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4
  } = _ref;

  if (!getAccounts) {
    throw new Error("opts.getAccounts is required");
  } //
  // utility
  //

  /**
   * Validates the keyholder address, and returns a normalized (i.e. lowercase)
   * copy of it.
   *
   * an error
   */


  async function validateAndNormalizeKeyholder(address, req) {
    if (typeof address === "string" && address.length > 0) {
      // ensure address is included in provided accounts
      const accounts = await getAccounts(req);
      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());
      const normalizedAddress = address.toLowerCase();

      if (normalizedAccounts.includes(normalizedAddress)) {
        return normalizedAddress;
      }
    }

    throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams({
      message: "Invalid parameters: must provide an Ethereum address."
    });
  } //
  // account lookups
  //


  async function lookupAccounts(req, res) {
    res.result = await getAccounts(req);
  }

  async function lookupDefaultAccount(req, res) {
    const accounts = await getAccounts(req);
    res.result = accounts[0] || null;
  } //
  // transaction signatures
  //


  async function sendTransaction(req, res) {
    if (!processTransaction) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const txParams = req.params[0] || {
      from: ""
    };
    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
    res.result = await processTransaction(txParams, req);
  }

  async function signTransaction(req, res) {
    if (!processSignTransaction) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const txParams = req.params[0] || {
      from: ""
    };
    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
    res.result = await processSignTransaction(txParams, req);
  } //
  // message signatures
  //


  async function ethSign(req, res) {
    if (!processEthSignMessage) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req);
    const message = req.params[1];
    const extraParams = req.params[2] || {};

    const msgParams = _objectSpread(_objectSpread({}, extraParams), {}, {
      from: address,
      data: message
    });

    res.result = await processEthSignMessage(msgParams, req);
  }

  async function signTypedData(req, res) {
    if (!processTypedMessage) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const message = req.params[0];
    const address = await validateAndNormalizeKeyholder(req.params[1], req);
    const version = "V1";
    const extraParams = req.params[2] || {};

    const msgParams = _objectSpread(_objectSpread({}, extraParams), {}, {
      from: address,
      data: message
    });

    res.result = await processTypedMessage(msgParams, req, version);
  }

  async function signTypedDataV3(req, res) {
    if (!processTypedMessageV3) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req);
    const message = req.params[1];
    const version = "V3";
    const msgParams = {
      data: message,
      from: address,
      version
    };
    res.result = await processTypedMessageV3(msgParams, req, version);
  }

  async function signTypedDataV4(req, res) {
    if (!processTypedMessageV4) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req);
    const message = req.params[1];
    const version = "V4";
    const msgParams = {
      data: message,
      from: address,
      version
    };
    res.result = await processTypedMessageV4(msgParams, req, version);
  }

  async function personalSign(req, res) {
    if (!processPersonalMessage) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    } // process normally


    const firstParam = req.params[0];
    const secondParam = req.params[1]; // non-standard "extraParams" to be appended to our "msgParams" obj

    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.
    // To gracefully respect users who adopted this API early,
    // we are currently gracefully recovering from the wrong param order
    // when it is clearly identifiable.
    //
    // That means when the first param is definitely an address,
    // and the second param is definitely not, but is hex.

    let address, message;

    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
      let warning = "The eth_personalSign method requires params ordered ";
      warning += "[message, address]. This was previously handled incorrectly, ";
      warning += "and has been corrected automatically. ";
      warning += "Please switch this param order for smooth behavior in the future.";
      res.warning = warning;
      address = firstParam;
      message = secondParam;
    } else {
      message = firstParam;
      address = secondParam;
    }

    address = await validateAndNormalizeKeyholder(address, req);

    const msgParams = _objectSpread(_objectSpread({}, extraParams), {}, {
      from: address,
      data: message
    }); // eslint-disable-next-line require-atomic-updates


    res.result = await processPersonalMessage(msgParams, req);
  }

  async function encryptionPublicKey(req, res) {
    if (!processEncryptionPublicKey) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req);
    res.result = await processEncryptionPublicKey(address, req);
  }

  async function decryptMessage(req, res) {
    if (!processDecryptMessage) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    const ciphertext = req.params[0];
    const address = await validateAndNormalizeKeyholder(req.params[1], req);
    const extraParams = req.params[2] || {};

    const msgParams = _objectSpread(_objectSpread({}, extraParams), {}, {
      from: address,
      data: ciphertext
    });

    res.result = processDecryptMessage(msgParams, req);
  }

  async function fetchPrivateKey(req, res) {
    if (!getPrivateKey) {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }

    res.result = getPrivateKey(req);
  }

  return Object(openlogin_jrpc_["createScaffoldMiddleware"])({
    // account lookups
    eth_accounts: Object(openlogin_jrpc_["createAsyncMiddleware"])(lookupAccounts),
    eth_private_key: Object(openlogin_jrpc_["createAsyncMiddleware"])(fetchPrivateKey),
    eth_coinbase: Object(openlogin_jrpc_["createAsyncMiddleware"])(lookupDefaultAccount),
    // tx signatures
    eth_sendTransaction: Object(openlogin_jrpc_["createAsyncMiddleware"])(sendTransaction),
    eth_signTransaction: Object(openlogin_jrpc_["createAsyncMiddleware"])(signTransaction),
    // message signatures
    eth_sign: Object(openlogin_jrpc_["createAsyncMiddleware"])(ethSign),
    eth_signTypedData: Object(openlogin_jrpc_["createAsyncMiddleware"])(signTypedData),
    eth_signTypedData_v3: Object(openlogin_jrpc_["createAsyncMiddleware"])(signTypedDataV3),
    eth_signTypedData_v4: Object(openlogin_jrpc_["createAsyncMiddleware"])(signTypedDataV4),
    personal_sign: Object(openlogin_jrpc_["createAsyncMiddleware"])(personalSign),
    eth_getEncryptionPublicKey: Object(openlogin_jrpc_["createAsyncMiddleware"])(encryptionPublicKey),
    eth_decrypt: Object(openlogin_jrpc_["createAsyncMiddleware"])(decryptMessage)
  });
}
// CONCATENATED MODULE: ./src/rpc/ethRpcMiddlewares.ts



function createEthMiddleware(providerHandlers) {
  const {
    getAccounts,
    getPrivateKey,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    processEncryptionPublicKey,
    processDecryptMessage
  } = providerHandlers;
  const ethMiddleware = Object(openlogin_jrpc_["mergeMiddleware"])([Object(openlogin_jrpc_["createScaffoldMiddleware"])({
    eth_syncing: false
  }), createWalletMiddleware({
    getAccounts,
    getPrivateKey,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    processEncryptionPublicKey,
    processDecryptMessage
  })]);
  return ethMiddleware;
}
function createChainSwitchMiddleware(_ref) {
  let {
    addChain,
    switchChain
  } = _ref;

  async function addNewChain(req, res) {
    var _req$params;

    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;
    if (!chainParams) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing chain params");
    if (!chainParams.chainId) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing chainId in chainParams");
    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing rpcUrls in chainParams");
    if (!chainParams.nativeCurrency) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing nativeCurrency in chainParams");
    res.result = await addChain(chainParams);
  }

  async function updateChain(req, res) {
    var _req$params2;

    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;
    if (!chainParams) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing chainId");
    res.result = await switchChain(chainParams);
  }

  return Object(openlogin_jrpc_["createScaffoldMiddleware"])({
    wallet_addEthereumChain: Object(openlogin_jrpc_["createAsyncMiddleware"])(addNewChain),
    wallet_switchEthereumChain: Object(openlogin_jrpc_["createAsyncMiddleware"])(updateChain)
  });
} // #region account middlewares

function createAccountMiddleware(_ref2) {
  let {
    updatePrivatekey
  } = _ref2;

  async function updateAccount(req, res) {
    var _req$params3;

    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;
    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("Missing privateKey");
    res.result = await updatePrivatekey(accountParams);
  }

  return Object(openlogin_jrpc_["createScaffoldMiddleware"])({
    wallet_updateAccount: Object(openlogin_jrpc_["createAsyncMiddleware"])(updateAccount)
  });
} // #endregion account middlewares
// CONCATENATED MODULE: ./src/rpc/jrpcClient.ts


function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }

    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }

    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  const {
    chainId,
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = Object(base_controllers_["createFetchMiddleware"])({
    rpcTarget
  });
  const networkMiddleware = Object(openlogin_jrpc_["mergeMiddleware"])([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
// EXTERNAL MODULE: external "loglevel"
var external_loglevel_ = __webpack_require__(2);
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_);

// CONCATENATED MODULE: ./src/providers/injectedProviders/walletConnectUtils.ts


function getProviderHandlers(_ref) {
  let {
    connector
  } = _ref;
  return {
    getPrivateKey: async () => {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    },
    getAccounts: async _ => {
      const {
        accounts
      } = connector;

      if (accounts && accounts.length) {
        return accounts;
      }

      throw new Error("Failed to get accounts");
    },
    processTransaction: async (txParams, _) => {
      const result = await connector.sendTransaction(txParams);
      return result;
    },
    processSignTransaction: async (txParams, _) => {
      const result = await connector.signTransaction(txParams);
      return result;
    },
    processEthSignMessage: async (msgParams, _) => {
      const result = await connector.signMessage([msgParams.from, msgParams.data]);
      return result;
    },
    processPersonalMessage: async (msgParams, _) => {
      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);
      return result;
    },
    processTypedMessage: async (msgParams, _) => {
      external_loglevel_default.a.debug("processTypedMessage", msgParams);
      const result = await connector.signTypedData([msgParams.from, msgParams.data]);
      return result;
    },
    processTypedMessageV3: async _ => {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    },
    processTypedMessageV4: async _ => {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    },
    processEncryptionPublicKey: async _ => {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    },
    processDecryptMessage: _ => {
      throw external_eth_rpc_errors_["ethErrors"].rpc.methodNotSupported();
    }
  };
}
// CONCATENATED MODULE: ./src/providers/injectedProviders/WalletConnectProvider.ts


function WalletConnectProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function WalletConnectProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? WalletConnectProvider_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : WalletConnectProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









class WalletConnectProvider_WalletConnectProvider extends base_provider_["BaseProvider"] {
  constructor(_ref) {
    let {
      config,
      state,
      connector
    } = _ref;
    super({
      config: {
        chainConfig: WalletConnectProvider_objectSpread(WalletConnectProvider_objectSpread({}, config.chainConfig), {}, {
          chainNamespace: base_["CHAIN_NAMESPACES"].EIP155
        })
      },
      state: WalletConnectProvider_objectSpread(WalletConnectProvider_objectSpread({}, state || {}), {}, {
        chainId: "loading",
        accounts: []
      })
    });

    defineProperty_default()(this, "connector", null);

    this.connector = connector || null;
  }

  async enable() {
    if (!this.connector) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Connector is not initialized, pass wallet connect connector in constructor",
      code: 4902
    });
    await this.setupProvider(this.connector);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }

  async setupProvider(connector) {
    this.onConnectorStateUpdate(connector);
    await this.setupEngine(connector);
  }

  async switchChain(_ref2) {
    let {
      chainId
    } = _ref2;
    const currentChainConfig = this.getChainConfig(chainId);
    const {
      ticker,
      tickerName,
      rpcTarget
    } = currentChainConfig;
    this.update({
      chainId: "loading"
    });
    await this.connector.updateChain({
      chainId: Number.parseInt(chainId, 16),
      nativeCurrency: {
        name: tickerName,
        symbol: ticker
      },
      networkId: Number.parseInt(chainId, 10),
      rpcUrl: rpcTarget
    });
    this.configure({
      chainConfig: currentChainConfig
    });
    await this.lookupNetwork(this.connector);
  }

  async lookupNetwork(connector) {
    if (!connector.connected) throw base_["WalletLoginError"].notConnectedError("Wallet connect connector is not connected");
    if (!this.provider) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    const connectedHexChainId = Object(base_["isHexStrict"])(connector.chainId.toString()) ? connector.chainId : "0x".concat(connector.chainId.toString(16));
    if (chainId !== connectedHexChainId) throw base_["WalletInitializationError"].rpcConnectionError("Invalid network, net_version is: ".concat(connectedHexChainId, ", expected: ").concat(chainId));
    this.update({
      chainId: connectedHexChainId
    });
    this.provider.emit("connect", {
      chainId
    });
    this.provider.emit("chainChanged", this.state.chainId);
    return connectedHexChainId;
  }

  async setupEngine(connector) {
    const providerHandlers = getProviderHandlers({
      connector
    });
    this.update({
      accounts: connector.accounts || []
    });
    const ethMiddleware = createEthMiddleware(providerHandlers);
    const engine = new openlogin_jrpc_["JRPCEngine"]();
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(ethMiddleware);
    engine.push(networkMiddleware);
    const provider = Object(base_controllers_["providerFromEngine"])(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork(connector);
  }

  async onConnectorStateUpdate(connector) {
    connector.on("session_update", async (error, payload) => {
      if (!this.provider) throw base_["WalletLoginError"].notConnectedError("Wallet connect connector is not connected");

      if (error) {
        this.provider.emit("error", error);
        return;
      }

      const {
        accounts,
        chainId: connectedChainId,
        rpcUrl
      } = payload; // Check if accounts changed and trigger event

      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {
        this.update({
          accounts
        }); // await this.setupEngine(connector);

        this.provider.emit("accountsChanged", accounts);
      }

      const connectedHexChainId = Object(base_["isHexStrict"])(connectedChainId) ? connectedChainId : "0x".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event

      if (connectedChainId && this.state.chainId !== connectedHexChainId) {
        // Handle rpcUrl update
        this.configure({
          chainConfig: WalletConnectProvider_objectSpread(WalletConnectProvider_objectSpread({}, this.config.chainConfig), {}, {
            chainId: connectedHexChainId,
            rpcTarget: rpcUrl
          })
        });
        await this.setupEngine(connector);
      }
    });
  }

}

defineProperty_default()(WalletConnectProvider_WalletConnectProvider, "getProviderInstance", async params => {
  const providerFactory = new WalletConnectProvider_WalletConnectProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.connector);
  return providerFactory;
});
// CONCATENATED MODULE: ./src/providers/injectedProviders/index.ts

// EXTERNAL MODULE: external "@ethereumjs/common"
var common_ = __webpack_require__(8);
var common_default = /*#__PURE__*/__webpack_require__.n(common_);

// EXTERNAL MODULE: external "@ethereumjs/tx"
var tx_ = __webpack_require__(9);

// EXTERNAL MODULE: external "@metamask/eth-sig-util"
var eth_sig_util_ = __webpack_require__(3);

// EXTERNAL MODULE: external "ethereumjs-util"
var external_ethereumjs_util_ = __webpack_require__(10);

// CONCATENATED MODULE: ./src/providers/privateKeyProviders/ethPrivatekeyUtils.ts








async function getCommonConfiguration(supportsEIP1559, chainConfig) {
  const {
    displayName: name,
    chainId
  } = chainConfig;
  const hardfork = supportsEIP1559 ? common_["Hardfork"].London : common_["Hardfork"].Berlin;
  const customChainParams = {
    name,
    chainId: chainId === "loading" ? 0 : parseInt(chainId, 16),
    networkId: chainId === "loading" ? 0 : Number.parseInt(chainId, 10),
    hardfork
  };
  return common_default.a.custom(customChainParams);
}

function ethPrivatekeyUtils_getProviderHandlers(_ref) {
  let {
    privKey,
    chainConfig,
    getProviderEngineProxy
  } = _ref;
  return {
    getAccounts: async _ => ["0x".concat(Object(external_ethereumjs_util_["privateToAddress"])(Buffer.from(privKey, "hex")).toString("hex"))],
    getPrivateKey: async _ => privKey,
    processTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);
      const unsignedEthTx = tx_["TransactionFactory"].fromTxData(txParams, {
        common
      });
      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, "hex")).serialize();
      const txHash = await providerEngineProxy.request({
        method: "eth_sendRawTransaction",
        params: ["0x".concat(signedTx.toString("hex"))]
      });
      return txHash;
    },
    processSignTransaction: async (txParams, _) => {
      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);
      const unsignedEthTx = tx_["TransactionFactory"].fromTxData(txParams, {
        common
      });
      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, "hex")).serialize();
      return "0x".concat(signedTx.toString("hex"));
    },
    processEthSignMessage: async (msgParams, _) => {
      const rawMessageSig = Object(base_controllers_["signMessage"])(privKey, msgParams.data);
      return rawMessageSig;
    },
    processPersonalMessage: async (msgParams, _) => {
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const sig = Object(eth_sig_util_["personalSign"])({
        privateKey: privKeyBuffer,
        data: msgParams.data
      });
      return sig;
    },
    processTypedMessage: async (msgParams, _) => {
      external_loglevel_default.a.debug("processTypedMessage", msgParams);
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const sig = Object(eth_sig_util_["signTypedData"])({
        privateKey: privKeyBuffer,
        data: msgParams.data,
        version: eth_sig_util_["SignTypedDataVersion"].V1
      });
      return sig;
    },
    processTypedMessageV3: async (msgParams, _) => {
      external_loglevel_default.a.debug("processTypedMessageV3", msgParams);
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const sig = Object(eth_sig_util_["signTypedData"])({
        privateKey: privKeyBuffer,
        data: msgParams.data,
        version: eth_sig_util_["SignTypedDataVersion"].V3
      });
      return sig;
    },
    processTypedMessageV4: async (msgParams, _) => {
      external_loglevel_default.a.debug("processTypedMessageV4", msgParams);
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const sig = Object(eth_sig_util_["signTypedData"])({
        privateKey: privKeyBuffer,
        data: msgParams.data,
        version: eth_sig_util_["SignTypedDataVersion"].V4
      });
      return sig;
    },
    processEncryptionPublicKey: async (address, _) => {
      external_loglevel_default.a.info("processEncryptionPublicKey", address);
      return Object(eth_sig_util_["getEncryptionPublicKey"])(privKey);
    },
    processDecryptMessage: (msgParams, _) => {
      external_loglevel_default.a.info("processDecryptMessage", msgParams);
      const stripped = Object(external_ethereumjs_util_["stripHexPrefix"])(msgParams.data);
      const buff = Buffer.from(stripped, "hex");
      const decrypted = Object(eth_sig_util_["decrypt"])({
        encryptedData: JSON.parse(buff.toString("utf8")),
        privateKey: privKey
      });
      return decrypted;
    }
  };
}
// CONCATENATED MODULE: ./src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts


function EthereumPrivateKeyProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function EthereumPrivateKeyProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? EthereumPrivateKeyProvider_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : EthereumPrivateKeyProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }










class EthereumPrivateKeyProvider_EthereumPrivateKeyProvider extends base_provider_["BaseProvider"] {
  constructor(_ref) {
    let {
      config,
      state
    } = _ref;
    super({
      config: {
        chainConfig: EthereumPrivateKeyProvider_objectSpread(EthereumPrivateKeyProvider_objectSpread({}, config.chainConfig), {}, {
          chainNamespace: base_["CHAIN_NAMESPACES"].EIP155
        })
      },
      state
    });
  }

  async enable() {
    if (!this.state.privateKey) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }

  async setupProvider(privKey) {
    const providerHandlers = ethPrivatekeyUtils_getProviderHandlers({
      privKey,
      chainConfig: this.config.chainConfig,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const ethMiddleware = createEthMiddleware(providerHandlers);
    const chainSwitchMiddleware = this.getChainSwitchMiddleware();
    const engine = new openlogin_jrpc_["JRPCEngine"](); // Not a partial anymore because of checks in ctor

    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(ethMiddleware);
    engine.push(chainSwitchMiddleware);
    engine.push(this.getAccountMiddleware());
    engine.push(networkMiddleware);
    const provider = Object(base_controllers_["providerFromEngine"])(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }

  async updateAccount(params) {
    if (!this._providerEngineProxy) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const existingKey = await this._providerEngineProxy.request({
      method: "eth_private_key"
    });

    if (existingKey !== params.privateKey) {
      await this.setupProvider(params.privateKey);

      this._providerEngineProxy.emit("accountsChanged", {
        accounts: await this._providerEngineProxy.request({
          method: "eth_accounts"
        })
      });
    }
  }

  async switchChain(params) {
    if (!this._providerEngineProxy) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const privKey = await this._providerEngineProxy.request({
      method: "eth_private_key"
    });
    await this.setupProvider(privKey);
  }

  async lookupNetwork() {
    if (!this.provider) throw external_eth_rpc_errors_["ethErrors"].provider.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    if (!chainId) throw external_eth_rpc_errors_["ethErrors"].rpc.invalidParams("chainId is required while lookupNetwork");
    const network = await this._providerEngineProxy.request({
      method: "net_version",
      params: []
    });
    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw external_eth_rpc_errors_["ethErrors"].provider.chainDisconnected("Invalid network, net_version is: ".concat(network));
    external_loglevel_default.a.debug("this provider", this.provider, chainId, this.state.chainId);

    if (this.state.chainId !== chainId) {
      this.provider.emit("chainChanged", chainId);
      this.provider.emit("connect", {
        chainId
      });
    }

    this.update({
      chainId
    });
    return network;
  }

  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addChain: async params => {
        const {
          chainId,
          chainName,
          rpcUrls,
          blockExplorerUrls,
          nativeCurrency
        } = params;
        this.addChain({
          chainNamespace: "eip155",
          chainId,
          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "ETH",
          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Ether",
          displayName: chainName,
          rpcTarget: rpcUrls[0],
          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || ""
        });
      },
      switchChain: async params => {
        const {
          chainId
        } = params;
        await this.switchChain({
          chainId
        });
      }
    };
    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }

  getAccountMiddleware() {
    const accountHandlers = {
      updatePrivatekey: async params => {
        const {
          privateKey
        } = params;
        await this.updateAccount({
          privateKey
        });
      }
    };
    return createAccountMiddleware(accountHandlers);
  }

}

defineProperty_default()(EthereumPrivateKeyProvider_EthereumPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new EthereumPrivateKeyProvider_EthereumPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});
// CONCATENATED MODULE: ./src/providers/privateKeyProviders/index.ts

// CONCATENATED MODULE: ./src/providers/index.ts


// CONCATENATED MODULE: ./src/index.ts


/***/ })
/******/ ]);
//# sourceMappingURL=ethereumProvider.cjs.js.map